"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bitcoin = __importStar(require("bitcoinjs-lib"));
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const result_1 = require("./helpers/result");
const decodeRawTx = (rawTx, _network = 'bitcoin') => {
    try {
        if (!rawTx)
            return (0, result_1.err)('No rawTx provided to decodeRawTx');
        const network = getNetwork(_network);
        const tx = bitcoin.Transaction.fromHex(rawTx);
        const format = decodeFormat(tx);
        const inputs = decodeInput(tx);
        const outputs = decodeOutput(tx, network);
        const result = {};
        Object.keys(format).forEach((key) => (result[key] = format[key]));
        result.inputs = inputs;
        result.outputs = outputs;
        return (0, result_1.ok)(result);
    }
    catch (e) {
        return (0, result_1.err)(e);
    }
};
const decodeOutput = (tx, network) => {
    return tx.outs.map((out, n) => formatOutput(out, n, network));
};
const decodeInput = (tx) => {
    return tx.ins.map((input) => ({
        txid: input.hash.reverse().toString('hex'),
        n: input.index,
        script: bitcoin.script.toASM(input.script),
        sequence: input.sequence
    }));
};
const decodeFormat = (tx) => {
    return {
        txid: tx.getId(),
        version: tx.version,
        locktime: tx.locktime
    };
};
const formatOutput = (out, n, network) => {
    const vout = {
        satoshi: out.value,
        value: (1e-8 * out.value).toFixed(8),
        n: n,
        scriptPubKey: {
            asm: bitcoin.script.toASM(out.script),
            hex: out.script.toString('hex'),
            type: classifyOutputScript(out.script),
            addresses: []
        }
    };
    switch (vout.scriptPubKey.type) {
        case 'pubkeyhash':
        case 'pubkey':
        case 'multisig':
        case 'pay-to-witness-pubkey-hash':
        case 'pay-to-witness-script-hash':
        case 'pay-to-taproot':
        case 'scripthash':
            const address = bitcoin.address.fromOutputScript(out.script, network);
            vout.scriptPubKey.addresses.push(address);
            break;
    }
    return vout;
};
const classifyOutputScript = (script) => {
    const isOutput = (paymentFn) => {
        try {
            return paymentFn({ output: script });
        }
        catch (e) { }
    };
    if (isOutput(bitcoin.payments.p2pk)) {
        return 'pubkey';
    }
    else if (isOutput(bitcoin.payments.p2pkh)) {
        return 'pubkeyhash';
    }
    else if (isOutput(bitcoin.payments.p2ms)) {
        return 'multisig';
    }
    else if (isOutput(bitcoin.payments.p2wpkh)) {
        return 'pay-to-witness-pubkey-hash';
    }
    else if (isOutput(bitcoin.payments.p2wsh)) {
        return 'pay-to-witness-script-hash';
    }
    else if (isOutput(bitcoin.payments.p2sh)) {
        return 'scripthash';
    }
    else if (isOutput(bitcoin.payments.p2tr)) {
        return 'pay-to-taproot';
    }
    return 'nonstandard';
};
const getNetwork = (network) => {
    return bitcoinjs_lib_1.networks[network];
};
exports.default = decodeRawTx;
//# sourceMappingURL=index.js.map