import { EmitterSubscription } from 'react-native';
import { Result } from './utils/result';
import { EEventTypes, ELdkLogLevels, TAddPeerReq, TChannel, TInvoice, TFeeUpdateReq, TInitChannelManagerReq, TPaymentReq, TCreatePaymentReq, TSetTxConfirmedReq, TInitNetworkGraphReq, TCloseChannelReq, TSpendOutputsReq, TNetworkGraphChannelInfo, TNetworkGraphNodeInfo, TFileReadRes, TFileReadReq, TFileWriteReq, TClaimableBalance, TPaymentRoute, TUserConfig, TReconstructAndSpendOutputsReq, THeader, TAcceptChannelReq, TBackupServerDetails, TNodeSignReq, TBackedUpFileList, TDownloadScorer, TInitKeysManager, TSpendRecoveredForceCloseOutputsReq, TChannelMonitor, TCreateChannelReq, TFundChannelReq } from './utils/types';
declare class LDK {
    private readonly logListeners;
    private readonly ldkEvent;
    constructor();
    setAccountStoragePath(path: string): Promise<Result<string>>;
    initKeysManager({ seed, address, channelCloseDestinationScriptPublicKey, channelCloseWitnessProgram, channelCloseWitnessProgramVersion, }: TInitKeysManager): Promise<Result<string>>;
    downloadScorer({ scorerDownloadUrl, skipHoursThreshold, }: TDownloadScorer): Promise<Result<string>>;
    initNetworkGraph({ network, rapidGossipSyncUrl, skipHoursThreshold, }: TInitNetworkGraphReq): Promise<Result<string>>;
    initUserConfig(userConfig: TUserConfig): Promise<Result<string>>;
    initChannelManager(data: TInitChannelManagerReq): Promise<Result<string>>;
    restart(): Promise<Result<string>>;
    stop(): Promise<Result<string>>;
    setLogLevel(level: ELdkLogLevels, active: boolean): Promise<Result<string>>;
    setLogFilePath(path: string): Promise<Result<string>>;
    writeToLogFile(type: 'error' | 'info' | 'debug', line: string): Promise<Result<string>>;
    private writeErrorToLog;
    private writeDebugToLog;
    updateFees(fees: TFeeUpdateReq): Promise<Result<string>>;
    syncToTip(tip: THeader): Promise<Result<string>>;
    addPeer(peer: TAddPeerReq): Promise<Result<string>>;
    setTxConfirmed({ header, txData, height, }: TSetTxConfirmedReq): Promise<Result<string>>;
    setTxUnconfirmed(txid: string): Promise<Result<string>>;
    closeChannel({ channelId, counterPartyNodeId, force, }: TCloseChannelReq): Promise<Result<string>>;
    createChannel({ counterPartyNodeId, channelValueSats, pushSats, }: TCreateChannelReq): Promise<Result<string>>;
    fundChannel({ temporaryChannelId, counterPartyNodeId, fundingTransaction, }: TFundChannelReq): Promise<Result<string>>;
    forceCloseAllChannels(broadcastLatestTx: boolean): Promise<Result<string>>;
    acceptChannel({ temporaryChannelId, counterPartyNodeId, trustedPeer0Conf, }: TAcceptChannelReq): Promise<Result<string>>;
    spendOutputs({ descriptorsSerialized, outputs, change_destination_script, feerate_sat_per_1000_weight, }: TSpendOutputsReq): Promise<Result<string>>;
    decode({ paymentRequest }: TPaymentReq): Promise<Result<TInvoice>>;
    createPaymentRequest({ amountSats, description, expiryDeltaSeconds, }: TCreatePaymentReq): Promise<Result<TInvoice>>;
    processPendingHtlcForwards(): Promise<Result<string>>;
    claimFunds(paymentPreimage: string): Promise<Result<string>>;
    failHtlcBackwards(paymentHash: string): Promise<Result<string>>;
    pay({ paymentRequest: anyPaymentRequest, amountSats, timeout, }: TPaymentReq): Promise<Result<string>>;
    buildPathToDestination({ paymentRequest: anyPaymentRequest, amountSats, }: TPaymentReq): Promise<Result<TPaymentRoute>>;
    abandonPayment(paymentId: string): Promise<Result<string>>;
    onEvent(event: EEventTypes, callback: (res: any) => void): EmitterSubscription;
    version(): Promise<Result<{
        c_bindings: string;
        ldk: string;
    }>>;
    nodeId(): Promise<Result<string>>;
    listPeers(): Promise<Result<string[]>>;
    listChannels(): Promise<Result<TChannel[]>>;
    listUsableChannels(): Promise<Result<TChannel[]>>;
    listChannelFiles(): Promise<Result<string[]>>;
    listChannelMonitors(ignoreOpenChannels: boolean): Promise<Result<TChannelMonitor[]>>;
    networkGraphListNodeIds(): Promise<Result<string[]>>;
    networkGraphNodes(nodeIds: string[]): Promise<Result<TNetworkGraphNodeInfo[]>>;
    completeGraphNodes(): Promise<Result<TNetworkGraphNodeInfo[]>>;
    networkGraphListChannels(): Promise<Result<string[]>>;
    networkGraphChannel(shortChannelId: string): Promise<Result<TNetworkGraphChannelInfo>>;
    completeGraphChannels(): Promise<Result<TNetworkGraphChannelInfo[]>>;
    claimableBalances(ignoreOpenChannels: boolean): Promise<Result<TClaimableBalance[]>>;
    writeToFile({ fileName, path, content, format, remotePersist, }: TFileWriteReq): Promise<Result<boolean>>;
    readFromFile({ fileName, format, path, }: TFileReadReq): Promise<Result<TFileReadRes>>;
    reconstructAndSpendOutputs({ outputScriptPubKey, outputValue, outpointTxId, outpointIndex, feeRate, changeDestinationScript, }: TReconstructAndSpendOutputsReq): Promise<Result<string>>;
    spendRecoveredForceCloseOutputs({ transaction, confirmationHeight, changeDestinationScript, useInner, }: TSpendRecoveredForceCloseOutputsReq): Promise<Result<string[]>>;
    nodeSign({ message, messagePrefix, }: TNodeSignReq): Promise<Result<string>>;
    nodeStateDump(): Promise<Result<string>>;
    backupSetup({ seed, network, details, }: {
        seed: string;
        network: string;
        details: TBackupServerDetails;
    }): Promise<Result<string>>;
    restoreFromRemoteBackup({ overwrite, }: {
        overwrite: boolean;
    }): Promise<Result<boolean>>;
    backupSelfCheck(): Promise<Result<string>>;
    backupListFiles(): Promise<Result<TBackedUpFileList>>;
    backupFile(fileName: string, content: string): Promise<Result<string>>;
    fetchBackupFile(fileName: string): Promise<Result<string>>;
}
declare const _default: LDK;
export default _default;
