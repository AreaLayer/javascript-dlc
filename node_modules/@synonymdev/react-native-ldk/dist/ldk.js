var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
import { NativeModules, NativeEventEmitter, Platform, } from 'react-native';
import { err, ok } from './utils/result';
import { extractPaymentRequest } from './utils/helpers';
const LINKING_ERROR = "The package 'react-native-ldk' doesn't seem to be linked. Make sure: \n\n" +
    Platform.select({ ios: "- You have run 'pod install'\n", default: '' }) +
    '- You rebuilt the app after installing the package\n' +
    '- You are not using Expo managed workflow\n';
const NativeLDK = (_a = NativeModules === null || NativeModules === void 0 ? void 0 : NativeModules.Ldk) !== null && _a !== void 0 ? _a : new Proxy({}, {
    get() {
        throw new Error(LINKING_ERROR);
    },
});
class LDK {
    constructor() {
        this.logListeners = [];
        this.ldkEvent = new NativeEventEmitter(NativeModules.LdkEventEmitter);
    }
    setAccountStoragePath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.setAccountStoragePath(path);
                this.writeDebugToLog('setAccountStoragePath');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('setAccountStoragePath', e);
                return err(e);
            }
        });
    }
    initKeysManager({ seed, address, channelCloseDestinationScriptPublicKey, channelCloseWitnessProgram, channelCloseWitnessProgramVersion, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.initKeysManager(seed, address, channelCloseDestinationScriptPublicKey, channelCloseWitnessProgram, channelCloseWitnessProgramVersion);
                this.writeDebugToLog('initKeysManager');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('initKeysManager', e);
                return err(e);
            }
        });
    }
    downloadScorer({ scorerDownloadUrl, skipHoursThreshold, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.downloadScorer(scorerDownloadUrl, skipHoursThreshold !== null && skipHoursThreshold !== void 0 ? skipHoursThreshold : 3);
                this.writeDebugToLog('downloadScorer');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('downloadScorer', e);
                return err(e);
            }
        });
    }
    initNetworkGraph({ network, rapidGossipSyncUrl, skipHoursThreshold, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.initNetworkGraph(network, rapidGossipSyncUrl !== null && rapidGossipSyncUrl !== void 0 ? rapidGossipSyncUrl : '', skipHoursThreshold !== null && skipHoursThreshold !== void 0 ? skipHoursThreshold : 3);
                this.writeDebugToLog('initNetworkGraph', `Rapid gossip sync ${rapidGossipSyncUrl ? 'Enabled' : 'Disabled'}`);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('initNetworkGraph', e);
                return err(e);
            }
        });
    }
    initUserConfig(userConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.initUserConfig(userConfig);
                this.writeDebugToLog('initUserConfig', userConfig);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('initUserConfig', e);
                return err(e);
            }
        });
    }
    initChannelManager(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const { network, bestBlock } = data;
            try {
                const res = yield NativeLDK.initChannelManager(network, bestBlock.hash, bestBlock.height);
                this.writeDebugToLog('initChannelManager', data);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('initChannelManager', e);
                return err(e);
            }
        });
    }
    restart() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.restart();
                this.writeDebugToLog('restart');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('restart', e);
                return err(e);
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.stop();
                this.writeDebugToLog('stop');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('stop', e);
                return err(e);
            }
        });
    }
    setLogLevel(level, active) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.setLogLevel(level, active);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    setLogFilePath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.setLogFilePath(path);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    writeToLogFile(type, line) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const writeLine = `${type.toUpperCase()} (JS): ${line}`;
                console.log(writeLine);
                const res = yield NativeLDK.writeToLogFile(writeLine);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    writeErrorToLog(funcName, error) {
        this.writeToLogFile('error', `${funcName}() failed: ${error}`).catch(console.error);
    }
    writeDebugToLog(funcName, data = '') {
        this.writeToLogFile('debug', `${funcName}() success. ${data ? JSON.stringify(data) : ''}`).catch(console.error);
    }
    updateFees(fees) {
        return __awaiter(this, void 0, void 0, function* () {
            const { anchorChannelFee, nonAnchorChannelFee, channelCloseMinimum, minAllowedAnchorChannelRemoteFee, onChainSweep, minAllowedNonAnchorChannelRemoteFee, } = fees;
            try {
                const satsPerKw = 250;
                const res = yield NativeLDK.updateFees(anchorChannelFee * satsPerKw, nonAnchorChannelFee * satsPerKw, channelCloseMinimum * satsPerKw, minAllowedAnchorChannelRemoteFee * satsPerKw, onChainSweep * satsPerKw, minAllowedNonAnchorChannelRemoteFee * satsPerKw);
                this.writeDebugToLog('updateFees', fees);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('updateFees', e);
                return err(e);
            }
        });
    }
    syncToTip(tip) {
        return __awaiter(this, void 0, void 0, function* () {
            const { hex, hash, height } = tip;
            try {
                const res = yield NativeLDK.syncToTip(hex, hash, height);
                this.writeDebugToLog('syncToTip', tip);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('syncToTip', e);
                return err(e);
            }
        });
    }
    addPeer(peer) {
        return __awaiter(this, void 0, void 0, function* () {
            const { pubKey, address, port, timeout } = peer;
            try {
                const res = yield NativeLDK.addPeer(address, port, pubKey, timeout);
                this.writeDebugToLog('addPeer', peer);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('addPeer', e);
                return err(e);
            }
        });
    }
    setTxConfirmed({ header, txData, height, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.setTxConfirmed(header, txData, height);
                this.writeDebugToLog('setTxConfirmed');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('setTxConfirmed', e);
                return err(e);
            }
        });
    }
    setTxUnconfirmed(txid) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.setTxUnconfirmed(txid);
                this.writeDebugToLog('setTxUnconfirmed');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('setTxConfirmed', e);
                return err(e);
            }
        });
    }
    closeChannel({ channelId, counterPartyNodeId, force, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const peersRes = yield this.listPeers();
                if (peersRes.isErr()) {
                    return err(peersRes.error);
                }
                const connectedNodeId = peersRes.value.find((nodeId) => nodeId === counterPartyNodeId);
                if (!connectedNodeId) {
                    const peerDisconnectedError = 'Cannot cooperatively close channel as peer is not connected.';
                    this.writeErrorToLog('closeChannel', peerDisconnectedError);
                    return err(peerDisconnectedError);
                }
            }
            try {
                const res = yield NativeLDK.closeChannel(channelId, counterPartyNodeId, !!force);
                this.writeDebugToLog('closeChannel');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('closeChannel', e);
                return err(e);
            }
        });
    }
    createChannel({ counterPartyNodeId, channelValueSats, pushSats, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.createChannel(counterPartyNodeId, channelValueSats, pushSats);
                this.writeDebugToLog('createChannel');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('createChannel', e);
                return err(e);
            }
        });
    }
    fundChannel({ temporaryChannelId, counterPartyNodeId, fundingTransaction, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.fundChannel(temporaryChannelId, counterPartyNodeId, fundingTransaction);
                this.writeDebugToLog('fundChannel');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('fundChannel', e);
                return err(e);
            }
        });
    }
    forceCloseAllChannels(broadcastLatestTx) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.forceCloseAllChannels(broadcastLatestTx);
                this.writeDebugToLog('forceCloseAllChannels');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('forceCloseAllChannels', e);
                return err(e);
            }
        });
    }
    acceptChannel({ temporaryChannelId, counterPartyNodeId, trustedPeer0Conf, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.acceptChannel(temporaryChannelId, counterPartyNodeId, trustedPeer0Conf);
                this.writeDebugToLog('acceptChannel');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('acceptChannel', e);
                return err(e);
            }
        });
    }
    spendOutputs({ descriptorsSerialized, outputs, change_destination_script, feerate_sat_per_1000_weight, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.spendOutputs(descriptorsSerialized, outputs, change_destination_script, feerate_sat_per_1000_weight);
                this.writeDebugToLog('spendOutputs');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('spendOutputs', e);
                return err(e);
            }
        });
    }
    decode({ paymentRequest }) {
        return __awaiter(this, void 0, void 0, function* () {
            const cleanedPaymentRequest = extractPaymentRequest(paymentRequest);
            try {
                const res = yield NativeLDK.decode(cleanedPaymentRequest);
                this.writeDebugToLog('decode');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('decode', e);
                return err(e);
            }
        });
    }
    createPaymentRequest({ amountSats, description, expiryDeltaSeconds, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.createPaymentRequest(amountSats || 0, description, expiryDeltaSeconds);
                this.writeDebugToLog('createPaymentRequest');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('createPaymentRequest', e);
                return err(e);
            }
        });
    }
    processPendingHtlcForwards() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.processPendingHtlcForwards();
                this.writeDebugToLog('processPendingHtlcForwards');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('processPendingHtlcForwards', e);
                return err(e);
            }
        });
    }
    claimFunds(paymentPreimage) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.claimFunds(paymentPreimage);
                this.writeDebugToLog('claimFunds');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('claimFunds', e);
                return err(e);
            }
        });
    }
    failHtlcBackwards(paymentHash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.failHtlcBackwards(paymentHash);
                this.writeDebugToLog('failHtlcBackwards');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('failHtlcBackwards', e);
                return err(e);
            }
        });
    }
    pay({ paymentRequest: anyPaymentRequest, amountSats, timeout = 20000, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const paymentRequest = extractPaymentRequest(anyPaymentRequest);
            const channelsRes = yield this.listUsableChannels();
            if (channelsRes.isOk() && channelsRes.value.length === 0) {
                const noUsableChannelsError = 'No usable channels found';
                this.writeErrorToLog('pay', noUsableChannelsError);
                return err(noUsableChannelsError);
            }
            try {
                const timeoutSeconds = timeout / 1000;
                const res = yield NativeLDK.pay(paymentRequest, amountSats || 0, timeoutSeconds);
                this.writeDebugToLog('pay');
                return ok(res);
            }
            catch (e) {
                let resultError = err(e);
                if (resultError.code === 'invoice_payment_fail_routing') {
                    const decodedRes = yield this.decode({ paymentRequest });
                    if (decodedRes.isErr()) {
                        this.writeErrorToLog('pay', e);
                        return err(e);
                    }
                    const { route_hints, recover_payee_pub_key, amount_satoshis } = decodedRes.value;
                    let usefulMessage = `${resultError.error.message}.`;
                    if (route_hints.length === 0) {
                        usefulMessage = `${usefulMessage} No route hints found in payment request.`;
                    }
                    const graphRes = yield this.networkGraphNodes([recover_payee_pub_key]);
                    if (graphRes.isOk()) {
                        if (graphRes.value.length === 0) {
                            usefulMessage = `${usefulMessage} Node not found in network graph.`;
                        }
                    }
                    if (channelsRes.isOk()) {
                        let highestOutgoing = 0;
                        channelsRes.value.forEach(({ outbound_capacity_sat }) => {
                            if (outbound_capacity_sat > highestOutgoing) {
                                highestOutgoing = outbound_capacity_sat;
                            }
                        });
                        let amountToSendSats = amountSats || amount_satoshis || 0;
                        if (amountToSendSats > highestOutgoing) {
                            usefulMessage = `${usefulMessage} Not enough outgoing capacity.`;
                        }
                    }
                    this.writeErrorToLog('pay', usefulMessage);
                    return err(usefulMessage);
                }
                this.writeErrorToLog('pay', e);
                return err(e);
            }
        });
    }
    buildPathToDestination({ paymentRequest: anyPaymentRequest, amountSats, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelsRes = yield this.listUsableChannels();
            if (channelsRes.isErr()) {
                return err(channelsRes.error);
            }
            if (channelsRes.value.length < 1) {
                return err('No usable channels to build path');
            }
            const paymentRequest = extractPaymentRequest(anyPaymentRequest);
            const decodeRes = yield this.decode({ paymentRequest });
            if (decodeRes.isErr()) {
                return err(decodeRes.error);
            }
            const { recover_payee_pub_key: destNodeId, amount_satoshis } = decodeRes.value;
            const finalAmountSats = amountSats || amount_satoshis || 0;
            const nodesRes = yield this.networkGraphNodes([destNodeId]);
            if (nodesRes.isErr()) {
                return err(nodesRes.error);
            }
            if (nodesRes.value.length === 0) {
                return err('Destination node not found in network graph');
            }
            let route = [];
            let hopToDest;
            let firstHop;
            const finalNode = nodesRes.value[0];
            for (let index = 0; index < finalNode.shortChannelIds.length; index++) {
                if (hopToDest) {
                    continue;
                }
                const finalHopShortChannelId = finalNode.shortChannelIds[index];
                const channelToDest = yield this.networkGraphChannel(finalHopShortChannelId);
                if (channelToDest.isOk()) {
                    const { node_one, node_two } = channelToDest.value;
                    channelsRes.value.forEach((myChannel) => {
                        const { counterparty_node_id: ourCounterPartyNodeId, short_channel_id, config_forwarding_fee_base_msat, config_forwarding_fee_proportional_millionths, outbound_capacity_sat, } = myChannel;
                        if (outbound_capacity_sat < finalAmountSats) {
                            return;
                        }
                        if (!short_channel_id) {
                            return;
                        }
                        if (ourCounterPartyNodeId === node_one ||
                            ourCounterPartyNodeId === node_two) {
                            const percentBasedFee = Math.ceil((finalAmountSats *
                                config_forwarding_fee_proportional_millionths) /
                                1000000);
                            const fee = Math.max(config_forwarding_fee_base_msat, percentBasedFee);
                            firstHop = {
                                dest_node_id: ourCounterPartyNodeId,
                                short_channel_id: short_channel_id,
                                fee_sats: fee,
                            };
                            hopToDest = {
                                dest_node_id: finalNode.id,
                                short_channel_id: finalHopShortChannelId,
                                fee_sats: finalAmountSats,
                            };
                        }
                    });
                }
            }
            if (!firstHop) {
                return err('No first hop found');
            }
            if (!hopToDest) {
                return err('No last hop found');
            }
            route.push(firstHop);
            route.push(hopToDest);
            return ok(route);
        });
    }
    abandonPayment(paymentId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.abandonPayment(paymentId);
                this.writeDebugToLog('abandonPayment', paymentId);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('abandonPayment', e);
                return err(e);
            }
        });
    }
    onEvent(event, callback) {
        return this.ldkEvent.addListener(event, callback);
    }
    version() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.version();
                this.writeDebugToLog('version');
                return ok(JSON.parse(res));
            }
            catch (e) {
                this.writeErrorToLog('version', e);
                return err(e);
            }
        });
    }
    nodeId() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.nodeId();
                this.writeDebugToLog('nodeId');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('nodeId', e);
                return err(e);
            }
        });
    }
    listPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.listPeers();
                this.writeDebugToLog('listPeers', `Peers: ${res.length}`);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('listPeers', e);
                return err(e);
            }
        });
    }
    listChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.listChannels();
                this.writeDebugToLog('listChannels', `Channels: ${res.length}`);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('listChannels', e);
                return err(e);
            }
        });
    }
    listUsableChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.listUsableChannels();
                this.writeDebugToLog('listUsableChannels', `Usable channels: ${res.length}`);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('listUsableChannels', e);
                return err(e);
            }
        });
    }
    listChannelFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.listChannelFiles();
                this.writeDebugToLog('listChannelFiles', `Files: ${res.length}`);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('listChannelFiles', e);
                return err(e);
            }
        });
    }
    listChannelMonitors(ignoreOpenChannels) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.listChannelMonitors(ignoreOpenChannels);
                this.writeDebugToLog('listChannelMonitors', `Monitors: ${res.length}`);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('listChannelMonitors', e);
                return err(e);
            }
        });
    }
    networkGraphListNodeIds() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.networkGraphListNodeIds();
                this.writeDebugToLog('networkGraphListNodeIds');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('networkGraphListNodeIds', e);
                return err(e);
            }
        });
    }
    networkGraphNodes(nodeIds) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.networkGraphNodes(nodeIds);
                this.writeDebugToLog('networkGraphNodes');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('networkGraphNodes', e);
                return err(e);
            }
        });
    }
    completeGraphNodes() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.networkGraphListNodeIds();
                if (res.isErr()) {
                    return err(res.error);
                }
                if (res.value.length > 100) {
                    const tooManyError = `Too many nodes to query (${res.value.length})`;
                    this.writeErrorToLog('completeGraphNodes', tooManyError);
                    return err(tooManyError);
                }
                const nodeRes = yield this.networkGraphNodes(res.value);
                if (nodeRes.isErr()) {
                    this.writeErrorToLog('completeGraphNodes', nodeRes.error);
                    return err(nodeRes.error);
                }
                this.writeDebugToLog('completeGraphNodes');
                return ok(nodeRes.value);
            }
            catch (e) {
                this.writeErrorToLog('networkGraphNodes', e);
                return err(e);
            }
        });
    }
    networkGraphListChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.networkGraphListChannels();
                this.writeDebugToLog('networkGraphListChannels');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('networkGraphNodes', e);
                return err(e);
            }
        });
    }
    networkGraphChannel(shortChannelId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.networkGraphChannel(shortChannelId);
                this.writeDebugToLog('networkGraphChannel');
                return ok(Object.assign(Object.assign({}, res), { shortChannelId }));
            }
            catch (e) {
                this.writeErrorToLog('networkGraphChannel', e);
                return err(e);
            }
        });
    }
    completeGraphChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.networkGraphListChannels();
                let channels = [];
                if (res.isErr()) {
                    this.writeErrorToLog('completeGraphChannels', res.error);
                    return err(res.error);
                }
                for (let index = 0; index < res.value.length; index++) {
                    const channelRes = yield this.networkGraphChannel(res.value[index]);
                    if (channelRes.isErr()) {
                        this.writeErrorToLog('completeGraphChannels', channelRes.error);
                        return err(channelRes.error);
                    }
                    channels.push(channelRes.value);
                }
                this.writeDebugToLog('completeGraphChannels');
                return ok(channels);
            }
            catch (e) {
                this.writeErrorToLog('completeGraphChannels', e);
                return err(e);
            }
        });
    }
    claimableBalances(ignoreOpenChannels) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.claimableBalances(ignoreOpenChannels);
                this.writeDebugToLog('claimableBalances', res);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('claimableBalances', e);
                return err(e);
            }
        });
    }
    writeToFile({ fileName, path, content, format, remotePersist, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield NativeLDK.writeToFile(fileName, path || '', content, format || 'string', !!remotePersist);
                this.writeDebugToLog('writeToFile', fileName);
                return ok(true);
            }
            catch (e) {
                this.writeErrorToLog('writeToFile', e);
                return err(e);
            }
        });
    }
    readFromFile({ fileName, format, path, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.readFromFile(fileName, path || '', format || 'string');
                this.writeDebugToLog('readFromFile', fileName);
                return ok(Object.assign(Object.assign({}, res), { timestamp: Math.round(res.timestamp) }));
            }
            catch (e) {
                if (JSON.stringify(e).indexOf('Could not locate file') < 0) {
                    this.writeErrorToLog('readFromFile', e);
                }
                return err(e);
            }
        });
    }
    reconstructAndSpendOutputs({ outputScriptPubKey, outputValue, outpointTxId, outpointIndex, feeRate, changeDestinationScript, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.reconstructAndSpendOutputs(outputScriptPubKey, outputValue, outpointTxId, outpointIndex, feeRate, changeDestinationScript);
                this.writeDebugToLog('reconstructAndSpendOutputs', res);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('reconstructAndSpendOutputs', e);
                return err(e);
            }
        });
    }
    spendRecoveredForceCloseOutputs({ transaction, confirmationHeight, changeDestinationScript, useInner, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.spendRecoveredForceCloseOutputs(transaction, confirmationHeight, changeDestinationScript, useInner);
                this.writeDebugToLog('spendRecoveredForceCloseOutputs', res);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('spendRecoveredForceCloseOutputs', e);
                return err(e);
            }
        });
    }
    nodeSign({ message, messagePrefix = 'Lightning Signed Message:', }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.nodeSign(`${messagePrefix}${message}`);
                this.writeDebugToLog('nodeSign', res);
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('nodeSign', e);
                return err(e);
            }
        });
    }
    nodeStateDump() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.nodeStateDump();
                this.writeDebugToLog('nodeStateDump');
                return ok(res);
            }
            catch (e) {
                this.writeErrorToLog('nodeStateDump', e);
                return err(e);
            }
        });
    }
    backupSetup({ seed, network, details, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.backupSetup(seed, network, details.host, details.serverPubKey);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    restoreFromRemoteBackup({ overwrite, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.restoreFromRemoteBackup(overwrite);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    backupSelfCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.backupSelfCheck();
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    backupListFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.backupListFiles();
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    backupFile(fileName, content) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.backupFile(fileName, content);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
    fetchBackupFile(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield NativeLDK.fetchBackupFile(fileName);
                return ok(res);
            }
            catch (e) {
                return err(e);
            }
        });
    }
}
export default new LDK();
//# sourceMappingURL=ldk.js.map