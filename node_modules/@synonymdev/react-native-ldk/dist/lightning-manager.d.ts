import { Result } from './utils/result';
import { ENetworks, TAccount, TAccountBackup, TAddPeerReq, TBroadcastTransaction, TChannelManagerFundingGenerationReady, TChannelManagerClaim, TChannelManagerPaymentSent, TGetAddress, TGetScriptPubKeyHistory, TGetBestBlock, TGetTransactionData, THeader, TLdkPeers, TLdkStart, TPeer, TRegisterOutputEvent, TRegisterTxEvent, TLdkUnconfirmedTransactions, TLdkBroadcastedTransactions, TPaymentReq, TGetTransactionPosition, TChannel, TGetFees, TBolt11Invoices, TInvoice, TCreatePaymentReq, TBackupServerDetails, TLspLogEvent, TCreateChannelReq } from './utils/types';
import { EmitterSubscription } from 'react-native';
declare class LightningManager {
    currentBlock: THeader;
    unconfirmedTxs: TLdkUnconfirmedTransactions;
    watchTxs: TRegisterTxEvent[];
    watchOutputs: TRegisterOutputEvent[];
    confirmedWatchOutputs: string[];
    getBestBlock: TGetBestBlock;
    account: TAccount;
    getTransactionData: TGetTransactionData;
    getTransactionPosition: TGetTransactionPosition;
    network: ENetworks;
    baseStoragePath: string;
    logFilePath: string;
    getAddress: TGetAddress;
    addresses: string[];
    getScriptPubKeyHistory: TGetScriptPubKeyHistory;
    getFees: TGetFees;
    broadcastTransaction: TBroadcastTransaction;
    lspLogEvent: TLspLogEvent | undefined;
    pathFailedSubscription: EmitterSubscription | undefined;
    paymentFailedSubscription: EmitterSubscription | undefined;
    paymentSentSubscription: EmitterSubscription | undefined;
    private isSyncing;
    private pendingSyncPromises;
    private isStarting;
    private pendingStartPromises;
    private previousAccountName;
    constructor();
    setBaseStoragePath(path: string): Promise<Result<string>>;
    private resolveAllPendingStartPromises;
    private handleStartError;
    start({ account, getBestBlock, getTransactionData, getTransactionPosition, getAddress, getScriptPubKeyHistory, getFees, broadcastTransaction, network, rapidGossipSyncUrl, scorerDownloadUrl, forceCloseOnStartup, userConfig, skipParamCheck, skipRemoteBackups, lspLogEvent, }: TLdkStart): Promise<Result<string>>;
    setStorage(account: TAccount): Promise<Result<string>>;
    addPeers(): Promise<void>;
    setFees(): Promise<Result<string>>;
    setTrustedZeroConfPeerNodeIds(nodeIds: string[], merge?: boolean): Promise<Result<boolean>>;
    syncLdk({ timeout, retryAttempts, force, }?: {
        timeout?: number;
        retryAttempts?: number;
        force?: boolean;
    }): Promise<Result<string>>;
    private resolveAllPendingSyncPromises;
    private retrySyncOrReturnError;
    private handleSyncError;
    checkWatchTxs: (watchTxs: TRegisterTxEvent[], channels: TChannel[], bestBlock: THeader) => Promise<Result<string>>;
    resetAddressFileIfUnused: () => Promise<void>;
    saveAddressToFile: (address: string) => Promise<Result<boolean>>;
    readAddressesFromFile: () => Promise<string[]>;
    private saveConfirmedWatchOutput;
    getConfirmedWatchOutputs: () => Promise<string[]>;
    checkWatchOutputs: (watchOutputs: TRegisterOutputEvent[]) => Promise<Result<string>>;
    addPeer: ({ pubKey, address, port, timeout, }: TAddPeerReq) => Promise<Result<string>>;
    removePeer: ({ pubKey, address, port, }: TAddPeerReq) => Promise<Result<TPeer[]>>;
    getPeers: () => Promise<TLdkPeers>;
    restoreFromRemoteServer: ({ account, serverDetails, network, overwrite, }: {
        account: TAccount;
        serverDetails: TBackupServerDetails;
        network: ENetworks;
        overwrite?: boolean | undefined;
    }) => Promise<Result<string>>;
    importAccount: ({ backup, overwrite, }: {
        backup: string | TAccountBackup;
        overwrite?: boolean | undefined;
    }) => Promise<Result<TAccount>>;
    payWithTimeout: ({ paymentRequest, amountSats, timeout, }: TPaymentReq) => Promise<Result<TChannelManagerPaymentSent>>;
    private subscribeToPaymentResponses;
    unsubscribeFromPaymentSubscriptions: () => void;
    private getChangeDestinationScript;
    checkUnconfirmedTransactions: () => Promise<Result<string>>;
    private getLdkUnconfirmedTxs;
    private getLdkPaymentIds;
    private removeLdkPaymentId;
    private appendLdkPaymentId;
    getLdkPaymentsClaimed: () => Promise<TChannelManagerClaim[]>;
    getLdkPaymentsSent: () => Promise<TChannelManagerPaymentSent[]>;
    getBolt11Invoices: () => Promise<TBolt11Invoices>;
    appendBolt11Invoice: (bolt11: string) => Promise<void>;
    createAndStorePaymentRequest(req: TCreatePaymentReq): Promise<Result<TInvoice>>;
    getInvoiceFromPaymentHash: (paymentHash: string) => Promise<TInvoice | undefined>;
    private getLdkSpendableOutputs;
    getLdkBroadcastedTxs(includeConfirmed?: boolean): Promise<TLdkBroadcastedTransactions>;
    cleanupBroadcastedTxs(): Promise<void>;
    rebroadcastAllKnownTransactions(): Promise<any[]>;
    recoverOutputsFromForceClose(): Promise<Result<string>>;
    recoverOutputs(): Promise<Result<string>>;
    private saveUnconfirmedTx;
    private updateUnconfirmedTxs;
    private saveBroadcastedTxs;
    private saveLdkPeerData;
    private onRegisterTx;
    private onRegisterOutput;
    private onBroadcastTransaction;
    private onChannelManagerPaymentClaimable;
    private onChannelManagerPaymentSent;
    private onChannelManagerOpenChannelRequest;
    private onChannelManagerPaymentPathSuccessful;
    private onChannelManagerPaymentPathFailed;
    private onChannelManagerPaymentFailed;
    private onChannelManagerPendingHtlcsForwardable;
    private getOnChainSweepFeeRate;
    private onChannelManagerSpendableOutputs;
    private onChannelManagerChannelClosed;
    private onChannelManagerDiscardFunding;
    private onChannelManagerPaymentClaimed;
    private onEmergencyForceCloseChannel;
    private onNetworkGraphUpdated;
    private onChannelManagerRestarted;
    private onLspLogEvent;
    private removeExpiredAndUnclaimedInvoices;
    private removeStalePaymentClaims;
    createChannel(req: TCreateChannelReq): Promise<Result<TChannelManagerFundingGenerationReady>>;
}
declare const _default: LightningManager;
export default _default;
