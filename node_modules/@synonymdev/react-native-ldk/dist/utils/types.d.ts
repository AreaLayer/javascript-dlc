export declare enum ENetworks {
    signet = "signet",
    regtest = "regtest",
    testnet = "testnet",
    mainnet = "bitcoin"
}
export declare type TAvailableNetworks = 'bitcoin' | 'bitcoinTestnet' | 'bitcoinRegtest' | 'bitcoinSignet';
export declare enum EEventTypes {
    ldk_log = "ldk_log",
    native_log = "native_log",
    register_tx = "register_tx",
    register_output = "register_output",
    broadcast_transaction = "broadcast_transaction",
    channel_manager_funding_generation_ready = "channel_manager_funding_generation_ready",
    channel_manager_payment_claimable = "channel_manager_payment_claimable",
    channel_manager_payment_sent = "channel_manager_payment_sent",
    channel_manager_open_channel_request = "channel_manager_open_channel_request",
    channel_manager_payment_path_successful = "channel_manager_payment_path_successful",
    channel_manager_payment_path_failed = "channel_manager_payment_path_failed",
    channel_manager_payment_failed = "channel_manager_payment_failed",
    channel_manager_pending_htlcs_forwardable = "channel_manager_pending_htlcs_forwardable",
    channel_manager_spendable_outputs = "channel_manager_spendable_outputs",
    channel_manager_channel_closed = "channel_manager_channel_closed",
    channel_manager_discard_funding = "channel_manager_discard_funding",
    channel_manager_payment_claimed = "channel_manager_payment_claimed",
    emergency_force_close_channel = "emergency_force_close_channel",
    new_channel = "new_channel",
    network_graph_updated = "network_graph_updated",
    channel_manager_restarted = "channel_manager_restarted",
    backup_state_update = "backup_state_update",
    lsp_log = "lsp_log",
    used_close_address = "used_close_address"
}
export declare type TRegisterTxEvent = {
    txid: string;
    script_pubkey: string;
};
export declare type TRegisterOutputEvent = {
    block_hash: string;
    index: number;
    script_pubkey: string;
};
export declare type TBroadcastTransactionEvent = {
    tx: string;
};
export declare type TChannelManagerFundingGenerationReady = {
    temp_channel_id: string;
    output_script: string;
    user_channel_id: string;
    value_satoshis: number;
};
export declare type TPaymentState = 'pending' | 'failed' | 'successful';
export declare type TChannelManagerClaim = {
    payment_hash: string;
    amount_sat: number;
    payment_preimage: string;
    payment_secret: string;
    spontaneous_payment_preimage: string;
    unix_timestamp: number;
    state: TPaymentState;
};
export declare type TChannelManagerPaymentSent = {
    bolt11_invoice?: string;
    description?: string;
    payment_id: string;
    payment_preimage?: string;
    payment_hash: string;
    fee_paid_sat: number;
    amount_sat?: number;
    unix_timestamp: number;
    state: TPaymentState;
};
export declare type TChannelManagerOpenChannelRequest = {
    temp_channel_id: string;
    counterparty_node_id: string;
    push_sat: number;
    funding_satoshis: number;
    requires_zero_conf: boolean;
    supports_zero_conf: boolean;
    requires_anchors_zero_fee_htlc_tx: boolean;
};
export declare type TChannelUpdate = {
    channel_id: string;
    counterparty_node_id: string;
};
declare type TPathHop = {
    pubkey: string;
    fee_sat: number;
    short_channel_id: string;
    cltv_expiry_delta: number;
};
export declare type TChannelManagerPaymentPathSuccessful = {
    payment_id: string;
    payment_hash: string;
    path_hops: TPathHop[];
};
export declare type TChannelManagerPaymentPathFailed = {
    payment_id: string;
    payment_hash: string;
    payment_failed_permanently: boolean;
    short_channel_id: string;
    path_hops: TPathHop[];
};
export declare type TChannelManagerPaymentFailed = {
    payment_id: string;
    payment_hash: string;
};
export declare type TChannelManagerPendingHtlcsForwardable = {
    time_forwardable: number;
};
export declare type TChannelManagerSpendableOutputs = {
    outputsSerialized: string[];
};
export declare type TChannelManagerChannelClosed = {
    user_channel_id: string;
    channel_id: string;
    reason: string;
};
export declare type TChannelManagerDiscardFunding = {
    channel_id: string;
    tx: string;
};
export declare type TChannel = {
    channel_id: string;
    is_public: boolean;
    is_usable: boolean;
    is_channel_ready: boolean;
    is_outbound: boolean;
    balance_sat: number;
    counterparty_node_id: string;
    funding_txid?: string;
    funding_output_index?: number;
    channel_type?: string;
    user_channel_id: string;
    confirmations_required?: number;
    short_channel_id: string;
    inbound_scid_alias: string;
    inbound_payment_scid: string;
    inbound_capacity_sat: number;
    outbound_capacity_sat: number;
    channel_value_satoshis: number;
    force_close_spend_delay?: number;
    unspendable_punishment_reserve?: number;
    config_forwarding_fee_base_msat: number;
    config_forwarding_fee_proportional_millionths: number;
    confirmations: number;
};
export declare type TChannelMonitor = {
    channel_id: string;
    funding_txo_index: number;
    funding_txo_txid: string;
    counterparty_node_id: string;
    claimable_balances: [TClaimableBalance];
};
export declare type TNetworkGraphChannelInfo = {
    shortChannelId: string;
    capacity_sats?: number;
    node_one: string;
    node_two: string;
    one_to_two_fees_base_sats: number;
    one_to_two_fees_proportional_millionths: number;
    one_to_two_enabled: boolean;
    one_to_two_last_update: number;
    one_to_two_htlc_maximum_sats: number;
    one_to_two_htlc_minimum_sats: number;
    two_to_one_fees_base_sats: number;
    two_to_one_fees_proportional_millionths: number;
    two_to_one_enabled: boolean;
    two_to_one_last_update: number;
    two_to_one_htlc_maximum_sats: number;
    two_to_one_htlc_minimum_sats: number;
};
export declare type TNetworkGraphNodeInfo = {
    id: string;
    shortChannelIds: string[];
    announcement_info_last_update: number;
};
export declare type TInvoice = {
    amount_satoshis?: number;
    description?: string;
    check_signature: boolean;
    is_expired: boolean;
    duration_since_epoch: number;
    expiry_time: number;
    min_final_cltv_expiry: number;
    payee_pub_key: string;
    recover_payee_pub_key: string;
    payment_hash: string;
    payment_secret: string;
    timestamp: number;
    features?: string;
    currency: string;
    to_str: string;
    route_hints: TRouteHints[];
};
export declare type TNetworkGraphUpdated = {
    channel_count: number;
    node_count: number;
};
export declare type TRouteHints = TRouteHintHop[];
export declare type TRouteHintHop = {
    src_node_id: string;
    short_channel_id: string;
};
export declare type TPaymentRoute = TPaymentHop[];
export declare type TPaymentHop = {
    dest_node_id: string;
    short_channel_id: string;
    fee_sats: number;
};
export declare type TLogListener = {
    id: string;
    callback: (log: string) => void;
};
export declare type TFeeUpdateReq = {
    anchorChannelFee: number;
    nonAnchorChannelFee: number;
    channelCloseMinimum: number;
    minAllowedAnchorChannelRemoteFee: number;
    onChainSweep: number;
    minAllowedNonAnchorChannelRemoteFee: number;
};
export declare type TPeer = {
    address: string;
    port: number;
    pubKey: string;
};
export declare type TAddPeerReq = {
    address: string;
    port: number;
    pubKey: string;
    timeout: number;
};
export declare type TSetTxConfirmedReq = {
    header: string;
    txData: {
        transaction: string;
        pos: number;
    }[];
    height: number;
};
export declare type TCloseChannelReq = {
    channelId: string;
    counterPartyNodeId: string;
    force?: boolean;
};
export declare type TCreateChannelReq = {
    counterPartyNodeId: string;
    channelValueSats: number;
    pushSats: number;
};
export declare type TFundChannelReq = {
    temporaryChannelId: string;
    counterPartyNodeId: string;
    fundingTransaction: string;
};
export declare type TAcceptChannelReq = {
    temporaryChannelId: string;
    counterPartyNodeId: string;
    trustedPeer0Conf: boolean;
};
export declare type TSpendOutputsReq = {
    descriptorsSerialized: string[];
    outputs: {
        script_pubkey: string;
        value: number;
    }[];
    change_destination_script: string;
    feerate_sat_per_1000_weight: number;
};
export declare type TPaymentReq = {
    paymentRequest: string;
    amountSats?: number;
    timeout?: number;
};
export declare type TPaymentTimeoutReq = TPaymentReq & {
    timeout?: number;
};
export declare type TCreatePaymentReq = {
    amountSats?: number;
    description: string;
    expiryDeltaSeconds: number;
};
export declare type TInitChannelManagerReq = {
    network: ENetworks;
    bestBlock: {
        hash: string;
        height: number;
    };
};
export declare type TDownloadScorer = {
    scorerDownloadUrl: string;
    skipHoursThreshold?: number;
};
export declare type TInitKeysManager = {
    seed: string;
    address: string;
    channelCloseDestinationScriptPublicKey: string;
    channelCloseWitnessProgram: string;
    channelCloseWitnessProgramVersion: number;
};
export declare type TInitNetworkGraphReq = {
    network: ENetworks;
    rapidGossipSyncUrl?: string;
    skipHoursThreshold?: number;
};
export declare type TChannelHandshakeConfig = {
    minimum_depth?: number;
    our_to_self_delay?: number;
    our_htlc_minimum_msat?: number;
    max_htlc_value_in_flight_percent_of_channel?: number;
    negotiate_scid_privacy?: boolean;
    announced_channel?: boolean;
    commit_upfront_shutdown_pubkey?: boolean;
    their_channel_reserve_proportional_millionths?: number;
    negotiate_anchors_zero_fee_htlc_tx?: boolean;
    our_max_accepted_htlcs_arg?: number;
    max_inbound_htlc_value_in_flight_percent_of_channel?: number;
};
export declare type TChannelHandshakeLimits = {
    min_funding_satoshis?: number;
    max_funding_satoshis?: number;
    max_htlc_minimum_msat?: number;
    min_max_htlc_value_in_flight_msat?: number;
    max_channel_reserve_satoshis?: number;
    min_max_accepted_htlcs?: number;
    max_minimum_depth?: number;
    trust_own_funding_0conf?: boolean;
    force_announced_channel_preference?: boolean;
    their_to_self_delay?: number;
};
export declare type TChannelConfig = {
    forwarding_fee_proportional_millionths?: number;
    forwarding_fee_base_msat?: number;
    cltv_expiry_delta?: number;
    max_dust_htlc_exposure_type?: 'fixed_limit' | 'fee_rate_multiplier';
    max_dust_htlc_exposure?: number;
    force_close_avoidance_max_fee_satoshis?: number;
    accept_underpaying_htlcs?: boolean;
};
export declare type TUserConfig = {
    channel_handshake_config?: TChannelHandshakeConfig;
    channel_handshake_limits?: TChannelHandshakeLimits;
    channel_config?: TChannelConfig;
    accept_forwards_to_priv_channels?: boolean;
    accept_inbound_channels?: boolean;
    manually_accept_inbound_channels?: boolean;
    accept_intercept_htlcs?: boolean;
    accept_mpp_keysend?: boolean;
};
export declare const defaultUserConfig: TUserConfig;
export declare enum ELdkLogLevels {
    gossip = "GOSSIP",
    trace = "TRACE",
    debug = "DEBUG",
    info = "INFO",
    warn = "WARN",
    error = "ERROR"
}
export declare type THeader = {
    hex: string;
    hash: string;
    height: number;
};
export declare type TTransactionData = {
    header: string;
    height: number;
    transaction: string;
    vout: TVout[];
};
export declare type TTransactionPosition = number;
export declare type TClaimableBalance = {
    amount_satoshis: number;
    type: 'ClaimableAwaitingConfirmations' | 'ClaimableOnChannelClose' | 'ContentiousClaimable' | 'CounterpartyRevokedOutputClaimable' | 'MaybePreimageClaimableHTLC' | 'MaybeTimeoutClaimableHTLC' | 'Unknown';
    confirmation_height?: number;
    timeout_height?: number;
    claimable_height?: number;
};
export declare type TFileWriteReq = {
    fileName: string;
    path?: string;
    content: string;
    format?: 'hex' | 'string';
    remotePersist: boolean;
};
export declare type TFileReadReq = {
    fileName: string;
    format?: 'hex' | 'string';
    path?: string;
};
export declare type TFileReadRes = {
    content: string;
    timestamp: number;
};
export declare const DefaultTransactionDataShape: TTransactionData;
export declare type TGetTransactionData = (txid: string) => Promise<TTransactionData | undefined>;
export declare type TGetTransactionPosition = (params: {
    tx_hash: string;
    height: number;
}) => Promise<TTransactionPosition>;
export declare type TGetBestBlock = () => Promise<THeader>;
export declare enum ELdkFiles {
    seed = "seed",
    channel_manager = "channel_manager.bin",
    channels = "channels",
    peers = "peers.json",
    trusted_peer_node_ids = "trusted_peer_node_ids.json",
    unconfirmed_transactions = "unconfirmed_transactions.json",
    broadcasted_transactions = "broadcasted_transactions.json",
    confirmed_broadcasted_transactions = "confirmed_broadcasted_transactions.json",
    payment_ids = "payment_ids.json",
    spendable_outputs = "spendable_outputs.json",
    payments_claimed = "payments_claimed.json",
    payments_sent = "payments_sent.json",
    bolt11_invoices = "bolt11_invoices.json",
    addresses = "addresses.json",
    confirmed_watch_outputs = "confirmed_watch_outputs.json"
}
export declare enum ELdkData {
    channel_manager = "channel_manager",
    channel_monitors = "channel_monitors",
    peers = "peers",
    unconfirmed_transactions = "unconfirmed_transactions",
    broadcasted_transactions = "broadcasted_transactions",
    payment_ids = "payment_ids",
    timestamp = "timestamp",
    spendable_outputs = "spendable_outputs",
    payments_claimed = "payments_claimed",
    payments_sent = "payments_sent",
    bolt11_invoices = "bolt11_invoices"
}
export declare type TLdkData = {
    [ELdkData.channel_manager]: string;
    [ELdkData.channel_monitors]: {
        [key: string]: string;
    };
    [ELdkData.peers]: TLdkPeers;
    [ELdkData.unconfirmed_transactions]: TLdkUnconfirmedTransactions;
    [ELdkData.broadcasted_transactions]: TLdkBroadcastedTransactions;
    [ELdkData.payment_ids]: TLdkPaymentIds;
    [ELdkData.timestamp]: number;
    [ELdkData.spendable_outputs]: TLdkSpendableOutputs;
    [ELdkData.payments_claimed]: TChannelManagerClaim[];
    [ELdkData.payments_sent]: TChannelManagerPaymentSent[];
    [ELdkData.bolt11_invoices]: TBolt11Invoices;
};
export declare type TAccountBackup = {
    account: TAccount;
    package_version: string;
    network: ENetworks;
    data: TLdkData;
};
export declare type TLdkPeers = TPeer[];
export declare type TLdkUnconfirmedTransaction = TTransactionData & {
    txid: string;
    script_pubkey: string;
};
export declare type TLdkUnconfirmedTransactions = TLdkUnconfirmedTransaction[];
export declare type TLdkBroadcastedTransactions = string[];
export declare type TLdkPaymentIds = string[];
export declare type TBolt11Invoices = string[];
export declare type TLdkSpendableOutputs = string[];
export declare type TAccount = {
    name: string;
    seed: string;
};
declare type TForceCloseOnStartup = {
    forceClose: boolean;
    broadcastLatestTx: boolean;
};
export declare type TLdkStart = {
    account: TAccount;
    getBestBlock: TGetBestBlock;
    getTransactionData: TGetTransactionData;
    getTransactionPosition: TGetTransactionPosition;
    getAddress: TGetAddress;
    getScriptPubKeyHistory: TGetScriptPubKeyHistory;
    getFees: TGetFees;
    broadcastTransaction: TBroadcastTransaction;
    network: ENetworks;
    rapidGossipSyncUrl?: string;
    scorerDownloadUrl?: string;
    forceCloseOnStartup?: TForceCloseOnStartup;
    userConfig?: TUserConfig;
    skipParamCheck?: boolean;
    skipRemoteBackups?: boolean;
    lspLogEvent?: TLspLogEvent;
};
export interface IAddress {
    address: string;
    publicKey: string;
}
export declare type TGetAddress = () => Promise<IAddress>;
export declare type TGetScriptPubKeyHistory = (address: string) => Promise<TGetScriptPubKeyHistoryResponse[]>;
export declare type TGetScriptPubKeyHistoryResponse = {
    height: number;
    txid: string;
};
export declare type TBroadcastTransaction = (rawTx: string) => Promise<any>;
export declare type TLspLogPayload = {
    nodeId: string;
    body: string;
};
export declare type TLspLogEvent = (payload: TLspLogPayload) => Promise<void>;
export declare type TGetFees = () => Promise<TFeeUpdateReq>;
export declare type TVout = {
    hex: string;
    n: number;
    value: number;
};
export declare type TReconstructAndSpendOutputsReq = {
    outputScriptPubKey: string;
    outputValue: number;
    outpointTxId: string;
    outpointIndex: number;
    feeRate: number;
    changeDestinationScript: string;
};
export declare type TSpendRecoveredForceCloseOutputsReq = {
    transaction: string;
    confirmationHeight: number;
    changeDestinationScript: string;
    useInner: boolean;
};
export declare type TBackupServerDetails = {
    host: string;
    serverPubKey: string;
};
export declare type TBackedUpFileList = {
    list: [string];
    channel_monitors: [string];
};
export declare type TNodeSignReq = {
    message: string;
    messagePrefix?: string;
};
declare type TBackupFileState = {
    lastQueued: number;
    lastPersisted?: number;
    lastFailed?: number;
    lastErrorMessage?: string;
};
export declare type TBackupStateUpdate = {
    [key: string]: TBackupFileState;
};
export {};
