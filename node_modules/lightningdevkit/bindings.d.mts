export declare function freeWasmMemory(pointer: number): void;
/**
 * Indicates whether the balance is derived from a cooperative close, a force-close
 * (for holder or counterparty), or whether it is for an HTLC.
 */
export declare enum BalanceSource {
    /**
     * The channel was force closed by the holder.
     */
    LDKBalanceSource_HolderForceClosed = 0,
    /**
     * The channel was force closed by the counterparty.
     */
    LDKBalanceSource_CounterpartyForceClosed = 1,
    /**
     * The channel was cooperatively closed.
     */
    LDKBalanceSource_CoopClose = 2,
    /**
     * This balance is the result of an HTLC.
     */
    LDKBalanceSource_Htlc = 3
}
/**
 * Whether this blinded HTLC is being failed backwards by the introduction node or a blinded node,
 * which determines the failure message that should be used.
 */
export declare enum BlindedFailure {
    /**
     * This HTLC is being failed backwards by the introduction node, and thus should be failed with
    [`msgs::UpdateFailHTLC`] and error code `0x8000|0x4000|24`.
     */
    LDKBlindedFailure_FromIntroductionNode = 0,
    /**
     * This HTLC is being failed backwards by a blinded node within the path, and thus should be
    failed with [`msgs::UpdateFailMalformedHTLC`] and error code `0x8000|0x4000|24`.
     */
    LDKBlindedFailure_FromBlindedNode = 1
}
/**
 * Errors that may occur when converting a [`RawBolt11Invoice`] to a [`Bolt11Invoice`]. They relate to
 * the requirements sections in BOLT #11
 */
export declare enum Bolt11SemanticError {
    /**
     * The invoice is missing the mandatory payment hash
     */
    LDKBolt11SemanticError_NoPaymentHash = 0,
    /**
     * The invoice has multiple payment hashes which isn't allowed
     */
    LDKBolt11SemanticError_MultiplePaymentHashes = 1,
    /**
     * No description or description hash are part of the invoice
     */
    LDKBolt11SemanticError_NoDescription = 2,
    /**
     * The invoice contains multiple descriptions and/or description hashes which isn't allowed
     */
    LDKBolt11SemanticError_MultipleDescriptions = 3,
    /**
     * The invoice is missing the mandatory payment secret, which all modern lightning nodes
    should provide.
     */
    LDKBolt11SemanticError_NoPaymentSecret = 4,
    /**
     * The invoice contains multiple payment secrets
     */
    LDKBolt11SemanticError_MultiplePaymentSecrets = 5,
    /**
     * The invoice's features are invalid
     */
    LDKBolt11SemanticError_InvalidFeatures = 6,
    /**
     * The recovery id doesn't fit the signature/pub key
     */
    LDKBolt11SemanticError_InvalidRecoveryId = 7,
    /**
     * The invoice's signature is invalid
     */
    LDKBolt11SemanticError_InvalidSignature = 8,
    /**
     * The invoice's amount was not a whole number of millisatoshis
     */
    LDKBolt11SemanticError_ImpreciseAmount = 9
}
/**
 * Error when interpreting a TLV stream as a specific type.
 */
export declare enum Bolt12SemanticError {
    /**
     * The current [`std::time::SystemTime`] is past the offer or invoice's expiration.
     */
    LDKBolt12SemanticError_AlreadyExpired = 0,
    /**
     * The provided chain hash does not correspond to a supported chain.
     */
    LDKBolt12SemanticError_UnsupportedChain = 1,
    /**
     * A chain was provided but was not expected.
     */
    LDKBolt12SemanticError_UnexpectedChain = 2,
    /**
     * An amount was expected but was missing.
     */
    LDKBolt12SemanticError_MissingAmount = 3,
    /**
     * The amount exceeded the total bitcoin supply.
     */
    LDKBolt12SemanticError_InvalidAmount = 4,
    /**
     * An amount was provided but was not sufficient in value.
     */
    LDKBolt12SemanticError_InsufficientAmount = 5,
    /**
     * An amount was provided but was not expected.
     */
    LDKBolt12SemanticError_UnexpectedAmount = 6,
    /**
     * A currency was provided that is not supported.
     */
    LDKBolt12SemanticError_UnsupportedCurrency = 7,
    /**
     * A feature was required but is unknown.
     */
    LDKBolt12SemanticError_UnknownRequiredFeatures = 8,
    /**
     * Features were provided but were not expected.
     */
    LDKBolt12SemanticError_UnexpectedFeatures = 9,
    /**
     * A required description was not provided.
     */
    LDKBolt12SemanticError_MissingDescription = 10,
    /**
     * A signing pubkey was not provided.
     */
    LDKBolt12SemanticError_MissingSigningPubkey = 11,
    /**
     * A signing pubkey was provided but a different one was expected.
     */
    LDKBolt12SemanticError_InvalidSigningPubkey = 12,
    /**
     * A signing pubkey was provided but was not expected.
     */
    LDKBolt12SemanticError_UnexpectedSigningPubkey = 13,
    /**
     * A quantity was expected but was missing.
     */
    LDKBolt12SemanticError_MissingQuantity = 14,
    /**
     * An unsupported quantity was provided.
     */
    LDKBolt12SemanticError_InvalidQuantity = 15,
    /**
     * A quantity or quantity bounds was provided but was not expected.
     */
    LDKBolt12SemanticError_UnexpectedQuantity = 16,
    /**
     * Metadata could not be used to verify the offers message.
     */
    LDKBolt12SemanticError_InvalidMetadata = 17,
    /**
     * Metadata was provided but was not expected.
     */
    LDKBolt12SemanticError_UnexpectedMetadata = 18,
    /**
     * Payer metadata was expected but was missing.
     */
    LDKBolt12SemanticError_MissingPayerMetadata = 19,
    /**
     * A payer id was expected but was missing.
     */
    LDKBolt12SemanticError_MissingPayerId = 20,
    /**
     * The payment id for a refund or request is already in use.
     */
    LDKBolt12SemanticError_DuplicatePaymentId = 21,
    /**
     * Blinded paths were expected but were missing.
     */
    LDKBolt12SemanticError_MissingPaths = 22,
    /**
     * Blinded paths were provided but were not expected.
     */
    LDKBolt12SemanticError_UnexpectedPaths = 23,
    /**
     * The blinded payinfo given does not match the number of blinded path hops.
     */
    LDKBolt12SemanticError_InvalidPayInfo = 24,
    /**
     * An invoice creation time was expected but was missing.
     */
    LDKBolt12SemanticError_MissingCreationTime = 25,
    /**
     * An invoice payment hash was expected but was missing.
     */
    LDKBolt12SemanticError_MissingPaymentHash = 26,
    /**
     * An invoice payment hash was provided but was not expected.
     */
    LDKBolt12SemanticError_UnexpectedPaymentHash = 27,
    /**
     * A signature was expected but was missing.
     */
    LDKBolt12SemanticError_MissingSignature = 28
}
/**
 * An enum which can either contain a  or not
 */
export declare enum COption_NoneZ {
    /**
     * When we're in this state, this COption_NoneZ contains a
     */
    LDKCOption_NoneZ_Some = 0,
    /**
     * When we're in this state, this COption_NoneZ contains nothing
     */
    LDKCOption_NoneZ_None = 1
}
/**
 * An enum representing the status of a channel monitor update persistence.
 *
 * These are generally used as the return value for an implementation of [`Persist`] which is used
 * as the storage layer for a [`ChainMonitor`]. See the docs on [`Persist`] for a high-level
 * explanation of how to handle different cases.
 *
 * While `UnrecoverableError` is provided as a failure variant, it is not truly \"handled\" on the
 * calling side, and generally results in an immediate panic. For those who prefer to avoid
 * panics, `InProgress` can be used and you can retry the update operation in the background or
 * shut down cleanly.
 *
 * Note that channels should generally *not* be force-closed after a persistence failure.
 * Force-closing with the latest [`ChannelMonitorUpdate`] applied may result in a transaction
 * being broadcast which can only be spent by the latest [`ChannelMonitor`]! Thus, if the
 * latest [`ChannelMonitor`] is not durably persisted anywhere and exists only in memory, naively
 * calling [`ChannelManager::force_close_broadcasting_latest_txn`] *may result in loss of funds*!
 *
 * [`Persist`]: chainmonitor::Persist
 * [`ChainMonitor`]: chainmonitor::ChainMonitor
 * [`ChannelManager::force_close_broadcasting_latest_txn`]: crate::ln::channelmanager::ChannelManager::force_close_broadcasting_latest_txn
 */
export declare enum ChannelMonitorUpdateStatus {
    /**
     * The update has been durably persisted and all copies of the relevant [`ChannelMonitor`]
    have been updated.
    
    This includes performing any `fsync()` calls required to ensure the update is guaranteed to
    be available on restart even if the application crashes.
     */
    LDKChannelMonitorUpdateStatus_Completed = 0,
    /**
     * Indicates that the update will happen asynchronously in the background or that a transient
    failure occurred which is being retried in the background and will eventually complete.
    
    This will \"freeze\" a channel, preventing us from revoking old states or submitting a new
    commitment transaction to the counterparty. Once the update(s) which are `InProgress` have
    been completed, a [`MonitorEvent::Completed`] can be used to restore the channel to an
    operational state.
    
    Even when a channel has been \"frozen\", updates to the [`ChannelMonitor`] can continue to
    occur (e.g. if an inbound HTLC which we forwarded was claimed upstream, resulting in us
    attempting to claim it on this channel) and those updates must still be persisted.
    
    No updates to the channel will be made which could invalidate other [`ChannelMonitor`]s
    until a [`MonitorEvent::Completed`] is provided, even if you return no error on a later
    monitor update for the same channel.
    
    For deployments where a copy of [`ChannelMonitor`]s and other local state are backed up in
    a remote location (with local copies persisted immediately), it is anticipated that all
    updates will return [`InProgress`] until the remote copies could be updated.
    
    Note that while fully asynchronous persistence of [`ChannelMonitor`] data is generally
    reliable, this feature is considered beta, and a handful of edge-cases remain. Until the
    remaining cases are fixed, in rare cases, *using this feature may lead to funds loss*.
    
    [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
     */
    LDKChannelMonitorUpdateStatus_InProgress = 1,
    /**
     * Indicates that an update has failed and will not complete at any point in the future.
    
    Currently returning this variant will cause LDK to immediately panic to encourage immediate
    shutdown. In the future this may be updated to disconnect peers and refuse to continue
    normal operation without a panic.
    
    Applications which wish to perform an orderly shutdown after failure should consider
    returning [`InProgress`] instead and simply shut down without ever marking the update
    complete.
    
    [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
     */
    LDKChannelMonitorUpdateStatus_UnrecoverableError = 2
}
/**
 * Further information on the details of the channel shutdown.
 * Upon channels being forced closed (i.e. commitment transaction confirmation detected
 * by `ChainMonitor`), ChannelShutdownState will be set to `ShutdownComplete` or
 * the channel will be removed shortly.
 * Also note, that in normal operation, peers could disconnect at any of these states
 * and require peer re-connection before making progress onto other states
 */
export declare enum ChannelShutdownState {
    /**
     * Channel has not sent or received a shutdown message.
     */
    LDKChannelShutdownState_NotShuttingDown = 0,
    /**
     * Local node has sent a shutdown message for this channel.
     */
    LDKChannelShutdownState_ShutdownInitiated = 1,
    /**
     * Shutdown message exchanges have concluded and the channels are in the midst of
    resolving all existing open HTLCs before closing can continue.
     */
    LDKChannelShutdownState_ResolvingHTLCs = 2,
    /**
     * All HTLCs have been resolved, nodes are currently negotiating channel close onchain fee rates.
     */
    LDKChannelShutdownState_NegotiatingClosingFee = 3,
    /**
     * We've successfully negotiated a closing_signed dance. At this point `ChannelManager` is about
    to drop the channel.
     */
    LDKChannelShutdownState_ShutdownComplete = 4
}
/**
 * An enum that represents the priority at which we want a transaction to confirm used for feerate
 * estimation.
 */
export declare enum ConfirmationTarget {
    /**
     * The most aggressive (i.e. highest) feerate estimate available.
    
    This is used to sanity-check our counterparty's feerates and should be as conservative as
    possible to ensure that we don't confuse a peer using a very conservative estimator for one
    trying to burn channel balance to dust.
     */
    LDKConfirmationTarget_MaximumFeeEstimate = 0,
    /**
     * We have some funds available on chain which we need to spend prior to some expiry time at
    which point our counterparty may be able to steal them.
    
    Generally we have in the high tens to low hundreds of blocks to get our transaction
    on-chain (it doesn't have to happen in the next few blocks!), but we shouldn't risk too low
    a fee - this should be a relatively high priority feerate.
     */
    LDKConfirmationTarget_UrgentOnChainSweep = 1,
    /**
     * This is the lowest feerate we will allow our channel counterparty to have in an anchor
    channel in order to close the channel if a channel party goes away.
    
    This needs to be sufficient to get into the mempool when the channel needs to
    be force-closed. Setting too high may result in force-closures if our counterparty attempts
    to use a lower feerate. Because this is for anchor channels, we can always bump the feerate
    later; the feerate here only needs to be sufficient to enter the mempool.
    
    A good estimate is the expected mempool minimum at the time of force-closure. Obviously this
    is not an estimate which is very easy to calculate because we do not know the future. Using
    a simple long-term fee estimate or tracking of the mempool minimum is a good approach to
    ensure you can always close the channel. A future change to Bitcoin's P2P network
    (package relay) may obviate the need for this entirely.
     */
    LDKConfirmationTarget_MinAllowedAnchorChannelRemoteFee = 2,
    /**
     * The lowest feerate we will allow our channel counterparty to have in a non-anchor channel.
    
    This is the feerate on the transaction which we (or our counterparty) will broadcast in
    order to close the channel if a channel party goes away. Setting this value too high will
    cause immediate force-closures in order to avoid having an unbroadcastable state.
    
    This feerate represents the fee we pick now, which must be sufficient to enter a block at an
    arbitrary time in the future. Obviously this is not an estimate which is very easy to
    calculate. This can leave channels subject to being unable to close if feerates rise, and in
    general you should prefer anchor channels to ensure you can increase the feerate when the
    transactions need broadcasting.
    
    Do note some fee estimators round up to the next full sat/vbyte (ie 250 sats per kw),
    causing occasional issues with feerate disagreements between an initiator that wants a
    feerate of 1.1 sat/vbyte and a receiver that wants 1.1 rounded up to 2. If your fee
    estimator rounds subtracting 250 to your desired feerate here can help avoid this issue.
    
    [`ChannelConfig::max_dust_htlc_exposure`]: crate::util::config::ChannelConfig::max_dust_htlc_exposure
     */
    LDKConfirmationTarget_MinAllowedNonAnchorChannelRemoteFee = 3,
    /**
     * This is the feerate on the transaction which we (or our counterparty) will broadcast in
    order to close the channel if a channel party goes away.
    
    This needs to be sufficient to get into the mempool when the channel needs to
    be force-closed. Setting too low may result in force-closures. Because this is for anchor
    channels, it can be a low value as we can always bump the feerate later.
    
    A good estimate is the expected mempool minimum at the time of force-closure. Obviously this
    is not an estimate which is very easy to calculate because we do not know the future. Using
    a simple long-term fee estimate or tracking of the mempool minimum is a good approach to
    ensure you can always close the channel. A future change to Bitcoin's P2P network
    (package relay) may obviate the need for this entirely.
     */
    LDKConfirmationTarget_AnchorChannelFee = 4,
    /**
     * Lightning is built around the ability to broadcast a transaction in the future to close our
    channel and claim all pending funds. In order to do so, non-anchor channels are built with
    transactions which we need to be able to broadcast at some point in the future.
    
    This feerate represents the fee we pick now, which must be sufficient to enter a block at an
    arbitrary time in the future. Obviously this is not an estimate which is very easy to
    calculate, so most lightning nodes use some relatively high-priority feerate using the
    current mempool. This leaves channels subject to being unable to close if feerates rise, and
    in general you should prefer anchor channels to ensure you can increase the feerate when the
    transactions need broadcasting.
    
    Since this should represent the feerate of a channel close that does not need fee
    bumping, this is also used as an upper bound for our attempted feerate when doing cooperative
    closure of any channel.
     */
    LDKConfirmationTarget_NonAnchorChannelFee = 5,
    /**
     * When cooperatively closing a channel, this is the minimum feerate we will accept.
    Recommended at least within a day or so worth of blocks.
    
    This will also be used when initiating a cooperative close of a channel. When closing a
    channel you can override this fee by using
    [`ChannelManager::close_channel_with_feerate_and_script`].
    
    [`ChannelManager::close_channel_with_feerate_and_script`]: crate::ln::channelmanager::ChannelManager::close_channel_with_feerate_and_script
     */
    LDKConfirmationTarget_ChannelCloseMinimum = 6,
    /**
     * The feerate used to claim on-chain funds when there is no particular urgency to do so.
    
    It is used to get commitment transactions without any HTLCs confirmed in [`ChannelMonitor`]
    and by  [`OutputSweeper`] on transactions spending [`SpendableOutputDescriptor`]s after a
    channel closure.
    
    Generally spending these outputs is safe as long as they eventually confirm, so a value
    (slightly above) the mempool minimum should suffice. However, as this value will influence
    how long funds will be unavailable after channel closure, [`FeeEstimator`] implementors
    might want to choose a higher feerate to regain control over funds faster.
    
    [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    [`OutputSweeper`]: crate::util::sweep::OutputSweeper
    [`SpendableOutputDescriptor`]: crate::sign::SpendableOutputDescriptor
     */
    LDKConfirmationTarget_OutputSpendingFee = 7
}
/**
 * Errors that may occur when constructing a new [`RawBolt11Invoice`] or [`Bolt11Invoice`]
 */
export declare enum CreationError {
    /**
     * The supplied description string was longer than 639 __bytes__ (see [`Description::new`])
     */
    LDKCreationError_DescriptionTooLong = 0,
    /**
     * The specified route has too many hops and can't be encoded
     */
    LDKCreationError_RouteTooLong = 1,
    /**
     * The Unix timestamp of the supplied date is less than zero or greater than 35-bits
     */
    LDKCreationError_TimestampOutOfBounds = 2,
    /**
     * The supplied millisatoshi amount was greater than the total bitcoin supply.
     */
    LDKCreationError_InvalidAmount = 3,
    /**
     * Route hints were required for this invoice and were missing.
     */
    LDKCreationError_MissingRouteHints = 4,
    /**
     * The provided `min_final_cltv_expiry_delta` was less than rust-lightning's minimum.
     */
    LDKCreationError_MinFinalCltvExpiryDeltaTooShort = 5
}
/**
 * Enum representing the crypto currencies (or networks) supported by this library
 */
export declare enum Currency {
    /**
     * Bitcoin mainnet
     */
    LDKCurrency_Bitcoin = 0,
    /**
     * Bitcoin testnet
     */
    LDKCurrency_BitcoinTestnet = 1,
    /**
     * Bitcoin regtest
     */
    LDKCurrency_Regtest = 2,
    /**
     * Bitcoin simnet
     */
    LDKCurrency_Simnet = 3,
    /**
     * Bitcoin signet
     */
    LDKCurrency_Signet = 4
}
/**
 * The side of a channel that is the [`IntroductionNode`] in a blinded path. [BOLT 7] defines which
 * nodes is which in the [`ChannelAnnouncement`] message.
 *
 * [BOLT 7]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_announcement-message
 * [`ChannelAnnouncement`]: crate::ln::msgs::ChannelAnnouncement
 */
export declare enum Direction {
    /**
     * The lesser node id when compared lexicographically in ascending order.
     */
    LDKDirection_NodeOne = 0,
    /**
     * The greater node id when compared lexicographically in ascending order.
     */
    LDKDirection_NodeTwo = 1
}
/**
 * Describes the type of HTLC claim as determined by analyzing the witness.
 */
export declare enum HTLCClaim {
    /**
     * Claims an offered output on a commitment transaction through the timeout path.
     */
    LDKHTLCClaim_OfferedTimeout = 0,
    /**
     * Claims an offered output on a commitment transaction through the success path.
     */
    LDKHTLCClaim_OfferedPreimage = 1,
    /**
     * Claims an accepted output on a commitment transaction through the timeout path.
     */
    LDKHTLCClaim_AcceptedTimeout = 2,
    /**
     * Claims an accepted output on a commitment transaction through the success path.
     */
    LDKHTLCClaim_AcceptedPreimage = 3,
    /**
     * Claims an offered/accepted output on a commitment transaction through the revocation path.
     */
    LDKHTLCClaim_Revocation = 4
}
/**
 * Represents an IO Error. Note that some information is lost in the conversion from Rust.
 */
export declare enum IOError {
    LDKIOError_NotFound = 0,
    LDKIOError_PermissionDenied = 1,
    LDKIOError_ConnectionRefused = 2,
    LDKIOError_ConnectionReset = 3,
    LDKIOError_ConnectionAborted = 4,
    LDKIOError_NotConnected = 5,
    LDKIOError_AddrInUse = 6,
    LDKIOError_AddrNotAvailable = 7,
    LDKIOError_BrokenPipe = 8,
    LDKIOError_AlreadyExists = 9,
    LDKIOError_WouldBlock = 10,
    LDKIOError_InvalidInput = 11,
    LDKIOError_InvalidData = 12,
    LDKIOError_TimedOut = 13,
    LDKIOError_WriteZero = 14,
    LDKIOError_Interrupted = 15,
    LDKIOError_Other = 16,
    LDKIOError_UnexpectedEof = 17
}
/**
 * Exposes the state of pending inbound HTLCs.
 *
 * At a high level, an HTLC being forwarded from one Lightning node to another Lightning node goes
 * through the following states in the state machine:
 * - Announced for addition by the originating node through the update_add_htlc message.
 * - Added to the commitment transaction of the receiving node and originating node in turn
 * through the exchange of commitment_signed and revoke_and_ack messages.
 * - Announced for resolution (fulfillment or failure) by the receiving node through either one of
 * the update_fulfill_htlc, update_fail_htlc, and update_fail_malformed_htlc messages.
 * - Removed from the commitment transaction of the originating node and receiving node in turn
 * through the exchange of commitment_signed and revoke_and_ack messages.
 *
 * This can be used to inspect what next message an HTLC is waiting for to advance its state.
 */
export declare enum InboundHTLCStateDetails {
    /**
     * We have added this HTLC in our commitment transaction by receiving commitment_signed and
    returning revoke_and_ack. We are awaiting the appropriate revoke_and_ack's from the remote
    before this HTLC is included on the remote commitment transaction.
     */
    LDKInboundHTLCStateDetails_AwaitingRemoteRevokeToAdd = 0,
    /**
     * This HTLC has been included in the commitment_signed and revoke_and_ack messages on both sides
    and is included in both commitment transactions.
    
    This HTLC is now safe to either forward or be claimed as a payment by us. The HTLC will
    remain in this state until the forwarded upstream HTLC has been resolved and we resolve this
    HTLC correspondingly, or until we claim it as a payment. If it is part of a multipart
    payment, it will only be claimed together with other required parts.
     */
    LDKInboundHTLCStateDetails_Committed = 1,
    /**
     * We have received the preimage for this HTLC and it is being removed by fulfilling it with
    update_fulfill_htlc. This HTLC is still on both commitment transactions, but we are awaiting
    the appropriate revoke_and_ack's from the remote before this HTLC is removed from the remote
    commitment transaction after update_fulfill_htlc.
     */
    LDKInboundHTLCStateDetails_AwaitingRemoteRevokeToRemoveFulfill = 2,
    /**
     * The HTLC is being removed by failing it with update_fail_htlc or update_fail_malformed_htlc.
    This HTLC is still on both commitment transactions, but we are awaiting the appropriate
    revoke_and_ack's from the remote before this HTLC is removed from the remote commitment
    transaction.
     */
    LDKInboundHTLCStateDetails_AwaitingRemoteRevokeToRemoveFail = 3
}
/**
 * An enum representing the available verbosity levels of the logger.
 */
export declare enum Level {
    /**
     * Designates extremely verbose information, including gossip-induced messages
     */
    LDKLevel_Gossip = 0,
    /**
     * Designates very low priority, often extremely verbose, information
     */
    LDKLevel_Trace = 1,
    /**
     * Designates lower priority information
     */
    LDKLevel_Debug = 2,
    /**
     * Designates useful information
     */
    LDKLevel_Info = 3,
    /**
     * Designates hazardous situations
     */
    LDKLevel_Warn = 4,
    /**
     * Designates very serious errors
     */
    LDKLevel_Error = 5
}
/**
 * An enum representing the possible Bitcoin or test networks which we can run on
 */
export declare enum Network {
    /**
     * The main Bitcoin blockchain.
     */
    LDKNetwork_Bitcoin = 0,
    /**
     * The testnet3 blockchain.
     */
    LDKNetwork_Testnet = 1,
    /**
     * A local test blockchain.
     */
    LDKNetwork_Regtest = 2,
    /**
     * A blockchain on which blocks are signed instead of mined.
     */
    LDKNetwork_Signet = 3
}
/**
 * Exposes the state of pending outbound HTLCs.
 *
 * At a high level, an HTLC being forwarded from one Lightning node to another Lightning node goes
 * through the following states in the state machine:
 * - Announced for addition by the originating node through the update_add_htlc message.
 * - Added to the commitment transaction of the receiving node and originating node in turn
 * through the exchange of commitment_signed and revoke_and_ack messages.
 * - Announced for resolution (fulfillment or failure) by the receiving node through either one of
 * the update_fulfill_htlc, update_fail_htlc, and update_fail_malformed_htlc messages.
 * - Removed from the commitment transaction of the originating node and receiving node in turn
 * through the exchange of commitment_signed and revoke_and_ack messages.
 *
 * This can be used to inspect what next message an HTLC is waiting for to advance its state.
 */
export declare enum OutboundHTLCStateDetails {
    /**
     * We are awaiting the appropriate revoke_and_ack's from the remote before the HTLC is added
    on the remote's commitment transaction after update_add_htlc.
     */
    LDKOutboundHTLCStateDetails_AwaitingRemoteRevokeToAdd = 0,
    /**
     * The HTLC has been added to the remote's commitment transaction by sending commitment_signed
    and receiving revoke_and_ack in return.
    
    The HTLC will remain in this state until the remote node resolves the HTLC, or until we
    unilaterally close the channel due to a timeout with an uncooperative remote node.
     */
    LDKOutboundHTLCStateDetails_Committed = 1,
    /**
     * The HTLC has been fulfilled successfully by the remote with a preimage in update_fulfill_htlc,
    and we removed the HTLC from our commitment transaction by receiving commitment_signed and
    returning revoke_and_ack. We are awaiting the appropriate revoke_and_ack's from the remote
    for the removal from its commitment transaction.
     */
    LDKOutboundHTLCStateDetails_AwaitingRemoteRevokeToRemoveSuccess = 2,
    /**
     * The HTLC has been failed by the remote with update_fail_htlc or update_fail_malformed_htlc,
    and we removed the HTLC from our commitment transaction by receiving commitment_signed and
    returning revoke_and_ack. We are awaiting the appropriate revoke_and_ack's from the remote
    for the removal from its commitment transaction.
     */
    LDKOutboundHTLCStateDetails_AwaitingRemoteRevokeToRemoveFailure = 3
}
/**
 * The reason the payment failed. Used in [`Event::PaymentFailed`].
 */
export declare enum PaymentFailureReason {
    /**
     * The intended recipient rejected our payment.
    
    Also used for [`UnknownRequiredFeatures`] and [`InvoiceRequestRejected`] when downgrading to
    version prior to 0.0.124.
    
    [`UnknownRequiredFeatures`]: Self::UnknownRequiredFeatures
    [`InvoiceRequestRejected`]: Self::InvoiceRequestRejected
     */
    LDKPaymentFailureReason_RecipientRejected = 0,
    /**
     * The user chose to abandon this payment by calling [`ChannelManager::abandon_payment`].
    
    [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
     */
    LDKPaymentFailureReason_UserAbandoned = 1,
    /**
     * We exhausted all of our retry attempts while trying to send the payment, or we
    exhausted the [`Retry::Timeout`] if the user set one. If at any point a retry
    attempt failed while being forwarded along the path, an [`Event::PaymentPathFailed`] will
    have come before this.
    
    [`Retry::Timeout`]: crate::ln::channelmanager::Retry::Timeout
     */
    LDKPaymentFailureReason_RetriesExhausted = 2,
    /**
     * The payment expired while retrying, based on the provided
    [`PaymentParameters::expiry_time`].
    
    Also used for [`InvoiceRequestExpired`] when downgrading to version prior to 0.0.124.
    
    [`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
    [`InvoiceRequestExpired`]: Self::InvoiceRequestExpired
     */
    LDKPaymentFailureReason_PaymentExpired = 3,
    /**
     * We failed to find a route while retrying the payment.
    
    Note that this generally indicates that we've exhausted the available set of possible
    routes - we tried the payment over a few routes but were not able to find any further
    candidate routes beyond those.
     */
    LDKPaymentFailureReason_RouteNotFound = 4,
    /**
     * This error should generally never happen. This likely means that there is a problem with
    your router.
     */
    LDKPaymentFailureReason_UnexpectedError = 5,
    /**
     * An invoice was received that required unknown features.
     */
    LDKPaymentFailureReason_UnknownRequiredFeatures = 6,
    /**
     * A [`Bolt12Invoice`] was not received in a reasonable amount of time.
     */
    LDKPaymentFailureReason_InvoiceRequestExpired = 7,
    /**
     * An [`InvoiceRequest`] for the payment was rejected by the recipient.
    
    [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
     */
    LDKPaymentFailureReason_InvoiceRequestRejected = 8
}
/**
 * Specifies the recipient of an invoice.
 *
 * This indicates to [`NodeSigner::sign_invoice`] what node secret key should be used to sign
 * the invoice.
 */
export declare enum Recipient {
    /**
     * The invoice should be signed with the local node secret key.
     */
    LDKRecipient_Node = 0,
    /**
     * The invoice should be signed with the phantom node secret key. This secret key must be the
    same for all nodes participating in the [phantom node payment].
    
    [phantom node payment]: PhantomKeysManager
     */
    LDKRecipient_PhantomNode = 1
}
/**
 * Indicates an immediate error on [`ChannelManager::send_payment`]. Further errors may be
 * surfaced later via [`Event::PaymentPathFailed`] and [`Event::PaymentFailed`].
 *
 * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
 * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
 */
export declare enum RetryableSendFailure {
    /**
     * The provided [`PaymentParameters::expiry_time`] indicated that the payment has expired. Note
    that this error is *not* caused by [`Retry::Timeout`].
    
    [`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
     */
    LDKRetryableSendFailure_PaymentExpired = 0,
    /**
     * We were unable to find a route to the destination.
     */
    LDKRetryableSendFailure_RouteNotFound = 1,
    /**
     * Indicates that a payment for the provided [`PaymentId`] is already in-flight and has not
    yet completed (i.e. generated an [`Event::PaymentSent`] or [`Event::PaymentFailed`]).
    
    [`PaymentId`]: crate::ln::channelmanager::PaymentId
    [`Event::PaymentSent`]: crate::events::Event::PaymentSent
    [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
     */
    LDKRetryableSendFailure_DuplicatePayment = 2,
    /**
     * The [`RecipientOnionFields::payment_metadata`], [`RecipientOnionFields::custom_tlvs`], or
    [`BlindedPaymentPath`]s provided are too large and caused us to exceed the maximum onion
    packet size of 1300 bytes.
    
    [`BlindedPaymentPath`]: crate::blinded_path::payment::BlindedPaymentPath
     */
    LDKRetryableSendFailure_OnionPacketSizeExceeded = 3
}
/**
 * Represents an error returned from libsecp256k1 during validation of some secp256k1 data
 */
export declare enum Secp256k1Error {
    /**
     * Signature failed verification
     */
    LDKSecp256k1Error_IncorrectSignature = 0,
    /**
     * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
     */
    LDKSecp256k1Error_InvalidMessage = 1,
    /**
     * Bad public key
     */
    LDKSecp256k1Error_InvalidPublicKey = 2,
    /**
     * Bad signature
     */
    LDKSecp256k1Error_InvalidSignature = 3,
    /**
     * Bad secret key
     */
    LDKSecp256k1Error_InvalidSecretKey = 4,
    /**
     * Bad shared secret.
     */
    LDKSecp256k1Error_InvalidSharedSecret = 5,
    /**
     * Bad recovery id
     */
    LDKSecp256k1Error_InvalidRecoveryId = 6,
    /**
     * Invalid tweak for add_assign or mul_assign
     */
    LDKSecp256k1Error_InvalidTweak = 7,
    /**
     * Didn't pass enough memory to context creation with preallocated memory
     */
    LDKSecp256k1Error_NotEnoughMemory = 8,
    /**
     * Bad set of public keys.
     */
    LDKSecp256k1Error_InvalidPublicKeySum = 9,
    /**
     * The only valid parity values are 0 or 1.
     */
    LDKSecp256k1Error_InvalidParityValue = 10,
    /**
     * Invalid Elligator Swift Value
     */
    LDKSecp256k1Error_InvalidEllSwift = 11
}
/**
 * A `short_channel_id` construction error
 */
export declare enum ShortChannelIdError {
    /**
     * Block height too high
     */
    LDKShortChannelIdError_BlockOverflow = 0,
    /**
     * Tx index too high
     */
    LDKShortChannelIdError_TxIndexOverflow = 1,
    /**
     * Vout index too high
     */
    LDKShortChannelIdError_VoutIndexOverflow = 2
}
/**
 * SI prefixes for the human readable part
 */
export declare enum SiPrefix {
    /**
     * 10^-3
     */
    LDKSiPrefix_Milli = 0,
    /**
     * 10^-6
     */
    LDKSiPrefix_Micro = 1,
    /**
     * 10^-9
     */
    LDKSiPrefix_Nano = 2,
    /**
     * 10^-12
     */
    LDKSiPrefix_Pico = 3
}
/**
 * [`SocketAddress`] error variants
 */
export declare enum SocketAddressParseError {
    /**
     * Socket address (IPv4/IPv6) parsing error
     */
    LDKSocketAddressParseError_SocketAddrParse = 0,
    /**
     * Invalid input format
     */
    LDKSocketAddressParseError_InvalidInput = 1,
    /**
     * Invalid port
     */
    LDKSocketAddressParseError_InvalidPort = 2,
    /**
     * Invalid onion v3 address
     */
    LDKSocketAddressParseError_InvalidOnionV3 = 3
}
/**
 * An error when accessing the chain via [`UtxoLookup`].
 */
export declare enum UtxoLookupError {
    /**
     * The requested chain is unknown.
     */
    LDKUtxoLookupError_UnknownChain = 0,
    /**
     * The requested transaction doesn't exist or hasn't confirmed.
     */
    LDKUtxoLookupError_UnknownTx = 1
}
