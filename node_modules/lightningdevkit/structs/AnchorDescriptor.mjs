import { TxOut } from '../structs/TxOut.mjs';
import { TxIn } from '../structs/TxIn.mjs';
import { OutPoint } from '../structs/OutPoint.mjs';
import { ChannelDerivationParameters } from '../structs/ChannelDerivationParameters.mjs';
import { EcdsaChannelSigner } from '../structs/EcdsaChannelSigner.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A descriptor used to sign for a commitment transaction's anchor output.
 */
export class AnchorDescriptor extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.AnchorDescriptor_free);
    }
    /**
     * The parameters required to derive the signer for the anchor input.
     */
    get_channel_derivation_parameters() {
        const ret = bindings.AnchorDescriptor_get_channel_derivation_parameters(this.ptr);
        const ret_hu_conv = new ChannelDerivationParameters(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The parameters required to derive the signer for the anchor input.
     */
    set_channel_derivation_parameters(val) {
        bindings.AnchorDescriptor_set_channel_derivation_parameters(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The transaction input's outpoint corresponding to the commitment transaction's anchor
     * output.
     */
    get_outpoint() {
        const ret = bindings.AnchorDescriptor_get_outpoint(this.ptr);
        const ret_hu_conv = new OutPoint(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The transaction input's outpoint corresponding to the commitment transaction's anchor
     * output.
     */
    set_outpoint(val) {
        bindings.AnchorDescriptor_set_outpoint(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * Constructs a new AnchorDescriptor given each field
     */
    static constructor_new(channel_derivation_parameters_arg, outpoint_arg) {
        const ret = bindings.AnchorDescriptor_new(CommonBase.get_ptr_of(channel_derivation_parameters_arg), CommonBase.get_ptr_of(outpoint_arg));
        const ret_hu_conv = new AnchorDescriptor(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.AnchorDescriptor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the AnchorDescriptor
     */
    clone() {
        const ret = bindings.AnchorDescriptor_clone(this.ptr);
        const ret_hu_conv = new AnchorDescriptor(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two AnchorDescriptors contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.AnchorDescriptor_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Returns the UTXO to be spent by the anchor input, which can be obtained via
     * [`Self::unsigned_tx_input`].
     */
    previous_utxo() {
        const ret = bindings.AnchorDescriptor_previous_utxo(this.ptr);
        const ret_conv = new TxOut(null, ret);
        return ret_conv;
    }
    /**
     * Returns the unsigned transaction input spending the anchor output in the commitment
     * transaction.
     */
    unsigned_tx_input() {
        const ret = bindings.AnchorDescriptor_unsigned_tx_input(this.ptr);
        const ret_conv = new TxIn(null, ret);
        return ret_conv;
    }
    /**
     * Returns the witness script of the anchor output in the commitment transaction.
     */
    witness_script() {
        const ret = bindings.AnchorDescriptor_witness_script(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the fully signed witness required to spend the anchor output in the commitment
     * transaction.
     */
    tx_input_witness(signature) {
        const ret = bindings.AnchorDescriptor_tx_input_witness(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(signature, 64)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Derives the channel signer required to sign the anchor input.
     */
    derive_channel_signer(signer_provider) {
        const ret = bindings.AnchorDescriptor_derive_channel_signer(this.ptr, CommonBase.get_ptr_of(signer_provider));
        const ret_hu_conv = new EcdsaChannelSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        CommonBase.add_ref_from(this, signer_provider);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=AnchorDescriptor.mjs.map