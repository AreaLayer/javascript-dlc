import { ReleaseHeldHtlc } from '../structs/ReleaseHeldHtlc.mjs';
import { HeldHtlcAvailable } from '../structs/HeldHtlcAvailable.mjs';
import { OnionMessageContents } from '../structs/OnionMessageContents.mjs';
import { Result_AsyncPaymentsMessageDecodeErrorZ } from '../structs/Result_AsyncPaymentsMessageDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Possible async payment messages sent and received via an [`OnionMessage`].
 *
 * [`OnionMessage`]: crate::ln::msgs::OnionMessage
 */
export class AsyncPaymentsMessage extends CommonBase {
    constructor(_dummy, ptr) { super(ptr, bindings.AsyncPaymentsMessage_free); }
    /* @internal */
    static constr_from_ptr(ptr) {
        const raw_ty = bindings.LDKAsyncPaymentsMessage_ty_from_ptr(ptr);
        switch (raw_ty) {
            case 0: return new AsyncPaymentsMessage_HeldHtlcAvailable(ptr);
            case 1: return new AsyncPaymentsMessage_ReleaseHeldHtlc(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = bindings.AsyncPaymentsMessage_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the AsyncPaymentsMessage
     */
    clone() {
        const ret = bindings.AsyncPaymentsMessage_clone(this.ptr);
        const ret_hu_conv = AsyncPaymentsMessage.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new HeldHtlcAvailable-variant AsyncPaymentsMessage
     */
    static constructor_held_htlc_available(a) {
        const ret = bindings.AsyncPaymentsMessage_held_htlc_available(CommonBase.get_ptr_of(a));
        const ret_hu_conv = AsyncPaymentsMessage.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ReleaseHeldHtlc-variant AsyncPaymentsMessage
     */
    static constructor_release_held_htlc(a) {
        const ret = bindings.AsyncPaymentsMessage_release_held_htlc(CommonBase.get_ptr_of(a));
        const ret_hu_conv = AsyncPaymentsMessage.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Constructs a new OnionMessageContents which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned OnionMessageContents must be freed before this_arg is
     */
    as_OnionMessageContents() {
        const ret = bindings.AsyncPaymentsMessage_as_OnionMessageContents(this.ptr);
        const ret_hu_conv = new OnionMessageContents(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the AsyncPaymentsMessage object into a byte array which can be read by AsyncPaymentsMessage_read
     */
    write() {
        const ret = bindings.AsyncPaymentsMessage_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a AsyncPaymentsMessage from a byte array, created by AsyncPaymentsMessage_write
     */
    static constructor_read(ser, arg) {
        const ret = bindings.AsyncPaymentsMessage_read(bindings.encodeUint8Array(ser), arg);
        const ret_hu_conv = Result_AsyncPaymentsMessageDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
/** A AsyncPaymentsMessage of type HeldHtlcAvailable */
export class AsyncPaymentsMessage_HeldHtlcAvailable extends AsyncPaymentsMessage {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const held_htlc_available = bindings.LDKAsyncPaymentsMessage_HeldHtlcAvailable_get_held_htlc_available(ptr);
        const held_htlc_available_hu_conv = new HeldHtlcAvailable(null, held_htlc_available);
        CommonBase.add_ref_from(held_htlc_available_hu_conv, this);
        this.held_htlc_available = held_htlc_available_hu_conv;
    }
}
/** A AsyncPaymentsMessage of type ReleaseHeldHtlc */
export class AsyncPaymentsMessage_ReleaseHeldHtlc extends AsyncPaymentsMessage {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const release_held_htlc = bindings.LDKAsyncPaymentsMessage_ReleaseHeldHtlc_get_release_held_htlc(ptr);
        const release_held_htlc_hu_conv = new ReleaseHeldHtlc(null, release_held_htlc);
        CommonBase.add_ref_from(release_held_htlc_hu_conv, this);
        this.release_held_htlc = release_held_htlc_hu_conv;
    }
}
//# sourceMappingURL=AsyncPaymentsMessage.mjs.map