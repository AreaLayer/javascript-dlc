import { ReleaseHeldHtlc } from '../structs/ReleaseHeldHtlc.mjs';
import { Option_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ } from '../structs/Option_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ.mjs';
import { HeldHtlcAvailable } from '../structs/HeldHtlcAvailable.mjs';
import { TwoTuple_AsyncPaymentsMessageMessageSendInstructionsZ } from '../structs/TwoTuple_AsyncPaymentsMessageMessageSendInstructionsZ.mjs';
import { Responder } from '../structs/Responder.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKAsyncPaymentsMessageHandlerHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A handler for an [`OnionMessage`] containing an async payments message as its payload.
 *
 * [`OnionMessage`]: crate::ln::msgs::OnionMessage
 */
export class AsyncPaymentsMessageHandler extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.AsyncPaymentsMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of AsyncPaymentsMessageHandler from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKAsyncPaymentsMessageHandlerHolder();
        let structImplementation = {
            held_htlc_available(message, responder) {
                const message_hu_conv = new HeldHtlcAvailable(null, message);
                CommonBase.add_ref_from(message_hu_conv, this);
                const responder_hu_conv = new Responder(null, responder);
                CommonBase.add_ref_from(responder_hu_conv, this);
                const ret = arg.held_htlc_available(message_hu_conv, responder_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            release_held_htlc(message) {
                const message_hu_conv = new ReleaseHeldHtlc(null, message);
                CommonBase.add_ref_from(message_hu_conv, this);
                arg.release_held_htlc(message_hu_conv);
            },
            release_pending_messages() {
                const ret = arg.release_pending_messages();
                const result = bindings.encodeUint64Array(ret.map(ret_conv_55 => ret_conv_55.clone_ptr()));
                return result;
            },
        };
        const ptr_idx = bindings.LDKAsyncPaymentsMessageHandler_new(structImplementation);
        impl_holder.held = new AsyncPaymentsMessageHandler(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Handle a [`HeldHtlcAvailable`] message. A [`ReleaseHeldHtlc`] should be returned to release
     * the held funds.
     *
     * Note that responder (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    held_htlc_available(message, responder) {
        const ret = bindings.AsyncPaymentsMessageHandler_held_htlc_available(this.ptr, CommonBase.get_ptr_of(message), responder == null ? 0n : CommonBase.get_ptr_of(responder));
        const ret_hu_conv = Option_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Handle a [`ReleaseHeldHtlc`] message. If authentication of the message succeeds, an HTLC
     * should be released to the corresponding payee.
     */
    release_held_htlc(message) {
        bindings.AsyncPaymentsMessageHandler_release_held_htlc(this.ptr, CommonBase.get_ptr_of(message));
    }
    /**
     * Release any [`AsyncPaymentsMessage`]s that need to be sent.
     *
     * Typically, this is used for messages initiating an async payment flow rather than in response
     * to another message.
     */
    release_pending_messages() {
        const ret = bindings.AsyncPaymentsMessageHandler_release_pending_messages(this.ptr);
        const ret_conv_55_len = bindings.getArrayLength(ret);
        const ret_conv_55_arr = new Array(ret_conv_55_len).fill(null);
        for (var d = 0; d < ret_conv_55_len; d++) {
            const ret_conv_55 = bindings.getU64ArrayElem(ret, d);
            const ret_conv_55_hu_conv = new TwoTuple_AsyncPaymentsMessageMessageSendInstructionsZ(null, ret_conv_55);
            CommonBase.add_ref_from(ret_conv_55_hu_conv, this);
            ret_conv_55_arr[d] = ret_conv_55_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_55_arr;
    }
}
//# sourceMappingURL=AsyncPaymentsMessageHandler.mjs.map