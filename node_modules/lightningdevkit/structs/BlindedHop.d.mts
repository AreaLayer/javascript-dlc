import { Result_BlindedHopDecodeErrorZ } from '../structs/Result_BlindedHopDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * An encrypted payload and node id corresponding to a hop in a payment or onion message path, to
 * be encoded in the sender's onion packet. These hops cannot be identified by outside observers
 * and thus can be used to hide the identity of the recipient.
 */
export declare class BlindedHop extends CommonBase {
    /**
     * The blinded node id of this hop in a blinded path.
     */
    get_blinded_node_id(): Uint8Array;
    /**
     * The blinded node id of this hop in a blinded path.
     */
    set_blinded_node_id(val: Uint8Array): void;
    /**
     * The encrypted payload intended for this hop in a blinded path.
     *
     * Returns a copy of the field.
     */
    get_encrypted_payload(): Uint8Array;
    /**
     * The encrypted payload intended for this hop in a blinded path.
     */
    set_encrypted_payload(val: Uint8Array): void;
    /**
     * Constructs a new BlindedHop given each field
     */
    static constructor_new(blinded_node_id_arg: Uint8Array, encrypted_payload_arg: Uint8Array): BlindedHop;
    clone_ptr(): bigint;
    /**
     * Creates a copy of the BlindedHop
     */
    clone(): BlindedHop;
    /**
     * Generates a non-cryptographic 64-bit hash of the BlindedHop.
     */
    hash(): bigint;
    /**
     * Checks if two BlindedHops contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b: BlindedHop): boolean;
    /**
     * Serialize the BlindedHop object into a byte array which can be read by BlindedHop_read
     */
    write(): Uint8Array;
    /**
     * Read a BlindedHop from a byte array, created by BlindedHop_write
     */
    static constructor_read(ser: Uint8Array): Result_BlindedHopDecodeErrorZ;
}
