import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { BlindedHop } from '../structs/BlindedHop.mjs';
import { NodeId } from '../structs/NodeId.mjs';
import { Result_BlindedMessagePathDecodeErrorZ } from '../structs/Result_BlindedMessagePathDecodeErrorZ.mjs';
import { Result_BlindedMessagePathNoneZ } from '../structs/Result_BlindedMessagePathNoneZ.mjs';
import { IntroductionNode } from '../structs/IntroductionNode.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A blinded path to be used for sending or receiving a message, hiding the identity of the
 * recipient.
 */
export class BlindedMessagePath extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.BlindedMessagePath_free);
    }
    clone_ptr() {
        const ret = bindings.BlindedMessagePath_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the BlindedMessagePath
     */
    clone() {
        const ret = bindings.BlindedMessagePath_clone(this.ptr);
        const ret_hu_conv = new BlindedMessagePath(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the BlindedMessagePath.
     */
    hash() {
        const ret = bindings.BlindedMessagePath_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two BlindedMessagePaths contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.BlindedMessagePath_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the BlindedMessagePath object into a byte array which can be read by BlindedMessagePath_read
     */
    write() {
        const ret = bindings.BlindedMessagePath_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a BlindedMessagePath from a byte array, created by BlindedMessagePath_write
     */
    static constructor_read(ser) {
        const ret = bindings.BlindedMessagePath_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_BlindedMessagePathDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Create a one-hop blinded path for a message.
     */
    static constructor_one_hop(recipient_node_id, context, entropy_source) {
        const ret = bindings.BlindedMessagePath_one_hop(bindings.encodeUint8Array(bindings.check_arr_len(recipient_node_id, 33)), CommonBase.get_ptr_of(context), CommonBase.get_ptr_of(entropy_source));
        const ret_hu_conv = Result_BlindedMessagePathNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        return ret_hu_conv;
    }
    /**
     * Create a path for an onion message, to be forwarded along `node_pks`. The last node
     * pubkey in `node_pks` will be the destination node.
     *
     * Errors if no hops are provided or if `node_pk`(s) are invalid.
     */
    static constructor_new(intermediate_nodes, recipient_node_id, context, entropy_source) {
        const ret = bindings.BlindedMessagePath_new(bindings.encodeUint64Array(intermediate_nodes.map(intermediate_nodes_conv_20 => CommonBase.get_ptr_of(intermediate_nodes_conv_20))), bindings.encodeUint8Array(bindings.check_arr_len(recipient_node_id, 33)), CommonBase.get_ptr_of(context), CommonBase.get_ptr_of(entropy_source));
        const ret_hu_conv = Result_BlindedMessagePathNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        return ret_hu_conv;
    }
    /**
     * Attempts to a use a compact representation for the [`IntroductionNode`] by using a directed
     * short channel id from a channel in `network_graph` leading to the introduction node.
     *
     * While this may result in a smaller encoding, there is a trade off in that the path may
     * become invalid if the channel is closed or hasn't been propagated via gossip. Therefore,
     * calling this may not be suitable for long-lived blinded paths.
     */
    use_compact_introduction_node(network_graph) {
        bindings.BlindedMessagePath_use_compact_introduction_node(this.ptr, CommonBase.get_ptr_of(network_graph));
        CommonBase.add_ref_from(this, network_graph);
    }
    /**
     * Returns the introduction [`NodeId`] of the blinded path, if it is publicly reachable (i.e.,
     * it is found in the network graph).
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    public_introduction_node_id(network_graph) {
        const ret = bindings.BlindedMessagePath_public_introduction_node_id(this.ptr, CommonBase.get_ptr_of(network_graph));
        const ret_hu_conv = new NodeId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        CommonBase.add_ref_from(this, network_graph);
        return ret_hu_conv;
    }
    /**
     * The [`IntroductionNode`] of the blinded path.
     */
    introduction_node() {
        const ret = bindings.BlindedMessagePath_introduction_node(this.ptr);
        const ret_hu_conv = IntroductionNode.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Used by the [`IntroductionNode`] to decrypt its [`encrypted_payload`] to forward the message.
     *
     * [`encrypted_payload`]: BlindedHop::encrypted_payload
     */
    blinding_point() {
        const ret = bindings.BlindedMessagePath_blinding_point(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The [`BlindedHop`]s within the blinded path.
     */
    blinded_hops() {
        const ret = bindings.BlindedMessagePath_blinded_hops(this.ptr);
        const ret_conv_12_len = bindings.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for (var m = 0; m < ret_conv_12_len; m++) {
            const ret_conv_12 = bindings.getU64ArrayElem(ret, m);
            const ret_conv_12_hu_conv = new BlindedHop(null, ret_conv_12);
            CommonBase.add_ref_from(ret_conv_12_hu_conv, this);
            ret_conv_12_arr[m] = ret_conv_12_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
    /**
     * Advance the blinded onion message path by one hop, making the second hop into the new
     * introduction node.
     *
     * Will only modify `self` when returning `Ok`.
     */
    advance_path_by_one(node_signer, node_id_lookup) {
        const ret = bindings.BlindedMessagePath_advance_path_by_one(this.ptr, CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(node_id_lookup));
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, node_signer);
        CommonBase.add_ref_from(this, node_id_lookup);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=BlindedMessagePath.mjs.map