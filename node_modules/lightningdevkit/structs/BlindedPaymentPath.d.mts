import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { BlindedHop } from '../structs/BlindedHop.mjs';
import { NodeId } from '../structs/NodeId.mjs';
import { EntropySource } from '../structs/EntropySource.mjs';
import { NodeSigner } from '../structs/NodeSigner.mjs';
import { ReceiveTlvs } from '../structs/ReceiveTlvs.mjs';
import { BlindedPayInfo } from '../structs/BlindedPayInfo.mjs';
import { Result_BlindedPaymentPathNoneZ } from '../structs/Result_BlindedPaymentPathNoneZ.mjs';
import { PaymentForwardNode } from '../structs/PaymentForwardNode.mjs';
import { NodeIdLookUp } from '../structs/NodeIdLookUp.mjs';
import { ReadOnlyNetworkGraph } from '../structs/ReadOnlyNetworkGraph.mjs';
import { IntroductionNode } from '../structs/IntroductionNode.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * A blinded path to be used for sending or receiving a payment, hiding the identity of the
 * recipient.
 */
export declare class BlindedPaymentPath extends CommonBase {
    /**
     * The [`BlindedPayInfo`] used to pay this blinded path.
     */
    get_payinfo(): BlindedPayInfo;
    /**
     * The [`BlindedPayInfo`] used to pay this blinded path.
     */
    set_payinfo(val: BlindedPayInfo): void;
    clone_ptr(): bigint;
    /**
     * Creates a copy of the BlindedPaymentPath
     */
    clone(): BlindedPaymentPath;
    /**
     * Generates a non-cryptographic 64-bit hash of the BlindedPaymentPath.
     */
    hash(): bigint;
    /**
     * Checks if two BlindedPaymentPaths contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b: BlindedPaymentPath): boolean;
    /**
     * Create a one-hop blinded path for a payment.
     */
    static constructor_one_hop(payee_node_id: Uint8Array, payee_tlvs: ReceiveTlvs, min_final_cltv_expiry_delta: number, entropy_source: EntropySource): Result_BlindedPaymentPathNoneZ;
    /**
     * Create a blinded path for a payment, to be forwarded along `intermediate_nodes`.
     *
     * Errors if:
     * a provided node id is invalid
     * [`BlindedPayInfo`] calculation results in an integer overflow
     * any unknown features are required in the provided [`ForwardTlvs`]
     */
    static constructor_new(intermediate_nodes: PaymentForwardNode[], payee_node_id: Uint8Array, payee_tlvs: ReceiveTlvs, htlc_maximum_msat: bigint, min_final_cltv_expiry_delta: number, entropy_source: EntropySource): Result_BlindedPaymentPathNoneZ;
    /**
     * Returns the introduction [`NodeId`] of the blinded path, if it is publicly reachable (i.e.,
     * it is found in the network graph).
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    public_introduction_node_id(network_graph: ReadOnlyNetworkGraph): NodeId;
    /**
     * The [`IntroductionNode`] of the blinded path.
     */
    introduction_node(): IntroductionNode;
    /**
     * Used by the [`IntroductionNode`] to decrypt its [`encrypted_payload`] to forward the payment.
     *
     * [`encrypted_payload`]: BlindedHop::encrypted_payload
     */
    blinding_point(): Uint8Array;
    /**
     * The [`BlindedHop`]s within the blinded path.
     */
    blinded_hops(): BlindedHop[];
    /**
     * Advance the blinded onion payment path by one hop, making the second hop into the new
     * introduction node.
     *
     * Will only modify `self` when returning `Ok`.
     */
    advance_path_by_one(node_signer: NodeSigner, node_id_lookup: NodeIdLookUp): Result_NoneNoneZ;
}
