import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { BlindedHop } from '../structs/BlindedHop.mjs';
import { NodeId } from '../structs/NodeId.mjs';
import { BlindedPayInfo } from '../structs/BlindedPayInfo.mjs';
import { Result_BlindedPaymentPathNoneZ } from '../structs/Result_BlindedPaymentPathNoneZ.mjs';
import { IntroductionNode } from '../structs/IntroductionNode.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A blinded path to be used for sending or receiving a payment, hiding the identity of the
 * recipient.
 */
export class BlindedPaymentPath extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.BlindedPaymentPath_free);
    }
    /**
     * The [`BlindedPayInfo`] used to pay this blinded path.
     */
    get_payinfo() {
        const ret = bindings.BlindedPaymentPath_get_payinfo(this.ptr);
        const ret_hu_conv = new BlindedPayInfo(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The [`BlindedPayInfo`] used to pay this blinded path.
     */
    set_payinfo(val) {
        bindings.BlindedPaymentPath_set_payinfo(this.ptr, CommonBase.get_ptr_of(val));
    }
    clone_ptr() {
        const ret = bindings.BlindedPaymentPath_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the BlindedPaymentPath
     */
    clone() {
        const ret = bindings.BlindedPaymentPath_clone(this.ptr);
        const ret_hu_conv = new BlindedPaymentPath(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the BlindedPaymentPath.
     */
    hash() {
        const ret = bindings.BlindedPaymentPath_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two BlindedPaymentPaths contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.BlindedPaymentPath_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Create a one-hop blinded path for a payment.
     */
    static constructor_one_hop(payee_node_id, payee_tlvs, min_final_cltv_expiry_delta, entropy_source) {
        const ret = bindings.BlindedPaymentPath_one_hop(bindings.encodeUint8Array(bindings.check_arr_len(payee_node_id, 33)), CommonBase.get_ptr_of(payee_tlvs), min_final_cltv_expiry_delta, CommonBase.get_ptr_of(entropy_source));
        const ret_hu_conv = Result_BlindedPaymentPathNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        return ret_hu_conv;
    }
    /**
     * Create a blinded path for a payment, to be forwarded along `intermediate_nodes`.
     *
     * Errors if:
     * a provided node id is invalid
     * [`BlindedPayInfo`] calculation results in an integer overflow
     * any unknown features are required in the provided [`ForwardTlvs`]
     */
    static constructor_new(intermediate_nodes, payee_node_id, payee_tlvs, htlc_maximum_msat, min_final_cltv_expiry_delta, entropy_source) {
        const ret = bindings.BlindedPaymentPath_new(bindings.encodeUint64Array(intermediate_nodes.map(intermediate_nodes_conv_20 => CommonBase.get_ptr_of(intermediate_nodes_conv_20))), bindings.encodeUint8Array(bindings.check_arr_len(payee_node_id, 33)), CommonBase.get_ptr_of(payee_tlvs), htlc_maximum_msat, min_final_cltv_expiry_delta, CommonBase.get_ptr_of(entropy_source));
        const ret_hu_conv = Result_BlindedPaymentPathNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        return ret_hu_conv;
    }
    /**
     * Returns the introduction [`NodeId`] of the blinded path, if it is publicly reachable (i.e.,
     * it is found in the network graph).
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    public_introduction_node_id(network_graph) {
        const ret = bindings.BlindedPaymentPath_public_introduction_node_id(this.ptr, CommonBase.get_ptr_of(network_graph));
        const ret_hu_conv = new NodeId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        CommonBase.add_ref_from(this, network_graph);
        return ret_hu_conv;
    }
    /**
     * The [`IntroductionNode`] of the blinded path.
     */
    introduction_node() {
        const ret = bindings.BlindedPaymentPath_introduction_node(this.ptr);
        const ret_hu_conv = IntroductionNode.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Used by the [`IntroductionNode`] to decrypt its [`encrypted_payload`] to forward the payment.
     *
     * [`encrypted_payload`]: BlindedHop::encrypted_payload
     */
    blinding_point() {
        const ret = bindings.BlindedPaymentPath_blinding_point(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The [`BlindedHop`]s within the blinded path.
     */
    blinded_hops() {
        const ret = bindings.BlindedPaymentPath_blinded_hops(this.ptr);
        const ret_conv_12_len = bindings.getArrayLength(ret);
        const ret_conv_12_arr = new Array(ret_conv_12_len).fill(null);
        for (var m = 0; m < ret_conv_12_len; m++) {
            const ret_conv_12 = bindings.getU64ArrayElem(ret, m);
            const ret_conv_12_hu_conv = new BlindedHop(null, ret_conv_12);
            CommonBase.add_ref_from(ret_conv_12_hu_conv, this);
            ret_conv_12_arr[m] = ret_conv_12_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_12_arr;
    }
    /**
     * Advance the blinded onion payment path by one hop, making the second hop into the new
     * introduction node.
     *
     * Will only modify `self` when returning `Ok`.
     */
    advance_path_by_one(node_signer, node_id_lookup) {
        const ret = bindings.BlindedPaymentPath_advance_path_by_one(this.ptr, CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(node_id_lookup));
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, node_signer);
        CommonBase.add_ref_from(this, node_id_lookup);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=BlindedPaymentPath.mjs.map