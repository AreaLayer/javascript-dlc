import { Option_u64Z } from '../structs/Option_u64Z.mjs';
import { Option_CVec_u8ZZ } from '../structs/Option_CVec_u8ZZ.mjs';
import { RouteHint } from '../structs/RouteHint.mjs';
import { Bolt11InvoiceFeatures } from '../structs/Bolt11InvoiceFeatures.mjs';
import { Result_Bolt11InvoiceParseOrSemanticErrorZ } from '../structs/Result_Bolt11InvoiceParseOrSemanticErrorZ.mjs';
import { SignedRawBolt11Invoice } from '../structs/SignedRawBolt11Invoice.mjs';
import { PrivateRoute } from '../structs/PrivateRoute.mjs';
import { Result_NoneBolt11SemanticErrorZ } from '../structs/Result_NoneBolt11SemanticErrorZ.mjs';
import { Result_Bolt11InvoiceBolt11SemanticErrorZ } from '../structs/Result_Bolt11InvoiceBolt11SemanticErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Represents a syntactically and semantically correct lightning BOLT11 invoice.
 *
 * There are three ways to construct a `Bolt11Invoice`:
 * 1. using [`InvoiceBuilder`]
 * 2. using [`Bolt11Invoice::from_signed`]
 * 3. using `str::parse::<Bolt11Invoice>(&str)` (see [`Bolt11Invoice::from_str`])
 *
 * [`Bolt11Invoice::from_str`]: crate::Bolt11Invoice#impl-FromStr
 */
export class Bolt11Invoice extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.Bolt11Invoice_free);
    }
    /**
     * Checks if two Bolt11Invoices contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.Bolt11Invoice_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    clone_ptr() {
        const ret = bindings.Bolt11Invoice_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Bolt11Invoice
     */
    clone() {
        const ret = bindings.Bolt11Invoice_clone(this.ptr);
        const ret_hu_conv = new Bolt11Invoice(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the Bolt11Invoice.
     */
    hash() {
        const ret = bindings.Bolt11Invoice_hash(this.ptr);
        return ret;
    }
    /**
     * The hash of the [`RawBolt11Invoice`] that was signed.
     */
    signable_hash() {
        const ret = bindings.Bolt11Invoice_signable_hash(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Transform the `Bolt11Invoice` into its unchecked version.
     */
    into_signed_raw() {
        const ret = bindings.Bolt11Invoice_into_signed_raw(this.ptr);
        const ret_hu_conv = new SignedRawBolt11Invoice(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Check that the invoice is signed correctly and that key recovery works
     */
    check_signature() {
        const ret = bindings.Bolt11Invoice_check_signature(this.ptr);
        const ret_hu_conv = Result_NoneBolt11SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Constructs a `Bolt11Invoice` from a [`SignedRawBolt11Invoice`] by checking all its invariants.
     * ```
     * use lightning_invoice::*;
     *
     * let invoice = \"lnbc100p1psj9jhxdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4q0d3p2sfluzdx45tqcs\\
     * h2pu5qc7lgq0xs578ngs6s0s68ua4h7cvspp5q6rmq35js88zp5dvwrv9m459tnk2zunwj5jalqtyxqulh0l\\
     * 5gflssp5nf55ny5gcrfl30xuhzj3nphgj27rstekmr9fw3ny5989s300gyus9qyysgqcqpcrzjqw2sxwe993\\
     * h5pcm4dxzpvttgza8zhkqxpgffcrf5v25nwpr3cmfg7z54kuqq8rgqqqqqqqq2qqqqq9qq9qrzjqd0ylaqcl\\
     * j9424x9m8h2vcukcgnm6s56xfgu3j78zyqzhgs4hlpzvznlugqq9vsqqqqqqqlgqqqqqeqq9qrzjqwldmj9d\\
     * ha74df76zhx6l9we0vjdquygcdt3kssupehe64g6yyp5yz5rhuqqwccqqyqqqqlgqqqqjcqq9qrzjqf9e58a\\
     * guqr0rcun0ajlvmzq3ek63cw2w282gv3z5uupmuwvgjtq2z55qsqqg6qqqyqqqrtnqqqzq3cqygrzjqvphms\\
     * ywntrrhqjcraumvc4y6r8v4z5v593trte429v4hredj7ms5z52usqq9ngqqqqqqqlgqqqqqqgq9qrzjq2v0v\\
     * p62g49p7569ev48cmulecsxe59lvaw3wlxm7r982zxa9zzj7z5l0cqqxusqqyqqqqlgqqqqqzsqygarl9fh3\\
     * 8s0gyuxjjgux34w75dnc6xp2l35j7es3jd4ugt3lu0xzre26yg5m7ke54n2d5sym4xcmxtl8238xxvw5h5h5\\
     * j5r6drg6k6zcqj0fcwg\";
     *
     * let signed = invoice.parse::<SignedRawBolt11Invoice>().unwrap();
     *
     * assert!(Bolt11Invoice::from_signed(signed).is_ok());
     * ```
     */
    static constructor_from_signed(signed_invoice) {
        const ret = bindings.Bolt11Invoice_from_signed(CommonBase.get_ptr_of(signed_invoice));
        const ret_hu_conv = Result_Bolt11InvoiceBolt11SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns the `Bolt11Invoice`'s timestamp as a duration since the Unix epoch
     */
    duration_since_epoch() {
        const ret = bindings.Bolt11Invoice_duration_since_epoch(this.ptr);
        return ret;
    }
    /**
     * Returns the hash to which we will receive the preimage on completion of the payment
     */
    payment_hash() {
        const ret = bindings.Bolt11Invoice_payment_hash(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get the payee's public key if one was included in the invoice
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    payee_pub_key() {
        const ret = bindings.Bolt11Invoice_payee_pub_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get the payment secret if one was included in the invoice
     */
    payment_secret() {
        const ret = bindings.Bolt11Invoice_payment_secret(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get the payment metadata blob if one was included in the invoice
     */
    payment_metadata() {
        const ret = bindings.Bolt11Invoice_payment_metadata(this.ptr);
        const ret_hu_conv = Option_CVec_u8ZZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Get the invoice features if they were included in the invoice
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    features() {
        const ret = bindings.Bolt11Invoice_features(this.ptr);
        const ret_hu_conv = new Bolt11InvoiceFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Recover the payee's public key (only to be used if none was included in the invoice)
     */
    recover_payee_pub_key() {
        const ret = bindings.Bolt11Invoice_recover_payee_pub_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Recover the payee's public key if one was included in the invoice, otherwise return the
     * recovered public key from the signature
     */
    get_payee_pub_key() {
        const ret = bindings.Bolt11Invoice_get_payee_pub_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the Duration since the Unix epoch at which the invoice expires.
     * Returning None if overflow occurred.
     */
    expires_at() {
        const ret = bindings.Bolt11Invoice_expires_at(this.ptr);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the invoice's expiry time, if present, otherwise [`DEFAULT_EXPIRY_TIME`].
     */
    expiry_time() {
        const ret = bindings.Bolt11Invoice_expiry_time(this.ptr);
        return ret;
    }
    /**
     * Returns the Duration remaining until the invoice expires given the current time.
     * `time` is the timestamp as a duration since the Unix epoch.
     */
    expiration_remaining_from_epoch(time) {
        const ret = bindings.Bolt11Invoice_expiration_remaining_from_epoch(this.ptr, time);
        return ret;
    }
    /**
     * Returns whether the expiry time would pass at the given point in time.
     * `at_time` is the timestamp as a duration since the Unix epoch.
     */
    would_expire(at_time) {
        const ret = bindings.Bolt11Invoice_would_expire(this.ptr, at_time);
        return ret;
    }
    /**
     * Returns the invoice's `min_final_cltv_expiry_delta` time, if present, otherwise
     * [`DEFAULT_MIN_FINAL_CLTV_EXPIRY_DELTA`].
     */
    min_final_cltv_expiry_delta() {
        const ret = bindings.Bolt11Invoice_min_final_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * Returns a list of all fallback addresses as [`Address`]es
     */
    fallback_addresses() {
        const ret = bindings.Bolt11Invoice_fallback_addresses(this.ptr);
        const ret_conv_8_len = bindings.getArrayLength(ret);
        const ret_conv_8_arr = new Array(ret_conv_8_len).fill(null);
        for (var i = 0; i < ret_conv_8_len; i++) {
            const ret_conv_8 = bindings.getU32ArrayElem(ret, i);
            const ret_conv_8_conv = bindings.decodeString(ret_conv_8);
            ret_conv_8_arr[i] = ret_conv_8_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_8_arr;
    }
    /**
     * Returns a list of all routes included in the invoice
     */
    private_routes() {
        const ret = bindings.Bolt11Invoice_private_routes(this.ptr);
        const ret_conv_14_len = bindings.getArrayLength(ret);
        const ret_conv_14_arr = new Array(ret_conv_14_len).fill(null);
        for (var o = 0; o < ret_conv_14_len; o++) {
            const ret_conv_14 = bindings.getU64ArrayElem(ret, o);
            const ret_conv_14_hu_conv = new PrivateRoute(null, ret_conv_14);
            CommonBase.add_ref_from(ret_conv_14_hu_conv, this);
            ret_conv_14_arr[o] = ret_conv_14_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_14_arr;
    }
    /**
     * Returns a list of all routes included in the invoice as the underlying hints
     */
    route_hints() {
        const ret = bindings.Bolt11Invoice_route_hints(this.ptr);
        const ret_conv_11_len = bindings.getArrayLength(ret);
        const ret_conv_11_arr = new Array(ret_conv_11_len).fill(null);
        for (var l = 0; l < ret_conv_11_len; l++) {
            const ret_conv_11 = bindings.getU64ArrayElem(ret, l);
            const ret_conv_11_hu_conv = new RouteHint(null, ret_conv_11);
            CommonBase.add_ref_from(ret_conv_11_hu_conv, this);
            ret_conv_11_arr[l] = ret_conv_11_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_11_arr;
    }
    /**
     * Returns the currency for which the invoice was issued
     */
    currency() {
        const ret = bindings.Bolt11Invoice_currency(this.ptr);
        return ret;
    }
    /**
     * Returns the amount if specified in the invoice as millisatoshis.
     */
    amount_milli_satoshis() {
        const ret = bindings.Bolt11Invoice_amount_milli_satoshis(this.ptr);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Read a Bolt11Invoice object from a string
     */
    static constructor_from_str(s) {
        const ret = bindings.Bolt11Invoice_from_str(bindings.encodeString(s));
        const ret_hu_conv = Result_Bolt11InvoiceParseOrSemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Get the string representation of a Bolt11Invoice object
     */
    to_str() {
        const ret = bindings.Bolt11Invoice_to_str(this.ptr);
        const ret_conv = bindings.decodeString(ret);
        return ret_conv;
    }
}
//# sourceMappingURL=Bolt11Invoice.mjs.map