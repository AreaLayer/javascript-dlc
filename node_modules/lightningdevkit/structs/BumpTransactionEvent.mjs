import { HTLCDescriptor } from '../structs/HTLCDescriptor.mjs';
import { HTLCOutputInCommitment } from '../structs/HTLCOutputInCommitment.mjs';
import { ChannelId } from '../structs/ChannelId.mjs';
import { AnchorDescriptor } from '../structs/AnchorDescriptor.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Represents the different types of transactions, originating from LDK, to be bumped.
 */
export class BumpTransactionEvent extends CommonBase {
    constructor(_dummy, ptr) { super(ptr, bindings.BumpTransactionEvent_free); }
    /* @internal */
    static constr_from_ptr(ptr) {
        const raw_ty = bindings.LDKBumpTransactionEvent_ty_from_ptr(ptr);
        switch (raw_ty) {
            case 0: return new BumpTransactionEvent_ChannelClose(ptr);
            case 1: return new BumpTransactionEvent_HTLCResolution(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = bindings.BumpTransactionEvent_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the BumpTransactionEvent
     */
    clone() {
        const ret = bindings.BumpTransactionEvent_clone(this.ptr);
        const ret_hu_conv = BumpTransactionEvent.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ChannelClose-variant BumpTransactionEvent
     */
    static constructor_channel_close(channel_id, counterparty_node_id, claim_id, package_target_feerate_sat_per_1000_weight, commitment_tx, commitment_tx_fee_satoshis, anchor_descriptor, pending_htlcs) {
        const ret = bindings.BumpTransactionEvent_channel_close(CommonBase.get_ptr_of(channel_id), bindings.encodeUint8Array(bindings.check_arr_len(counterparty_node_id, 33)), bindings.encodeUint8Array(bindings.check_arr_len(claim_id, 32)), package_target_feerate_sat_per_1000_weight, bindings.encodeUint8Array(commitment_tx), commitment_tx_fee_satoshis, CommonBase.get_ptr_of(anchor_descriptor), bindings.encodeUint64Array(pending_htlcs.map(pending_htlcs_conv_24 => CommonBase.get_ptr_of(pending_htlcs_conv_24))));
        const ret_hu_conv = BumpTransactionEvent.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new HTLCResolution-variant BumpTransactionEvent
     */
    static constructor_htlcresolution(channel_id, counterparty_node_id, claim_id, target_feerate_sat_per_1000_weight, htlc_descriptors, tx_lock_time) {
        const ret = bindings.BumpTransactionEvent_htlcresolution(CommonBase.get_ptr_of(channel_id), bindings.encodeUint8Array(bindings.check_arr_len(counterparty_node_id, 33)), bindings.encodeUint8Array(bindings.check_arr_len(claim_id, 32)), target_feerate_sat_per_1000_weight, bindings.encodeUint64Array(htlc_descriptors.map(htlc_descriptors_conv_16 => CommonBase.get_ptr_of(htlc_descriptors_conv_16))), tx_lock_time);
        const ret_hu_conv = BumpTransactionEvent.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Checks if two BumpTransactionEvents contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     */
    eq(b) {
        const ret = bindings.BumpTransactionEvent_eq(this.ptr, CommonBase.get_ptr_of(b));
        return ret;
    }
}
/** A BumpTransactionEvent of type ChannelClose */
export class BumpTransactionEvent_ChannelClose extends BumpTransactionEvent {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const channel_id = bindings.LDKBumpTransactionEvent_ChannelClose_get_channel_id(ptr);
        const channel_id_hu_conv = new ChannelId(null, channel_id);
        CommonBase.add_ref_from(channel_id_hu_conv, this);
        this.channel_id = channel_id_hu_conv;
        const counterparty_node_id = bindings.LDKBumpTransactionEvent_ChannelClose_get_counterparty_node_id(ptr);
        const counterparty_node_id_conv = bindings.decodeUint8Array(counterparty_node_id);
        this.counterparty_node_id = counterparty_node_id_conv;
        const claim_id = bindings.LDKBumpTransactionEvent_ChannelClose_get_claim_id(ptr);
        const claim_id_conv = bindings.decodeUint8Array(claim_id);
        this.claim_id = claim_id_conv;
        this.package_target_feerate_sat_per_1000_weight = bindings.LDKBumpTransactionEvent_ChannelClose_get_package_target_feerate_sat_per_1000_weight(ptr);
        const commitment_tx = bindings.LDKBumpTransactionEvent_ChannelClose_get_commitment_tx(ptr);
        const commitment_tx_conv = bindings.decodeUint8Array(commitment_tx);
        this.commitment_tx = commitment_tx_conv;
        this.commitment_tx_fee_satoshis = bindings.LDKBumpTransactionEvent_ChannelClose_get_commitment_tx_fee_satoshis(ptr);
        const anchor_descriptor = bindings.LDKBumpTransactionEvent_ChannelClose_get_anchor_descriptor(ptr);
        const anchor_descriptor_hu_conv = new AnchorDescriptor(null, anchor_descriptor);
        CommonBase.add_ref_from(anchor_descriptor_hu_conv, this);
        this.anchor_descriptor = anchor_descriptor_hu_conv;
        const pending_htlcs = bindings.LDKBumpTransactionEvent_ChannelClose_get_pending_htlcs(ptr);
        const pending_htlcs_conv_24_len = bindings.getArrayLength(pending_htlcs);
        const pending_htlcs_conv_24_arr = new Array(pending_htlcs_conv_24_len).fill(null);
        for (var y = 0; y < pending_htlcs_conv_24_len; y++) {
            const pending_htlcs_conv_24 = bindings.getU64ArrayElem(pending_htlcs, y);
            const pending_htlcs_conv_24_hu_conv = new HTLCOutputInCommitment(null, pending_htlcs_conv_24);
            CommonBase.add_ref_from(pending_htlcs_conv_24_hu_conv, this);
            pending_htlcs_conv_24_arr[y] = pending_htlcs_conv_24_hu_conv;
        }
        bindings.freeWasmMemory(pending_htlcs);
        this.pending_htlcs = pending_htlcs_conv_24_arr;
    }
}
/** A BumpTransactionEvent of type HTLCResolution */
export class BumpTransactionEvent_HTLCResolution extends BumpTransactionEvent {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const channel_id = bindings.LDKBumpTransactionEvent_HTLCResolution_get_channel_id(ptr);
        const channel_id_hu_conv = new ChannelId(null, channel_id);
        CommonBase.add_ref_from(channel_id_hu_conv, this);
        this.channel_id = channel_id_hu_conv;
        const counterparty_node_id = bindings.LDKBumpTransactionEvent_HTLCResolution_get_counterparty_node_id(ptr);
        const counterparty_node_id_conv = bindings.decodeUint8Array(counterparty_node_id);
        this.counterparty_node_id = counterparty_node_id_conv;
        const claim_id = bindings.LDKBumpTransactionEvent_HTLCResolution_get_claim_id(ptr);
        const claim_id_conv = bindings.decodeUint8Array(claim_id);
        this.claim_id = claim_id_conv;
        this.target_feerate_sat_per_1000_weight = bindings.LDKBumpTransactionEvent_HTLCResolution_get_target_feerate_sat_per_1000_weight(ptr);
        const htlc_descriptors = bindings.LDKBumpTransactionEvent_HTLCResolution_get_htlc_descriptors(ptr);
        const htlc_descriptors_conv_16_len = bindings.getArrayLength(htlc_descriptors);
        const htlc_descriptors_conv_16_arr = new Array(htlc_descriptors_conv_16_len).fill(null);
        for (var q = 0; q < htlc_descriptors_conv_16_len; q++) {
            const htlc_descriptors_conv_16 = bindings.getU64ArrayElem(htlc_descriptors, q);
            const htlc_descriptors_conv_16_hu_conv = new HTLCDescriptor(null, htlc_descriptors_conv_16);
            CommonBase.add_ref_from(htlc_descriptors_conv_16_hu_conv, this);
            htlc_descriptors_conv_16_arr[q] = htlc_descriptors_conv_16_hu_conv;
        }
        bindings.freeWasmMemory(htlc_descriptors);
        this.htlc_descriptors = htlc_descriptors_conv_16_arr;
        this.tx_lock_time = bindings.LDKBumpTransactionEvent_HTLCResolution_get_tx_lock_time(ptr);
    }
}
//# sourceMappingURL=BumpTransactionEvent.mjs.map