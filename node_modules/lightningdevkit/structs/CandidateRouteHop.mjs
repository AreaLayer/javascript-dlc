import { Option_u64Z } from '../structs/Option_u64Z.mjs';
import { NodeId } from '../structs/NodeId.mjs';
import { RoutingFees } from '../structs/RoutingFees.mjs';
import { FirstHopCandidate } from '../structs/FirstHopCandidate.mjs';
import { PublicHopCandidate } from '../structs/PublicHopCandidate.mjs';
import { PrivateHopCandidate } from '../structs/PrivateHopCandidate.mjs';
import { BlindedPathCandidate } from '../structs/BlindedPathCandidate.mjs';
import { OneHopBlindedPathCandidate } from '../structs/OneHopBlindedPathCandidate.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A wrapper around the various hop representations.
 *
 * Can be used to examine the properties of a hop,
 * potentially to decide whether to include it in a route.
 */
export class CandidateRouteHop extends CommonBase {
    constructor(_dummy, ptr) { super(ptr, bindings.CandidateRouteHop_free); }
    /* @internal */
    static constr_from_ptr(ptr) {
        const raw_ty = bindings.LDKCandidateRouteHop_ty_from_ptr(ptr);
        switch (raw_ty) {
            case 0: return new CandidateRouteHop_FirstHop(ptr);
            case 1: return new CandidateRouteHop_PublicHop(ptr);
            case 2: return new CandidateRouteHop_PrivateHop(ptr);
            case 3: return new CandidateRouteHop_Blinded(ptr);
            case 4: return new CandidateRouteHop_OneHopBlinded(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = bindings.CandidateRouteHop_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the CandidateRouteHop
     */
    clone() {
        const ret = bindings.CandidateRouteHop_clone(this.ptr);
        const ret_hu_conv = CandidateRouteHop.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new FirstHop-variant CandidateRouteHop
     */
    static constructor_first_hop(a) {
        const ret = bindings.CandidateRouteHop_first_hop(CommonBase.get_ptr_of(a));
        const ret_hu_conv = CandidateRouteHop.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PublicHop-variant CandidateRouteHop
     */
    static constructor_public_hop(a) {
        const ret = bindings.CandidateRouteHop_public_hop(CommonBase.get_ptr_of(a));
        const ret_hu_conv = CandidateRouteHop.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new PrivateHop-variant CandidateRouteHop
     */
    static constructor_private_hop(a) {
        const ret = bindings.CandidateRouteHop_private_hop(CommonBase.get_ptr_of(a));
        const ret_hu_conv = CandidateRouteHop.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new Blinded-variant CandidateRouteHop
     */
    static constructor_blinded(a) {
        const ret = bindings.CandidateRouteHop_blinded(CommonBase.get_ptr_of(a));
        const ret_hu_conv = CandidateRouteHop.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new OneHopBlinded-variant CandidateRouteHop
     */
    static constructor_one_hop_blinded(a) {
        const ret = bindings.CandidateRouteHop_one_hop_blinded(CommonBase.get_ptr_of(a));
        const ret_hu_conv = CandidateRouteHop.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns the globally unique short channel ID for this hop, if one is known.
     *
     * This only returns `Some` if the channel is public (either our own, or one we've learned
     * from the public network graph), and thus the short channel ID we have for this channel is
     * globally unique and identifies this channel in a global namespace.
     */
    globally_unique_short_channel_id() {
        const ret = bindings.CandidateRouteHop_globally_unique_short_channel_id(this.ptr);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the required difference in HTLC CLTV expiry between the [`Self::source`] and the
     * next-hop for an HTLC taking this hop.
     *
     * This is the time that the node(s) in this hop have to claim the HTLC on-chain if the
     * next-hop goes on chain with a payment preimage.
     */
    cltv_expiry_delta() {
        const ret = bindings.CandidateRouteHop_cltv_expiry_delta(this.ptr);
        return ret;
    }
    /**
     * Returns the minimum amount that can be sent over this hop, in millisatoshis.
     */
    htlc_minimum_msat() {
        const ret = bindings.CandidateRouteHop_htlc_minimum_msat(this.ptr);
        return ret;
    }
    /**
     * Returns the fees that must be paid to route an HTLC over this channel.
     */
    fees() {
        const ret = bindings.CandidateRouteHop_fees(this.ptr);
        const ret_hu_conv = new RoutingFees(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the source node id of current hop.
     *
     * Source node id refers to the node forwarding the HTLC through this hop.
     *
     * For [`Self::FirstHop`] we return payer's node id.
     */
    source() {
        const ret = bindings.CandidateRouteHop_source(this.ptr);
        const ret_hu_conv = new NodeId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the target node id of this hop, if known.
     *
     * Target node id refers to the node receiving the HTLC after this hop.
     *
     * For [`Self::Blinded`] we return `None` because the ultimate destination after the blinded
     * path is unknown.
     *
     * For [`Self::OneHopBlinded`] we return `None` because the target is the same as the source,
     * and such a return value would be somewhat nonsensical.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    target() {
        const ret = bindings.CandidateRouteHop_target(this.ptr);
        const ret_hu_conv = new NodeId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
/** A CandidateRouteHop of type FirstHop */
export class CandidateRouteHop_FirstHop extends CandidateRouteHop {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const first_hop = bindings.LDKCandidateRouteHop_FirstHop_get_first_hop(ptr);
        const first_hop_hu_conv = new FirstHopCandidate(null, first_hop);
        CommonBase.add_ref_from(first_hop_hu_conv, this);
        this.first_hop = first_hop_hu_conv;
    }
}
/** A CandidateRouteHop of type PublicHop */
export class CandidateRouteHop_PublicHop extends CandidateRouteHop {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const public_hop = bindings.LDKCandidateRouteHop_PublicHop_get_public_hop(ptr);
        const public_hop_hu_conv = new PublicHopCandidate(null, public_hop);
        CommonBase.add_ref_from(public_hop_hu_conv, this);
        this.public_hop = public_hop_hu_conv;
    }
}
/** A CandidateRouteHop of type PrivateHop */
export class CandidateRouteHop_PrivateHop extends CandidateRouteHop {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const private_hop = bindings.LDKCandidateRouteHop_PrivateHop_get_private_hop(ptr);
        const private_hop_hu_conv = new PrivateHopCandidate(null, private_hop);
        CommonBase.add_ref_from(private_hop_hu_conv, this);
        this.private_hop = private_hop_hu_conv;
    }
}
/** A CandidateRouteHop of type Blinded */
export class CandidateRouteHop_Blinded extends CandidateRouteHop {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const blinded = bindings.LDKCandidateRouteHop_Blinded_get_blinded(ptr);
        const blinded_hu_conv = new BlindedPathCandidate(null, blinded);
        CommonBase.add_ref_from(blinded_hu_conv, this);
        this.blinded = blinded_hu_conv;
    }
}
/** A CandidateRouteHop of type OneHopBlinded */
export class CandidateRouteHop_OneHopBlinded extends CandidateRouteHop {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const one_hop_blinded = bindings.LDKCandidateRouteHop_OneHopBlinded_get_one_hop_blinded(ptr);
        const one_hop_blinded_hu_conv = new OneHopBlindedPathCandidate(null, one_hop_blinded);
        CommonBase.add_ref_from(one_hop_blinded_hu_conv, this);
        this.one_hop_blinded = one_hop_blinded_hu_conv;
    }
}
//# sourceMappingURL=CandidateRouteHop.mjs.map