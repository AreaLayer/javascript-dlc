import { Result_NoneAPIErrorZ } from '../structs/Result_NoneAPIErrorZ.mjs';
import { OutPoint } from '../structs/OutPoint.mjs';
import { ChannelDetails } from '../structs/ChannelDetails.mjs';
import { Logger } from '../structs/Logger.mjs';
import { Watch } from '../structs/Watch.mjs';
import { BroadcasterInterface } from '../structs/BroadcasterInterface.mjs';
import { FeeEstimator } from '../structs/FeeEstimator.mjs';
import { Balance } from '../structs/Balance.mjs';
import { Option_FilterZ } from '../structs/Option_FilterZ.mjs';
import { Result_LockedChannelMonitorNoneZ } from '../structs/Result_LockedChannelMonitorNoneZ.mjs';
import { TwoTuple_OutPointChannelIdZ } from '../structs/TwoTuple_OutPointChannelIdZ.mjs';
import { TwoTuple_OutPointCVec_u64ZZ } from '../structs/TwoTuple_OutPointCVec_u64ZZ.mjs';
import { Persist } from '../structs/Persist.mjs';
import { Listen } from '../structs/Listen.mjs';
import { Confirm } from '../structs/Confirm.mjs';
import { Future } from '../structs/Future.mjs';
import { EventsProvider } from '../structs/EventsProvider.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * Note that `ChainMonitor` should regularly trigger rebroadcasts/fee bumps of pending claims from
 * a force-closed channel. This is crucial in preventing certain classes of pinning attacks,
 * detecting substantial mempool feerate changes between blocks, and ensuring reliability if
 * broadcasting fails. We recommend invoking this every 30 seconds, or lower if running in an
 * environment with spotty connections, like on mobile.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 * [`rebroadcast_pending_claims`]: Self::rebroadcast_pending_claims
 */
export declare class ChainMonitor extends CommonBase {
    /**
     * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
     *
     * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
     * will call back to it indicating transactions and outputs of interest. This allows clients to
     * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
     * always need to fetch full blocks absent another means for determining which blocks contain
     * transactions relevant to the watched channels.
     */
    static constructor_new(chain_source: Option_FilterZ, broadcaster: BroadcasterInterface, logger: Logger, feeest: FeeEstimator, persister: Persist): ChainMonitor;
    /**
     * Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
     * claims which are awaiting confirmation.
     *
     * Includes the balances from each [`ChannelMonitor`] *except* those included in
     * `ignored_channels`.
     *
     * See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
     * inclusion in the return value.
     */
    get_claimable_balances(ignored_channels: ChannelDetails[]): Balance[];
    /**
     * Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
     * such [`ChannelMonitor`] is currently being monitored for.
     *
     * Note that the result holds a mutex over our monitor set, and should not be held
     * indefinitely.
     */
    get_monitor(funding_txo: OutPoint): Result_LockedChannelMonitorNoneZ;
    /**
     * Lists the funding outpoint and channel ID of each [`ChannelMonitor`] being monitored.
     *
     * Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
     * monitoring for on-chain state resolutions.
     */
    list_monitors(): TwoTuple_OutPointChannelIdZ[];
    /**
     * Lists the pending updates for each [`ChannelMonitor`] (by `OutPoint` being monitored).
     * Each `Vec<u64>` contains `update_id`s from [`ChannelMonitor::get_latest_update_id`] for updates
     * that have not yet been fully persisted. Note that if a full monitor is persisted all the pending
     * monitor updates must be individually marked completed by calling [`ChainMonitor::channel_monitor_updated`].
     */
    list_pending_monitor_updates(): TwoTuple_OutPointCVec_u64ZZ[];
    /**
     * Indicates the persistence of a [`ChannelMonitor`] has completed after
     * [`ChannelMonitorUpdateStatus::InProgress`] was returned from an update operation.
     *
     * Thus, the anticipated use is, at a high level:
     * 1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
     * update to disk and begins updating any remote (e.g. watchtower/backup) copies,
     * returning [`ChannelMonitorUpdateStatus::InProgress`],
     * 2) once all remote copies are updated, you call this function with [`ChannelMonitor::get_latest_update_id`]
     * or [`ChannelMonitorUpdate::update_id`] as the `completed_update_id`, and once all pending
     * updates have completed the channel will be re-enabled.
     *
     * It is only necessary to call [`ChainMonitor::channel_monitor_updated`] when you return [`ChannelMonitorUpdateStatus::InProgress`]
     * from [`Persist`] and either:
     * 1. A new [`ChannelMonitor`] was added in [`Persist::persist_new_channel`], or
     * 2. A [`ChannelMonitorUpdate`] was provided as part of [`Persist::update_persisted_channel`].
     * Note that we don't care about calls to [`Persist::update_persisted_channel`] where no
     * [`ChannelMonitorUpdate`] was provided.
     *
     * Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
     * registered [`ChannelMonitor`]s.
     */
    channel_monitor_updated(funding_txo: OutPoint, completed_update_id: bigint): Result_NoneAPIErrorZ;
    /**
     * Gets a [`Future`] that completes when an event is available either via
     * [`chain::Watch::release_pending_monitor_events`] or
     * [`EventsProvider::process_pending_events`].
     *
     * Note that callbacks registered on the [`Future`] MUST NOT call back into this
     * [`ChainMonitor`] and should instead register actions to be taken later.
     *
     * [`EventsProvider::process_pending_events`]: crate::events::EventsProvider::process_pending_events
     */
    get_update_future(): Future;
    /**
     * Triggers rebroadcasts/fee-bumps of pending claims from a force-closed channel. This is
     * crucial in preventing certain classes of pinning attacks, detecting substantial mempool
     * feerate changes between blocks, and ensuring reliability if broadcasting fails. We recommend
     * invoking this every 30 seconds, or lower if running in an environment with spotty
     * connections, like on mobile.
     */
    rebroadcast_pending_claims(): void;
    /**
     * Triggers rebroadcasts of pending claims from force-closed channels after a transaction
     * signature generation failure.
     *
     * `monitor_opt` can be used as a filter to only trigger them for a specific channel monitor.
     *
     * Note that monitor_opt (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    signer_unblocked(monitor_opt: OutPoint | null): void;
    /**
     * Archives fully resolved channel monitors by calling [`Persist::archive_persisted_channel`].
     *
     * This is useful for pruning fully resolved monitors from the monitor set and primary
     * storage so they are not kept in memory and reloaded on restart.
     *
     * Should be called occasionally (once every handful of blocks or on startup).
     *
     * Depending on the implementation of [`Persist::archive_persisted_channel`] the monitor
     * data could be moved to an archive location or removed entirely.
     */
    archive_fully_resolved_channel_monitors(): void;
    /**
     * Constructs a new Listen which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
     */
    as_Listen(): Listen;
    /**
     * Constructs a new Confirm which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
     */
    as_Confirm(): Confirm;
    /**
     * Constructs a new Watch which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
     */
    as_Watch(): Watch;
    /**
     * Constructs a new EventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
     */
    as_EventsProvider(): EventsProvider;
}
