import { Result_NoneAPIErrorZ } from '../structs/Result_NoneAPIErrorZ.mjs';
import { Watch } from '../structs/Watch.mjs';
import { Balance } from '../structs/Balance.mjs';
import { Result_LockedChannelMonitorNoneZ } from '../structs/Result_LockedChannelMonitorNoneZ.mjs';
import { TwoTuple_OutPointChannelIdZ } from '../structs/TwoTuple_OutPointChannelIdZ.mjs';
import { TwoTuple_OutPointCVec_u64ZZ } from '../structs/TwoTuple_OutPointCVec_u64ZZ.mjs';
import { Listen } from '../structs/Listen.mjs';
import { Confirm } from '../structs/Confirm.mjs';
import { Future } from '../structs/Future.mjs';
import { EventsProvider } from '../structs/EventsProvider.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * Note that `ChainMonitor` should regularly trigger rebroadcasts/fee bumps of pending claims from
 * a force-closed channel. This is crucial in preventing certain classes of pinning attacks,
 * detecting substantial mempool feerate changes between blocks, and ensuring reliability if
 * broadcasting fails. We recommend invoking this every 30 seconds, or lower if running in an
 * environment with spotty connections, like on mobile.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 * [`rebroadcast_pending_claims`]: Self::rebroadcast_pending_claims
 */
export class ChainMonitor extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ChainMonitor_free);
    }
    /**
     * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
     *
     * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
     * will call back to it indicating transactions and outputs of interest. This allows clients to
     * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
     * always need to fetch full blocks absent another means for determining which blocks contain
     * transactions relevant to the watched channels.
     */
    static constructor_new(chain_source, broadcaster, logger, feeest, persister) {
        const ret = bindings.ChainMonitor_new(CommonBase.get_ptr_of(chain_source), CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(logger), CommonBase.get_ptr_of(feeest), CommonBase.get_ptr_of(persister));
        const ret_hu_conv = new ChainMonitor(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, chain_source);
        CommonBase.add_ref_from(ret_hu_conv, broadcaster);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        CommonBase.add_ref_from(ret_hu_conv, feeest);
        CommonBase.add_ref_from(ret_hu_conv, persister);
        return ret_hu_conv;
    }
    /**
     * Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
     * claims which are awaiting confirmation.
     *
     * Includes the balances from each [`ChannelMonitor`] *except* those included in
     * `ignored_channels`.
     *
     * See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
     * inclusion in the return value.
     */
    get_claimable_balances(ignored_channels) {
        const ret = bindings.ChainMonitor_get_claimable_balances(this.ptr, bindings.encodeUint64Array(ignored_channels.map(ignored_channels_conv_16 => CommonBase.get_ptr_of(ignored_channels_conv_16))));
        const ret_conv_9_len = bindings.getArrayLength(ret);
        const ret_conv_9_arr = new Array(ret_conv_9_len).fill(null);
        for (var j = 0; j < ret_conv_9_len; j++) {
            const ret_conv_9 = bindings.getU64ArrayElem(ret, j);
            const ret_conv_9_hu_conv = Balance.constr_from_ptr(ret_conv_9);
            CommonBase.add_ref_from(ret_conv_9_hu_conv, this);
            ret_conv_9_arr[j] = ret_conv_9_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_9_arr;
    }
    /**
     * Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
     * such [`ChannelMonitor`] is currently being monitored for.
     *
     * Note that the result holds a mutex over our monitor set, and should not be held
     * indefinitely.
     */
    get_monitor(funding_txo) {
        const ret = bindings.ChainMonitor_get_monitor(this.ptr, CommonBase.get_ptr_of(funding_txo));
        const ret_hu_conv = Result_LockedChannelMonitorNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Lists the funding outpoint and channel ID of each [`ChannelMonitor`] being monitored.
     *
     * Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
     * monitoring for on-chain state resolutions.
     */
    list_monitors() {
        const ret = bindings.ChainMonitor_list_monitors(this.ptr);
        const ret_conv_29_len = bindings.getArrayLength(ret);
        const ret_conv_29_arr = new Array(ret_conv_29_len).fill(null);
        for (var d = 0; d < ret_conv_29_len; d++) {
            const ret_conv_29 = bindings.getU64ArrayElem(ret, d);
            const ret_conv_29_hu_conv = new TwoTuple_OutPointChannelIdZ(null, ret_conv_29);
            CommonBase.add_ref_from(ret_conv_29_hu_conv, this);
            ret_conv_29_arr[d] = ret_conv_29_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_29_arr;
    }
    /**
     * Lists the pending updates for each [`ChannelMonitor`] (by `OutPoint` being monitored).
     * Each `Vec<u64>` contains `update_id`s from [`ChannelMonitor::get_latest_update_id`] for updates
     * that have not yet been fully persisted. Note that if a full monitor is persisted all the pending
     * monitor updates must be individually marked completed by calling [`ChainMonitor::channel_monitor_updated`].
     */
    list_pending_monitor_updates() {
        const ret = bindings.ChainMonitor_list_pending_monitor_updates(this.ptr);
        const ret_conv_29_len = bindings.getArrayLength(ret);
        const ret_conv_29_arr = new Array(ret_conv_29_len).fill(null);
        for (var d = 0; d < ret_conv_29_len; d++) {
            const ret_conv_29 = bindings.getU64ArrayElem(ret, d);
            const ret_conv_29_hu_conv = new TwoTuple_OutPointCVec_u64ZZ(null, ret_conv_29);
            CommonBase.add_ref_from(ret_conv_29_hu_conv, this);
            ret_conv_29_arr[d] = ret_conv_29_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_29_arr;
    }
    /**
     * Indicates the persistence of a [`ChannelMonitor`] has completed after
     * [`ChannelMonitorUpdateStatus::InProgress`] was returned from an update operation.
     *
     * Thus, the anticipated use is, at a high level:
     * 1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
     * update to disk and begins updating any remote (e.g. watchtower/backup) copies,
     * returning [`ChannelMonitorUpdateStatus::InProgress`],
     * 2) once all remote copies are updated, you call this function with [`ChannelMonitor::get_latest_update_id`]
     * or [`ChannelMonitorUpdate::update_id`] as the `completed_update_id`, and once all pending
     * updates have completed the channel will be re-enabled.
     *
     * It is only necessary to call [`ChainMonitor::channel_monitor_updated`] when you return [`ChannelMonitorUpdateStatus::InProgress`]
     * from [`Persist`] and either:
     * 1. A new [`ChannelMonitor`] was added in [`Persist::persist_new_channel`], or
     * 2. A [`ChannelMonitorUpdate`] was provided as part of [`Persist::update_persisted_channel`].
     * Note that we don't care about calls to [`Persist::update_persisted_channel`] where no
     * [`ChannelMonitorUpdate`] was provided.
     *
     * Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
     * registered [`ChannelMonitor`]s.
     */
    channel_monitor_updated(funding_txo, completed_update_id) {
        const ret = bindings.ChainMonitor_channel_monitor_updated(this.ptr, CommonBase.get_ptr_of(funding_txo), completed_update_id);
        const ret_hu_conv = Result_NoneAPIErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets a [`Future`] that completes when an event is available either via
     * [`chain::Watch::release_pending_monitor_events`] or
     * [`EventsProvider::process_pending_events`].
     *
     * Note that callbacks registered on the [`Future`] MUST NOT call back into this
     * [`ChainMonitor`] and should instead register actions to be taken later.
     *
     * [`EventsProvider::process_pending_events`]: crate::events::EventsProvider::process_pending_events
     */
    get_update_future() {
        const ret = bindings.ChainMonitor_get_update_future(this.ptr);
        const ret_hu_conv = new Future(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Triggers rebroadcasts/fee-bumps of pending claims from a force-closed channel. This is
     * crucial in preventing certain classes of pinning attacks, detecting substantial mempool
     * feerate changes between blocks, and ensuring reliability if broadcasting fails. We recommend
     * invoking this every 30 seconds, or lower if running in an environment with spotty
     * connections, like on mobile.
     */
    rebroadcast_pending_claims() {
        bindings.ChainMonitor_rebroadcast_pending_claims(this.ptr);
    }
    /**
     * Triggers rebroadcasts of pending claims from force-closed channels after a transaction
     * signature generation failure.
     *
     * `monitor_opt` can be used as a filter to only trigger them for a specific channel monitor.
     *
     * Note that monitor_opt (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    signer_unblocked(monitor_opt) {
        bindings.ChainMonitor_signer_unblocked(this.ptr, monitor_opt == null ? 0n : CommonBase.get_ptr_of(monitor_opt));
    }
    /**
     * Archives fully resolved channel monitors by calling [`Persist::archive_persisted_channel`].
     *
     * This is useful for pruning fully resolved monitors from the monitor set and primary
     * storage so they are not kept in memory and reloaded on restart.
     *
     * Should be called occasionally (once every handful of blocks or on startup).
     *
     * Depending on the implementation of [`Persist::archive_persisted_channel`] the monitor
     * data could be moved to an archive location or removed entirely.
     */
    archive_fully_resolved_channel_monitors() {
        bindings.ChainMonitor_archive_fully_resolved_channel_monitors(this.ptr);
    }
    /**
     * Constructs a new Listen which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
     */
    as_Listen() {
        const ret = bindings.ChainMonitor_as_Listen(this.ptr);
        const ret_hu_conv = new Listen(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Confirm which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
     */
    as_Confirm() {
        const ret = bindings.ChainMonitor_as_Confirm(this.ptr);
        const ret_hu_conv = new Confirm(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Watch which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
     */
    as_Watch() {
        const ret = bindings.ChainMonitor_as_Watch(this.ptr);
        const ret_hu_conv = new Watch(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new EventsProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
     */
    as_EventsProvider() {
        const ret = bindings.ChainMonitor_as_EventsProvider(this.ptr);
        const ret_hu_conv = new EventsProvider(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=ChainMonitor.mjs.map