import { OutPoint } from '../structs/OutPoint.mjs';
import { EntropySource } from '../structs/EntropySource.mjs';
import { Result_ChannelIdDecodeErrorZ } from '../structs/Result_ChannelIdDecodeErrorZ.mjs';
import { RevocationBasepoint } from '../structs/RevocationBasepoint.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * A unique 32-byte identifier for a channel.
 * Depending on how the ID is generated, several varieties are distinguished
 * (but all are stored as 32 bytes):
 * _v1_ and _temporary_.
 * A _v1_ channel ID is generated based on funding tx outpoint (txid & index).
 * A _temporary_ ID is generated randomly.
 * (Later revocation-point-based _v2_ is a possibility.)
 * The variety (context) is not stored, it is relevant only at creation.
 */
export declare class ChannelId extends CommonBase {
    get_a(): Uint8Array;
    set_a(val: Uint8Array): void;
    /**
     * Constructs a new ChannelId given each field
     */
    static constructor_new(a_arg: Uint8Array): ChannelId;
    clone_ptr(): bigint;
    /**
     * Creates a copy of the ChannelId
     */
    clone(): ChannelId;
    /**
     * Checks if two ChannelIds contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b: ChannelId): boolean;
    /**
     * Generates a non-cryptographic 64-bit hash of the ChannelId.
     */
    hash(): bigint;
    /**
     * Create _v1_ channel ID based on a funding TX ID and output index
     */
    static constructor_v1_from_funding_txid(txid: Uint8Array, output_index: number): ChannelId;
    /**
     * Create _v1_ channel ID from a funding tx outpoint
     */
    static constructor_v1_from_funding_outpoint(outpoint: OutPoint): ChannelId;
    /**
     * Create a _temporary_ channel ID randomly, based on an entropy source.
     */
    static constructor_temporary_from_entropy_source(entropy_source: EntropySource): ChannelId;
    /**
     * Generic constructor; create a new channel ID from the provided data.
     * Use a more specific `*_from_*` constructor when possible.
     */
    static constructor_from_bytes(data: Uint8Array): ChannelId;
    /**
     * Create a channel ID consisting of all-zeros data (e.g. when uninitialized or a placeholder).
     */
    static constructor_new_zero(): ChannelId;
    /**
     * Check whether ID is consisting of all zeros (uninitialized)
     */
    is_zero(): boolean;
    /**
     * Create _v2_ channel ID by concatenating the holder revocation basepoint with the counterparty
     * revocation basepoint and hashing the result. The basepoints will be concatenated in increasing
     * sorted order.
     */
    static constructor_v2_from_revocation_basepoints(ours: RevocationBasepoint, theirs: RevocationBasepoint): ChannelId;
    /**
     * Create temporary _v2_ channel ID by concatenating a zeroed out basepoint with the holder
     * revocation basepoint and hashing the result.
     */
    static constructor_temporary_v2_from_revocation_basepoint(our_revocation_basepoint: RevocationBasepoint): ChannelId;
    /**
     * Serialize the ChannelId object into a byte array which can be read by ChannelId_read
     */
    write(): Uint8Array;
    /**
     * Read a ChannelId from a byte array, created by ChannelId_write
     */
    static constructor_read(ser: Uint8Array): Result_ChannelIdDecodeErrorZ;
    /**
     * Get the string representation of a ChannelId object
     */
    to_str(): string;
}
