import { Result_ChannelIdDecodeErrorZ } from '../structs/Result_ChannelIdDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A unique 32-byte identifier for a channel.
 * Depending on how the ID is generated, several varieties are distinguished
 * (but all are stored as 32 bytes):
 * _v1_ and _temporary_.
 * A _v1_ channel ID is generated based on funding tx outpoint (txid & index).
 * A _temporary_ ID is generated randomly.
 * (Later revocation-point-based _v2_ is a possibility.)
 * The variety (context) is not stored, it is relevant only at creation.
 */
export class ChannelId extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ChannelId_free);
    }
    get_a() {
        const ret = bindings.ChannelId_get_a(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    set_a(val) {
        bindings.ChannelId_set_a(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * Constructs a new ChannelId given each field
     */
    static constructor_new(a_arg) {
        const ret = bindings.ChannelId_new(bindings.encodeUint8Array(bindings.check_arr_len(a_arg, 32)));
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.ChannelId_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelId
     */
    clone() {
        const ret = bindings.ChannelId_clone(this.ptr);
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two ChannelIds contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.ChannelId_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the ChannelId.
     */
    hash() {
        const ret = bindings.ChannelId_hash(this.ptr);
        return ret;
    }
    /**
     * Create _v1_ channel ID based on a funding TX ID and output index
     */
    static constructor_v1_from_funding_txid(txid, output_index) {
        const ret = bindings.ChannelId_v1_from_funding_txid(bindings.encodeUint8Array(bindings.check_arr_len(txid, 32)), output_index);
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Create _v1_ channel ID from a funding tx outpoint
     */
    static constructor_v1_from_funding_outpoint(outpoint) {
        const ret = bindings.ChannelId_v1_from_funding_outpoint(CommonBase.get_ptr_of(outpoint));
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Create a _temporary_ channel ID randomly, based on an entropy source.
     */
    static constructor_temporary_from_entropy_source(entropy_source) {
        const ret = bindings.ChannelId_temporary_from_entropy_source(CommonBase.get_ptr_of(entropy_source));
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        return ret_hu_conv;
    }
    /**
     * Generic constructor; create a new channel ID from the provided data.
     * Use a more specific `*_from_*` constructor when possible.
     */
    static constructor_from_bytes(data) {
        const ret = bindings.ChannelId_from_bytes(bindings.encodeUint8Array(bindings.check_arr_len(data, 32)));
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Create a channel ID consisting of all-zeros data (e.g. when uninitialized or a placeholder).
     */
    static constructor_new_zero() {
        const ret = bindings.ChannelId_new_zero();
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Check whether ID is consisting of all zeros (uninitialized)
     */
    is_zero() {
        const ret = bindings.ChannelId_is_zero(this.ptr);
        return ret;
    }
    /**
     * Create _v2_ channel ID by concatenating the holder revocation basepoint with the counterparty
     * revocation basepoint and hashing the result. The basepoints will be concatenated in increasing
     * sorted order.
     */
    static constructor_v2_from_revocation_basepoints(ours, theirs) {
        const ret = bindings.ChannelId_v2_from_revocation_basepoints(CommonBase.get_ptr_of(ours), CommonBase.get_ptr_of(theirs));
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, ours);
        CommonBase.add_ref_from(ret_hu_conv, theirs);
        return ret_hu_conv;
    }
    /**
     * Create temporary _v2_ channel ID by concatenating a zeroed out basepoint with the holder
     * revocation basepoint and hashing the result.
     */
    static constructor_temporary_v2_from_revocation_basepoint(our_revocation_basepoint) {
        const ret = bindings.ChannelId_temporary_v2_from_revocation_basepoint(CommonBase.get_ptr_of(our_revocation_basepoint));
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, our_revocation_basepoint);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelId object into a byte array which can be read by ChannelId_read
     */
    write() {
        const ret = bindings.ChannelId_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ChannelId from a byte array, created by ChannelId_write
     */
    static constructor_read(ser) {
        const ret = bindings.ChannelId_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_ChannelIdDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Get the string representation of a ChannelId object
     */
    to_str() {
        const ret = bindings.ChannelId_to_str(this.ptr);
        const ret_conv = bindings.decodeString(ret);
        return ret_conv;
    }
}
//# sourceMappingURL=ChannelId.mjs.map