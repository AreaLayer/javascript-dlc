import { Option_CVec_ThirtyTwoBytesZZ } from '../structs/Option_CVec_ThirtyTwoBytesZZ.mjs';
import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { InitFeatures } from '../structs/InitFeatures.mjs';
import { NodeFeatures } from '../structs/NodeFeatures.mjs';
import { ChannelUpdate } from '../structs/ChannelUpdate.mjs';
import { AcceptChannel } from '../structs/AcceptChannel.mjs';
import { AcceptChannelV2 } from '../structs/AcceptChannelV2.mjs';
import { OpenChannel } from '../structs/OpenChannel.mjs';
import { OpenChannelV2 } from '../structs/OpenChannelV2.mjs';
import { FundingCreated } from '../structs/FundingCreated.mjs';
import { FundingSigned } from '../structs/FundingSigned.mjs';
import { Stfu } from '../structs/Stfu.mjs';
import { TxAddInput } from '../structs/TxAddInput.mjs';
import { TxAddOutput } from '../structs/TxAddOutput.mjs';
import { TxRemoveInput } from '../structs/TxRemoveInput.mjs';
import { TxRemoveOutput } from '../structs/TxRemoveOutput.mjs';
import { TxComplete } from '../structs/TxComplete.mjs';
import { TxSignatures } from '../structs/TxSignatures.mjs';
import { TxInitRbf } from '../structs/TxInitRbf.mjs';
import { TxAckRbf } from '../structs/TxAckRbf.mjs';
import { TxAbort } from '../structs/TxAbort.mjs';
import { ChannelReady } from '../structs/ChannelReady.mjs';
import { AnnouncementSignatures } from '../structs/AnnouncementSignatures.mjs';
import { RevokeAndACK } from '../structs/RevokeAndACK.mjs';
import { ClosingSigned } from '../structs/ClosingSigned.mjs';
import { Shutdown } from '../structs/Shutdown.mjs';
import { ChannelReestablish } from '../structs/ChannelReestablish.mjs';
import { ErrorMessage } from '../structs/ErrorMessage.mjs';
import { UpdateAddHTLC } from '../structs/UpdateAddHTLC.mjs';
import { UpdateFulfillHTLC } from '../structs/UpdateFulfillHTLC.mjs';
import { UpdateFailHTLC } from '../structs/UpdateFailHTLC.mjs';
import { UpdateFailMalformedHTLC } from '../structs/UpdateFailMalformedHTLC.mjs';
import { CommitmentSigned } from '../structs/CommitmentSigned.mjs';
import { Init } from '../structs/Init.mjs';
import { UpdateFee } from '../structs/UpdateFee.mjs';
import { MessageSendEventsProvider } from '../structs/MessageSendEventsProvider.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKChannelMessageHandlerHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different `their_node_ids`, however
 * they MUST NOT be called in parallel when the two calls have the same `their_node_id`.
 */
export class ChannelMessageHandler extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ChannelMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of ChannelMessageHandler from a given implementation */
    static new_impl(arg, messageSendEventsProvider_impl) {
        const impl_holder = new LDKChannelMessageHandlerHolder();
        let structImplementation = {
            handle_open_channel(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new OpenChannel(null, msg);
                arg.handle_open_channel(their_node_id_conv, msg_hu_conv);
            },
            handle_open_channel_v2(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new OpenChannelV2(null, msg);
                arg.handle_open_channel_v2(their_node_id_conv, msg_hu_conv);
            },
            handle_accept_channel(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new AcceptChannel(null, msg);
                arg.handle_accept_channel(their_node_id_conv, msg_hu_conv);
            },
            handle_accept_channel_v2(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new AcceptChannelV2(null, msg);
                arg.handle_accept_channel_v2(their_node_id_conv, msg_hu_conv);
            },
            handle_funding_created(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new FundingCreated(null, msg);
                arg.handle_funding_created(their_node_id_conv, msg_hu_conv);
            },
            handle_funding_signed(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new FundingSigned(null, msg);
                arg.handle_funding_signed(their_node_id_conv, msg_hu_conv);
            },
            handle_channel_ready(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new ChannelReady(null, msg);
                arg.handle_channel_ready(their_node_id_conv, msg_hu_conv);
            },
            handle_shutdown(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new Shutdown(null, msg);
                arg.handle_shutdown(their_node_id_conv, msg_hu_conv);
            },
            handle_closing_signed(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new ClosingSigned(null, msg);
                arg.handle_closing_signed(their_node_id_conv, msg_hu_conv);
            },
            handle_stfu(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new Stfu(null, msg);
                arg.handle_stfu(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_add_input(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxAddInput(null, msg);
                arg.handle_tx_add_input(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_add_output(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxAddOutput(null, msg);
                arg.handle_tx_add_output(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_remove_input(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxRemoveInput(null, msg);
                arg.handle_tx_remove_input(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_remove_output(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxRemoveOutput(null, msg);
                arg.handle_tx_remove_output(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_complete(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxComplete(null, msg);
                arg.handle_tx_complete(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_signatures(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxSignatures(null, msg);
                arg.handle_tx_signatures(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_init_rbf(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxInitRbf(null, msg);
                arg.handle_tx_init_rbf(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_ack_rbf(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxAckRbf(null, msg);
                arg.handle_tx_ack_rbf(their_node_id_conv, msg_hu_conv);
            },
            handle_tx_abort(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new TxAbort(null, msg);
                arg.handle_tx_abort(their_node_id_conv, msg_hu_conv);
            },
            handle_update_add_htlc(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new UpdateAddHTLC(null, msg);
                arg.handle_update_add_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fulfill_htlc(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new UpdateFulfillHTLC(null, msg);
                arg.handle_update_fulfill_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fail_htlc(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new UpdateFailHTLC(null, msg);
                arg.handle_update_fail_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fail_malformed_htlc(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new UpdateFailMalformedHTLC(null, msg);
                arg.handle_update_fail_malformed_htlc(their_node_id_conv, msg_hu_conv);
            },
            handle_commitment_signed(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new CommitmentSigned(null, msg);
                arg.handle_commitment_signed(their_node_id_conv, msg_hu_conv);
            },
            handle_revoke_and_ack(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new RevokeAndACK(null, msg);
                arg.handle_revoke_and_ack(their_node_id_conv, msg_hu_conv);
            },
            handle_update_fee(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new UpdateFee(null, msg);
                arg.handle_update_fee(their_node_id_conv, msg_hu_conv);
            },
            handle_announcement_signatures(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new AnnouncementSignatures(null, msg);
                arg.handle_announcement_signatures(their_node_id_conv, msg_hu_conv);
            },
            peer_disconnected(their_node_id) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                arg.peer_disconnected(their_node_id_conv);
            },
            peer_connected(their_node_id, msg, inbound) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new Init(null, msg);
                const ret = arg.peer_connected(their_node_id_conv, msg_hu_conv, inbound);
                const result = ret.clone_ptr();
                return result;
            },
            handle_channel_reestablish(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new ChannelReestablish(null, msg);
                arg.handle_channel_reestablish(their_node_id_conv, msg_hu_conv);
            },
            handle_channel_update(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new ChannelUpdate(null, msg);
                arg.handle_channel_update(their_node_id_conv, msg_hu_conv);
            },
            handle_error(their_node_id, msg) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new ErrorMessage(null, msg);
                arg.handle_error(their_node_id_conv, msg_hu_conv);
            },
            provided_node_features() {
                const ret = arg.provided_node_features();
                const result = ret.clone_ptr();
                return result;
            },
            provided_init_features(their_node_id) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const ret = arg.provided_init_features(their_node_id_conv);
                const result = ret.clone_ptr();
                return result;
            },
            get_chain_hashes() {
                const ret = arg.get_chain_hashes();
                const result = ret.clone_ptr();
                return result;
            },
        };
        const messageSendEventsProvider = MessageSendEventsProvider.new_impl(messageSendEventsProvider_impl);
        const ptr_idx = bindings.LDKChannelMessageHandler_new(structImplementation, messageSendEventsProvider.instance_idx);
        impl_holder.held = new ChannelMessageHandler(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(messageSendEventsProvider);
        return impl_holder.held;
    }
    /**
     * Handle an incoming `open_channel` message from the given peer.
     */
    handle_open_channel(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_open_channel(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `open_channel2` message from the given peer.
     */
    handle_open_channel_v2(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_open_channel_v2(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `accept_channel` message from the given peer.
     */
    handle_accept_channel(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_accept_channel(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `accept_channel2` message from the given peer.
     */
    handle_accept_channel_v2(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_accept_channel_v2(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `funding_created` message from the given peer.
     */
    handle_funding_created(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_funding_created(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `funding_signed` message from the given peer.
     */
    handle_funding_signed(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_funding_signed(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `channel_ready` message from the given peer.
     */
    handle_channel_ready(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_channel_ready(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `shutdown` message from the given peer.
     */
    handle_shutdown(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_shutdown(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `closing_signed` message from the given peer.
     */
    handle_closing_signed(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_closing_signed(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `stfu` message from the given peer.
     */
    handle_stfu(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_stfu(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_add_input message` from the given peer.
     */
    handle_tx_add_input(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_add_input(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_add_output` message from the given peer.
     */
    handle_tx_add_output(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_add_output(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_remove_input` message from the given peer.
     */
    handle_tx_remove_input(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_remove_input(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_remove_output` message from the given peer.
     */
    handle_tx_remove_output(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_remove_output(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_complete message` from the given peer.
     */
    handle_tx_complete(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_complete(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_signatures` message from the given peer.
     */
    handle_tx_signatures(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_signatures(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_init_rbf` message from the given peer.
     */
    handle_tx_init_rbf(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_init_rbf(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_ack_rbf` message from the given peer.
     */
    handle_tx_ack_rbf(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_ack_rbf(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `tx_abort message` from the given peer.
     */
    handle_tx_abort(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_tx_abort(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `update_add_htlc` message from the given peer.
     */
    handle_update_add_htlc(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_update_add_htlc(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `update_fulfill_htlc` message from the given peer.
     */
    handle_update_fulfill_htlc(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_update_fulfill_htlc(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `update_fail_htlc` message from the given peer.
     */
    handle_update_fail_htlc(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_update_fail_htlc(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `update_fail_malformed_htlc` message from the given peer.
     */
    handle_update_fail_malformed_htlc(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_update_fail_malformed_htlc(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `commitment_signed` message from the given peer.
     */
    handle_commitment_signed(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_commitment_signed(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `revoke_and_ack` message from the given peer.
     */
    handle_revoke_and_ack(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_revoke_and_ack(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `update_fee` message from the given peer.
     */
    handle_update_fee(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_update_fee(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `announcement_signatures` message from the given peer.
     */
    handle_announcement_signatures(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_announcement_signatures(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Indicates a connection to the peer failed/an existing connection was lost.
     */
    peer_disconnected(their_node_id) {
        bindings.ChannelMessageHandler_peer_disconnected(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)));
    }
    /**
     * Handle a peer reconnecting, possibly generating `channel_reestablish` message(s).
     *
     * May return an `Err(())` if the features the peer supports are not sufficient to communicate
     * with us. Implementors should be somewhat conservative about doing so, however, as other
     * message handlers may still wish to communicate with this peer.
     */
    peer_connected(their_node_id, msg, inbound) {
        const ret = bindings.ChannelMessageHandler_peer_connected(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg), inbound);
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Handle an incoming `channel_reestablish` message from the given peer.
     */
    handle_channel_reestablish(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_channel_reestablish(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `channel_update` message from the given peer.
     */
    handle_channel_update(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_channel_update(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Handle an incoming `error` message from the given peer.
     */
    handle_error(their_node_id, msg) {
        bindings.ChannelMessageHandler_handle_error(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg));
        CommonBase.add_ref_from(this, msg);
    }
    /**
     * Gets the node feature flags which this handler itself supports. All available handlers are
     * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
     * which are broadcasted in our [`NodeAnnouncement`] message.
     */
    provided_node_features() {
        const ret = bindings.ChannelMessageHandler_provided_node_features(this.ptr);
        const ret_hu_conv = new NodeFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets the init feature flags which should be sent to the given peer. All available handlers
     * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
     * which are sent in our [`Init`] message.
     *
     * Note that this method is called before [`Self::peer_connected`].
     */
    provided_init_features(their_node_id) {
        const ret = bindings.ChannelMessageHandler_provided_init_features(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)));
        const ret_hu_conv = new InitFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets the chain hashes for this `ChannelMessageHandler` indicating which chains it supports.
     *
     * If it's `None`, then no particular network chain hash compatibility will be enforced when
     * connecting to peers.
     */
    get_chain_hashes() {
        const ret = bindings.ChannelMessageHandler_get_chain_hashes(this.ptr);
        const ret_hu_conv = Option_CVec_ThirtyTwoBytesZZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=ChannelMessageHandler.mjs.map