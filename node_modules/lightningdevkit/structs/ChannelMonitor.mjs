import { SpendableOutputDescriptor } from '../structs/SpendableOutputDescriptor.mjs';
import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { Result_TransactionNoneZ } from '../structs/Result_TransactionNoneZ.mjs';
import { CommitmentTransaction } from '../structs/CommitmentTransaction.mjs';
import { BestBlock } from '../structs/BestBlock.mjs';
import { ThreeTuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ } from '../structs/ThreeTuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ.mjs';
import { ChannelId } from '../structs/ChannelId.mjs';
import { MonitorEvent } from '../structs/MonitorEvent.mjs';
import { TwoTuple_OutPointCVec_u8ZZ } from '../structs/TwoTuple_OutPointCVec_u8ZZ.mjs';
import { TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ } from '../structs/TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ.mjs';
import { Result_NoneReplayEventZ } from '../structs/Result_NoneReplayEventZ.mjs';
import { TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ } from '../structs/TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ.mjs';
import { Balance } from '../structs/Balance.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */
export class ChannelMonitor extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ChannelMonitor_free);
    }
    clone_ptr() {
        const ret = bindings.ChannelMonitor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ChannelMonitor
     */
    clone() {
        const ret = bindings.ChannelMonitor_clone(this.ptr);
        const ret_hu_conv = new ChannelMonitor(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
     */
    write() {
        const ret = bindings.ChannelMonitor_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Updates a ChannelMonitor on the basis of some new information provided by the Channel
     * itself.
     *
     * panics if the given update is not the next update by update_id.
     */
    update_monitor(updates, broadcaster, fee_estimator, logger) {
        const ret = bindings.ChannelMonitor_update_monitor(this.ptr, CommonBase.get_ptr_of(updates), CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, updates);
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
        return ret_hu_conv;
    }
    /**
     * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
     * ChannelMonitor.
     */
    get_latest_update_id() {
        const ret = bindings.ChannelMonitor_get_latest_update_id(this.ptr);
        return ret;
    }
    /**
     * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
     */
    get_funding_txo() {
        const ret = bindings.ChannelMonitor_get_funding_txo(this.ptr);
        const ret_hu_conv = new TwoTuple_OutPointCVec_u8ZZ(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets the channel_id of the channel this ChannelMonitor is monitoring for.
     */
    channel_id() {
        const ret = bindings.ChannelMonitor_channel_id(this.ptr);
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets a list of txids, with their output scripts (in the order they appear in the
     * transaction), which we must learn about spends of via block_connected().
     */
    get_outputs_to_watch() {
        const ret = bindings.ChannelMonitor_get_outputs_to_watch(this.ptr);
        const ret_conv_52_len = bindings.getArrayLength(ret);
        const ret_conv_52_arr = new Array(ret_conv_52_len).fill(null);
        for (var a = 0; a < ret_conv_52_len; a++) {
            const ret_conv_52 = bindings.getU64ArrayElem(ret, a);
            const ret_conv_52_hu_conv = new TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ(null, ret_conv_52);
            CommonBase.add_ref_from(ret_conv_52_hu_conv, this);
            ret_conv_52_arr[a] = ret_conv_52_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_52_arr;
    }
    /**
     * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
     * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
     * have been registered.
     */
    load_outputs_to_watch(filter, logger) {
        bindings.ChannelMonitor_load_outputs_to_watch(this.ptr, CommonBase.get_ptr_of(filter), CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, filter);
        CommonBase.add_ref_from(this, logger);
    }
    /**
     * Get the list of HTLCs who's status has been updated on chain. This should be called by
     * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
     */
    get_and_clear_pending_monitor_events() {
        const ret = bindings.ChannelMonitor_get_and_clear_pending_monitor_events(this.ptr);
        const ret_conv_14_len = bindings.getArrayLength(ret);
        const ret_conv_14_arr = new Array(ret_conv_14_len).fill(null);
        for (var o = 0; o < ret_conv_14_len; o++) {
            const ret_conv_14 = bindings.getU64ArrayElem(ret, o);
            const ret_conv_14_hu_conv = MonitorEvent.constr_from_ptr(ret_conv_14);
            CommonBase.add_ref_from(ret_conv_14_hu_conv, this);
            ret_conv_14_arr[o] = ret_conv_14_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_14_arr;
    }
    /**
     * Processes [`SpendableOutputs`] events produced from each [`ChannelMonitor`] upon maturity.
     *
     * For channels featuring anchor outputs, this method will also process [`BumpTransaction`]
     * events produced from each [`ChannelMonitor`] while there is a balance to claim onchain
     * within each channel. As the confirmation of a commitment transaction may be critical to the
     * safety of funds, we recommend invoking this every 30 seconds, or lower if running in an
     * environment with spotty connections, like on mobile.
     *
     * An [`EventHandler`] may safely call back to the provider, though this shouldn't be needed in
     * order to handle these events.
     *
     * Will return a [`ReplayEvent`] error if event handling failed and should eventually be retried.
     *
     * [`SpendableOutputs`]: crate::events::Event::SpendableOutputs
     * [`BumpTransaction`]: crate::events::Event::BumpTransaction
     */
    process_pending_events(handler) {
        const ret = bindings.ChannelMonitor_process_pending_events(this.ptr, CommonBase.get_ptr_of(handler));
        const ret_hu_conv = Result_NoneReplayEventZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, handler);
        return ret_hu_conv;
    }
    /**
     * Gets the counterparty's initial commitment transaction. The returned commitment
     * transaction is unsigned. This is intended to be called during the initial persistence of
     * the monitor (inside an implementation of [`Persist::persist_new_channel`]), to allow for
     * watchtowers in the persistence pipeline to have enough data to form justice transactions.
     *
     * This is similar to [`Self::counterparty_commitment_txs_from_update`], except
     * that for the initial commitment transaction, we don't have a corresponding update.
     *
     * This will only return `Some` for channel monitors that have been created after upgrading
     * to LDK 0.0.117+.
     *
     * [`Persist::persist_new_channel`]: crate::chain::chainmonitor::Persist::persist_new_channel
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    initial_counterparty_commitment_tx() {
        const ret = bindings.ChannelMonitor_initial_counterparty_commitment_tx(this.ptr);
        const ret_hu_conv = new CommitmentTransaction(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets all of the counterparty commitment transactions provided by the given update. This
     * may be empty if the update doesn't include any new counterparty commitments. Returned
     * commitment transactions are unsigned.
     *
     * This is provided so that watchtower clients in the persistence pipeline are able to build
     * justice transactions for each counterparty commitment upon each update. It's intended to be
     * used within an implementation of [`Persist::update_persisted_channel`], which is provided
     * with a monitor and an update. Once revoked, signing a justice transaction can be done using
     * [`Self::sign_to_local_justice_tx`].
     *
     * It is expected that a watchtower client may use this method to retrieve the latest counterparty
     * commitment transaction(s), and then hold the necessary data until a later update in which
     * the monitor has been updated with the corresponding revocation data, at which point the
     * monitor can sign the justice transaction.
     *
     * This will only return a non-empty list for monitor updates that have been created after
     * upgrading to LDK 0.0.117+. Note that no restriction lies on the monitors themselves, which
     * may have been created prior to upgrading.
     *
     * [`Persist::update_persisted_channel`]: crate::chain::chainmonitor::Persist::update_persisted_channel
     */
    counterparty_commitment_txs_from_update(update) {
        const ret = bindings.ChannelMonitor_counterparty_commitment_txs_from_update(this.ptr, CommonBase.get_ptr_of(update));
        const ret_conv_23_len = bindings.getArrayLength(ret);
        const ret_conv_23_arr = new Array(ret_conv_23_len).fill(null);
        for (var x = 0; x < ret_conv_23_len; x++) {
            const ret_conv_23 = bindings.getU64ArrayElem(ret, x);
            const ret_conv_23_hu_conv = new CommitmentTransaction(null, ret_conv_23);
            CommonBase.add_ref_from(ret_conv_23_hu_conv, this);
            ret_conv_23_arr[x] = ret_conv_23_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        CommonBase.add_ref_from(this, update);
        return ret_conv_23_arr;
    }
    /**
     * Wrapper around [`EcdsaChannelSigner::sign_justice_revoked_output`] to make
     * signing the justice transaction easier for implementors of
     * [`chain::chainmonitor::Persist`]. On success this method returns the provided transaction
     * signing the input at `input_idx`. This method will only produce a valid signature for
     * a transaction spending the `to_local` output of a commitment transaction, i.e. this cannot
     * be used for revoked HTLC outputs.
     *
     * `Value` is the value of the output being spent by the input at `input_idx`, committed
     * in the BIP 143 signature.
     *
     * This method will only succeed if this monitor has received the revocation secret for the
     * provided `commitment_number`. If a commitment number is provided that does not correspond
     * to the commitment transaction being revoked, this will return a signed transaction, but
     * the signature will not be valid.
     *
     * [`EcdsaChannelSigner::sign_justice_revoked_output`]: crate::sign::ecdsa::EcdsaChannelSigner::sign_justice_revoked_output
     * [`Persist`]: crate::chain::chainmonitor::Persist
     */
    sign_to_local_justice_tx(justice_tx, input_idx, value, commitment_number) {
        const ret = bindings.ChannelMonitor_sign_to_local_justice_tx(this.ptr, bindings.encodeUint8Array(justice_tx), input_idx, value, commitment_number);
        const ret_hu_conv = Result_TransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets the `node_id` of the counterparty for this channel.
     *
     * Will be `None` for channels constructed on LDK versions prior to 0.0.110 and always `Some`
     * otherwise.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    get_counterparty_node_id() {
        const ret = bindings.ChannelMonitor_get_counterparty_node_id(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * You may use this to broadcast the latest local commitment transaction, either because
     * a monitor update failed or because we've fallen behind (i.e. we've received proof that our
     * counterparty side knows a revocation secret we gave them that they shouldn't know).
     *
     * Broadcasting these transactions in this manner is UNSAFE, as they allow counterparty
     * side to punish you. Nevertheless you may want to broadcast them if counterparty doesn't
     * close channel with their commitment transaction after a substantial amount of time. Best
     * may be to contact the other node operator out-of-band to coordinate other options available
     * to you.
     */
    broadcast_latest_holder_commitment_txn(broadcaster, fee_estimator, logger) {
        bindings.ChannelMonitor_broadcast_latest_holder_commitment_txn(this.ptr, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
    }
    /**
     * Processes transactions in a newly connected block, which may result in any of the following:
     * - update the monitor's state against resolved HTLCs
     * - punish the counterparty in the case of seeing a revoked commitment transaction
     * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
     * - detect settled outputs for later spending
     * - schedule and bump any in-flight claims
     *
     * Returns any new outputs to watch from `txdata`; after called, these are also included in
     * [`get_outputs_to_watch`].
     *
     * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
     */
    block_connected(header, txdata, height, broadcaster, fee_estimator, logger) {
        const ret = bindings.ChannelMonitor_block_connected(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(header, 80)), bindings.encodeUint64Array(txdata.map(txdata_conv_28 => CommonBase.get_ptr_of(txdata_conv_28))), height, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        const ret_conv_49_len = bindings.getArrayLength(ret);
        const ret_conv_49_arr = new Array(ret_conv_49_len).fill(null);
        for (var x = 0; x < ret_conv_49_len; x++) {
            const ret_conv_49 = bindings.getU64ArrayElem(ret, x);
            const ret_conv_49_hu_conv = new TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ(null, ret_conv_49);
            CommonBase.add_ref_from(ret_conv_49_hu_conv, this);
            ret_conv_49_arr[x] = ret_conv_49_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
        return ret_conv_49_arr;
    }
    /**
     * Determines if the disconnected block contained any transactions of interest and updates
     * appropriately.
     */
    block_disconnected(header, height, broadcaster, fee_estimator, logger) {
        bindings.ChannelMonitor_block_disconnected(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(header, 80)), height, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
    }
    /**
     * Processes transactions confirmed in a block with the given header and height, returning new
     * outputs to watch. See [`block_connected`] for details.
     *
     * Used instead of [`block_connected`] by clients that are notified of transactions rather than
     * blocks. See [`chain::Confirm`] for calling expectations.
     *
     * [`block_connected`]: Self::block_connected
     */
    transactions_confirmed(header, txdata, height, broadcaster, fee_estimator, logger) {
        const ret = bindings.ChannelMonitor_transactions_confirmed(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(header, 80)), bindings.encodeUint64Array(txdata.map(txdata_conv_28 => CommonBase.get_ptr_of(txdata_conv_28))), height, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        const ret_conv_49_len = bindings.getArrayLength(ret);
        const ret_conv_49_arr = new Array(ret_conv_49_len).fill(null);
        for (var x = 0; x < ret_conv_49_len; x++) {
            const ret_conv_49 = bindings.getU64ArrayElem(ret, x);
            const ret_conv_49_hu_conv = new TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ(null, ret_conv_49);
            CommonBase.add_ref_from(ret_conv_49_hu_conv, this);
            ret_conv_49_arr[x] = ret_conv_49_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
        return ret_conv_49_arr;
    }
    /**
     * Processes a transaction that was reorganized out of the chain.
     *
     * Used instead of [`block_disconnected`] by clients that are notified of transactions rather
     * than blocks. See [`chain::Confirm`] for calling expectations.
     *
     * [`block_disconnected`]: Self::block_disconnected
     */
    transaction_unconfirmed(txid, broadcaster, fee_estimator, logger) {
        bindings.ChannelMonitor_transaction_unconfirmed(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(txid, 32)), CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
    }
    /**
     * Updates the monitor with the current best chain tip, returning new outputs to watch. See
     * [`block_connected`] for details.
     *
     * Used instead of [`block_connected`] by clients that are notified of transactions rather than
     * blocks. See [`chain::Confirm`] for calling expectations.
     *
     * [`block_connected`]: Self::block_connected
     */
    best_block_updated(header, height, broadcaster, fee_estimator, logger) {
        const ret = bindings.ChannelMonitor_best_block_updated(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(header, 80)), height, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        const ret_conv_49_len = bindings.getArrayLength(ret);
        const ret_conv_49_arr = new Array(ret_conv_49_len).fill(null);
        for (var x = 0; x < ret_conv_49_len; x++) {
            const ret_conv_49 = bindings.getU64ArrayElem(ret, x);
            const ret_conv_49_hu_conv = new TwoTuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ(null, ret_conv_49);
            CommonBase.add_ref_from(ret_conv_49_hu_conv, this);
            ret_conv_49_arr[x] = ret_conv_49_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
        return ret_conv_49_arr;
    }
    /**
     * Returns the set of txids that should be monitored for re-organization out of the chain.
     */
    get_relevant_txids() {
        const ret = bindings.ChannelMonitor_get_relevant_txids(this.ptr);
        const ret_conv_54_len = bindings.getArrayLength(ret);
        const ret_conv_54_arr = new Array(ret_conv_54_len).fill(null);
        for (var c = 0; c < ret_conv_54_len; c++) {
            const ret_conv_54 = bindings.getU64ArrayElem(ret, c);
            const ret_conv_54_hu_conv = new ThreeTuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ(null, ret_conv_54);
            CommonBase.add_ref_from(ret_conv_54_hu_conv, this);
            ret_conv_54_arr[c] = ret_conv_54_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_54_arr;
    }
    /**
     * Gets the latest best block which was connected either via the [`chain::Listen`] or
     * [`chain::Confirm`] interfaces.
     */
    current_best_block() {
        const ret = bindings.ChannelMonitor_current_best_block(this.ptr);
        const ret_hu_conv = new BestBlock(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Triggers rebroadcasts/fee-bumps of pending claims from a force-closed channel. This is
     * crucial in preventing certain classes of pinning attacks, detecting substantial mempool
     * feerate changes between blocks, and ensuring reliability if broadcasting fails. We recommend
     * invoking this every 30 seconds, or lower if running in an environment with spotty
     * connections, like on mobile.
     */
    rebroadcast_pending_claims(broadcaster, fee_estimator, logger) {
        bindings.ChannelMonitor_rebroadcast_pending_claims(this.ptr, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
    }
    /**
     * Returns true if the monitor has pending claim requests that are not fully confirmed yet.
     */
    has_pending_claims() {
        const ret = bindings.ChannelMonitor_has_pending_claims(this.ptr);
        return ret;
    }
    /**
     * Triggers rebroadcasts of pending claims from a force-closed channel after a transaction
     * signature generation failure.
     */
    signer_unblocked(broadcaster, fee_estimator, logger) {
        bindings.ChannelMonitor_signer_unblocked(this.ptr, CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, broadcaster);
        CommonBase.add_ref_from(this, fee_estimator);
        CommonBase.add_ref_from(this, logger);
    }
    /**
     * Returns the descriptors for relevant outputs (i.e., those that we can spend) within the
     * transaction if they exist and the transaction has at least [`ANTI_REORG_DELAY`]
     * confirmations. For [`SpendableOutputDescriptor::DelayedPaymentOutput`] descriptors to be
     * returned, the transaction must have at least `max(ANTI_REORG_DELAY, to_self_delay)`
     * confirmations.
     *
     * Descriptors returned by this method are primarily exposed via [`Event::SpendableOutputs`]
     * once they are no longer under reorg risk. This method serves as a way to retrieve these
     * descriptors at a later time, either for historical purposes, or to replay any
     * missed/unhandled descriptors. For the purpose of gathering historical records, if the
     * channel close has fully resolved (i.e., [`ChannelMonitor::get_claimable_balances`] returns
     * an empty set), you can retrieve all spendable outputs by providing all descendant spending
     * transactions starting from the channel's funding transaction and going down three levels.
     *
     * `tx` is a transaction we'll scan the outputs of. Any transaction can be provided. If any
     * outputs which can be spent by us are found, at least one descriptor is returned.
     *
     * `confirmation_height` must be the height of the block in which `tx` was included in.
     */
    get_spendable_outputs(tx, confirmation_height) {
        const ret = bindings.ChannelMonitor_get_spendable_outputs(this.ptr, bindings.encodeUint8Array(tx), confirmation_height);
        const ret_conv_27_len = bindings.getArrayLength(ret);
        const ret_conv_27_arr = new Array(ret_conv_27_len).fill(null);
        for (var b = 0; b < ret_conv_27_len; b++) {
            const ret_conv_27 = bindings.getU64ArrayElem(ret, b);
            const ret_conv_27_hu_conv = SpendableOutputDescriptor.constr_from_ptr(ret_conv_27);
            CommonBase.add_ref_from(ret_conv_27_hu_conv, this);
            ret_conv_27_arr[b] = ret_conv_27_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_27_arr;
    }
    /**
     * Checks if the monitor is fully resolved. Resolved monitor is one that has claimed all of
     * its outputs and balances (i.e. [`Self::get_claimable_balances`] returns an empty set).
     *
     * This function returns true only if [`Self::get_claimable_balances`] has been empty for at least
     * 4032 blocks as an additional protection against any bugs resulting in spuriously empty balance sets.
     */
    is_fully_resolved(logger) {
        const ret = bindings.ChannelMonitor_is_fully_resolved(this.ptr, CommonBase.get_ptr_of(logger));
        CommonBase.add_ref_from(this, logger);
        return ret;
    }
    /**
     * Gets the balances in this channel which are either claimable by us if we were to
     * force-close the channel now or which are claimable on-chain (possibly awaiting
     * confirmation).
     *
     * Any balances in the channel which are available on-chain (excluding on-chain fees) are
     * included here until an [`Event::SpendableOutputs`] event has been generated for the
     * balance, or until our counterparty has claimed the balance and accrued several
     * confirmations on the claim transaction.
     *
     * Note that for `ChannelMonitors` which track a channel which went on-chain with versions of
     * LDK prior to 0.0.111, not all or excess balances may be included.
     *
     * See [`Balance`] for additional details on the types of claimable balances which
     * may be returned here and their meanings.
     */
    get_claimable_balances() {
        const ret = bindings.ChannelMonitor_get_claimable_balances(this.ptr);
        const ret_conv_9_len = bindings.getArrayLength(ret);
        const ret_conv_9_arr = new Array(ret_conv_9_len).fill(null);
        for (var j = 0; j < ret_conv_9_len; j++) {
            const ret_conv_9 = bindings.getU64ArrayElem(ret, j);
            const ret_conv_9_hu_conv = Balance.constr_from_ptr(ret_conv_9);
            CommonBase.add_ref_from(ret_conv_9_hu_conv, this);
            ret_conv_9_arr[j] = ret_conv_9_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_9_arr;
    }
}
//# sourceMappingURL=ChannelMonitor.mjs.map