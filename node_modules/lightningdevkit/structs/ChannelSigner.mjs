import { Result_PublicKeyNoneZ } from '../structs/Result_PublicKeyNoneZ.mjs';
import { Result__u832NoneZ } from '../structs/Result__u832NoneZ.mjs';
import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { HolderCommitmentTransaction } from '../structs/HolderCommitmentTransaction.mjs';
import { ChannelPublicKeys } from '../structs/ChannelPublicKeys.mjs';
import { ChannelTransactionParameters } from '../structs/ChannelTransactionParameters.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKChannelSignerHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait to handle Lightning channel key material without concretizing the channel type or
 * the signature mechanism.
 *
 * Several methods allow error types to be returned to support async signing. This feature
 * is not yet complete, and panics may occur in certain situations when returning errors
 * for these methods.
 */
export class ChannelSigner extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ChannelSigner_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of ChannelSigner from a given implementation */
    static new_impl(arg, pubkeys) {
        const impl_holder = new LDKChannelSignerHolder();
        let structImplementation = {
            get_per_commitment_point(idx) {
                const ret = arg.get_per_commitment_point(idx);
                const result = ret.clone_ptr();
                return result;
            },
            release_commitment_secret(idx) {
                const ret = arg.release_commitment_secret(idx);
                const result = ret.clone_ptr();
                return result;
            },
            validate_holder_commitment(holder_tx, outbound_htlc_preimages) {
                const holder_tx_hu_conv = new HolderCommitmentTransaction(null, holder_tx);
                const outbound_htlc_preimages_conv_12_len = bindings.getArrayLength(outbound_htlc_preimages);
                const outbound_htlc_preimages_conv_12_arr = new Array(outbound_htlc_preimages_conv_12_len).fill(null);
                for (var m = 0; m < outbound_htlc_preimages_conv_12_len; m++) {
                    const outbound_htlc_preimages_conv_12 = bindings.getU32ArrayElem(outbound_htlc_preimages, m);
                    const outbound_htlc_preimages_conv_12_conv = bindings.decodeUint8Array(outbound_htlc_preimages_conv_12);
                    outbound_htlc_preimages_conv_12_arr[m] = outbound_htlc_preimages_conv_12_conv;
                }
                bindings.freeWasmMemory(outbound_htlc_preimages);
                const ret = arg.validate_holder_commitment(holder_tx_hu_conv, outbound_htlc_preimages_conv_12_arr);
                const result = ret.clone_ptr();
                return result;
            },
            validate_counterparty_revocation(idx, secret) {
                const secret_conv = bindings.decodeUint8Array(secret);
                const ret = arg.validate_counterparty_revocation(idx, secret_conv);
                const result = ret.clone_ptr();
                return result;
            },
            channel_keys_id() {
                const ret = arg.channel_keys_id();
                const result = bindings.encodeUint8Array(bindings.check_arr_len(ret, 32));
                return result;
            },
            provide_channel_parameters(channel_parameters) {
                const channel_parameters_hu_conv = new ChannelTransactionParameters(null, channel_parameters);
                arg.provide_channel_parameters(channel_parameters_hu_conv);
            },
        };
        const ptr_idx = bindings.LDKChannelSigner_new(structImplementation, pubkeys.clone_ptr());
        impl_holder.held = new ChannelSigner(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Gets the per-commitment point for a specific commitment number
     *
     * Note that the commitment number starts at `(1 << 48) - 1` and counts backwards.
     *
     * If the signer returns `Err`, then the user is responsible for either force-closing the channel
     * or calling `ChannelManager::signer_unblocked` (this method is only available when the
     * `async_signing` cfg flag is enabled) once the signature is ready.
     */
    get_per_commitment_point(idx) {
        const ret = bindings.ChannelSigner_get_per_commitment_point(this.ptr, idx);
        const ret_hu_conv = Result_PublicKeyNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets the commitment secret for a specific commitment number as part of the revocation process
     *
     * An external signer implementation should error here if the commitment was already signed
     * and should refuse to sign it in the future.
     *
     * May be called more than once for the same index.
     *
     * Note that the commitment number starts at `(1 << 48) - 1` and counts backwards.
     */
    release_commitment_secret(idx) {
        const ret = bindings.ChannelSigner_release_commitment_secret(this.ptr, idx);
        const ret_hu_conv = Result__u832NoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Validate the counterparty's signatures on the holder commitment transaction and HTLCs.
     *
     * This is required in order for the signer to make sure that releasing a commitment
     * secret won't leave us without a broadcastable holder transaction.
     * Policy checks should be implemented in this function, including checking the amount
     * sent to us and checking the HTLCs.
     *
     * The preimages of outbound HTLCs that were fulfilled since the last commitment are provided.
     * A validating signer should ensure that an HTLC output is removed only when the matching
     * preimage is provided, or when the value to holder is restored.
     *
     * Note that all the relevant preimages will be provided, but there may also be additional
     * irrelevant or duplicate preimages.
     */
    validate_holder_commitment(holder_tx, outbound_htlc_preimages) {
        const ret = bindings.ChannelSigner_validate_holder_commitment(this.ptr, CommonBase.get_ptr_of(holder_tx), bindings.encodeUint32Array(outbound_htlc_preimages.map(outbound_htlc_preimages_conv_12 => bindings.encodeUint8Array(bindings.check_arr_len(outbound_htlc_preimages_conv_12, 32)))));
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, holder_tx);
        return ret_hu_conv;
    }
    /**
     * Validate the counterparty's revocation.
     *
     * This is required in order for the signer to make sure that the state has moved
     * forward and it is safe to sign the next counterparty commitment.
     */
    validate_counterparty_revocation(idx, secret) {
        const ret = bindings.ChannelSigner_validate_counterparty_revocation(this.ptr, idx, bindings.encodeUint8Array(bindings.check_arr_len(secret, 32)));
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns an arbitrary identifier describing the set of keys which are provided back to you in
     * some [`SpendableOutputDescriptor`] types. This should be sufficient to identify this
     * [`EcdsaChannelSigner`] object uniquely and lookup or re-derive its keys.
     */
    channel_keys_id() {
        const ret = bindings.ChannelSigner_channel_keys_id(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Set the counterparty static channel data, including basepoints,
     * `counterparty_selected`/`holder_selected_contest_delay` and funding outpoint.
     *
     * This data is static, and will never change for a channel once set. For a given [`ChannelSigner`]
     * instance, LDK will call this method exactly once - either immediately after construction
     * (not including if done via [`SignerProvider::read_chan_signer`]) or when the funding
     * information has been generated.
     *
     * channel_parameters.is_populated() MUST be true.
     */
    provide_channel_parameters(channel_parameters) {
        bindings.ChannelSigner_provide_channel_parameters(this.ptr, CommonBase.get_ptr_of(channel_parameters));
        CommonBase.add_ref_from(this, channel_parameters);
    }
    /**
     * Frees any resources associated with this object given its this_arg pointer.
     * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
     */
    get_pubkeys() {
        const ret = bindings.ChannelSigner_get_pubkeys(this.ptr);
        const ret_hu_conv = new ChannelPublicKeys(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=ChannelSigner.mjs.map