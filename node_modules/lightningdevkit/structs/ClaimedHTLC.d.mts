import { ChannelId } from '../structs/ChannelId.mjs';
import { Result_ClaimedHTLCDecodeErrorZ } from '../structs/Result_ClaimedHTLCDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * Information about an HTLC that is part of a payment that can be claimed.
 */
export declare class ClaimedHTLC extends CommonBase {
    /**
     * The `channel_id` of the channel over which the HTLC was received.
     */
    get_channel_id(): ChannelId;
    /**
     * The `channel_id` of the channel over which the HTLC was received.
     */
    set_channel_id(val: ChannelId): void;
    /**
     * The `user_channel_id` of the channel over which the HTLC was received. This is the value
     * passed in to [`ChannelManager::create_channel`] for outbound channels, or to
     * [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.
     *
     * This field will be zero for a payment that was serialized prior to LDK version 0.0.117. (This
     * should only happen in the case that a payment was claimable prior to LDK version 0.0.117, but
     * was not actually claimed until after upgrading.)
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    get_user_channel_id(): bigint;
    /**
     * The `user_channel_id` of the channel over which the HTLC was received. This is the value
     * passed in to [`ChannelManager::create_channel`] for outbound channels, or to
     * [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.
     *
     * This field will be zero for a payment that was serialized prior to LDK version 0.0.117. (This
     * should only happen in the case that a payment was claimable prior to LDK version 0.0.117, but
     * was not actually claimed until after upgrading.)
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    set_user_channel_id(val: bigint): void;
    /**
     * The block height at which this HTLC expires.
     */
    get_cltv_expiry(): number;
    /**
     * The block height at which this HTLC expires.
     */
    set_cltv_expiry(val: number): void;
    /**
     * The amount (in msats) of this part of an MPP.
     */
    get_value_msat(): bigint;
    /**
     * The amount (in msats) of this part of an MPP.
     */
    set_value_msat(val: bigint): void;
    /**
     * The extra fee our counterparty skimmed off the top of this HTLC, if any.
     *
     * This value will always be 0 for [`ClaimedHTLC`]s serialized with LDK versions prior to
     * 0.0.119.
     */
    get_counterparty_skimmed_fee_msat(): bigint;
    /**
     * The extra fee our counterparty skimmed off the top of this HTLC, if any.
     *
     * This value will always be 0 for [`ClaimedHTLC`]s serialized with LDK versions prior to
     * 0.0.119.
     */
    set_counterparty_skimmed_fee_msat(val: bigint): void;
    /**
     * Constructs a new ClaimedHTLC given each field
     */
    static constructor_new(channel_id_arg: ChannelId, user_channel_id_arg: bigint, cltv_expiry_arg: number, value_msat_arg: bigint, counterparty_skimmed_fee_msat_arg: bigint): ClaimedHTLC;
    clone_ptr(): bigint;
    /**
     * Creates a copy of the ClaimedHTLC
     */
    clone(): ClaimedHTLC;
    /**
     * Checks if two ClaimedHTLCs contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b: ClaimedHTLC): boolean;
    /**
     * Serialize the ClaimedHTLC object into a byte array which can be read by ClaimedHTLC_read
     */
    write(): Uint8Array;
    /**
     * Read a ClaimedHTLC from a byte array, created by ClaimedHTLC_write
     */
    static constructor_read(ser: Uint8Array): Result_ClaimedHTLCDecodeErrorZ;
}
