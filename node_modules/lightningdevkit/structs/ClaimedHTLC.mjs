import { ChannelId } from '../structs/ChannelId.mjs';
import { Result_ClaimedHTLCDecodeErrorZ } from '../structs/Result_ClaimedHTLCDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Information about an HTLC that is part of a payment that can be claimed.
 */
export class ClaimedHTLC extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ClaimedHTLC_free);
    }
    /**
     * The `channel_id` of the channel over which the HTLC was received.
     */
    get_channel_id() {
        const ret = bindings.ClaimedHTLC_get_channel_id(this.ptr);
        const ret_hu_conv = new ChannelId(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The `channel_id` of the channel over which the HTLC was received.
     */
    set_channel_id(val) {
        bindings.ClaimedHTLC_set_channel_id(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The `user_channel_id` of the channel over which the HTLC was received. This is the value
     * passed in to [`ChannelManager::create_channel`] for outbound channels, or to
     * [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.
     *
     * This field will be zero for a payment that was serialized prior to LDK version 0.0.117. (This
     * should only happen in the case that a payment was claimable prior to LDK version 0.0.117, but
     * was not actually claimed until after upgrading.)
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    get_user_channel_id() {
        const ret = bindings.ClaimedHTLC_get_user_channel_id(this.ptr);
        const ret_conv = bindings.decodeUint128(ret);
        return ret_conv;
    }
    /**
     * The `user_channel_id` of the channel over which the HTLC was received. This is the value
     * passed in to [`ChannelManager::create_channel`] for outbound channels, or to
     * [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.
     *
     * This field will be zero for a payment that was serialized prior to LDK version 0.0.117. (This
     * should only happen in the case that a payment was claimable prior to LDK version 0.0.117, but
     * was not actually claimed until after upgrading.)
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    set_user_channel_id(val) {
        bindings.ClaimedHTLC_set_user_channel_id(this.ptr, bindings.encodeUint128(val));
    }
    /**
     * The block height at which this HTLC expires.
     */
    get_cltv_expiry() {
        const ret = bindings.ClaimedHTLC_get_cltv_expiry(this.ptr);
        return ret;
    }
    /**
     * The block height at which this HTLC expires.
     */
    set_cltv_expiry(val) {
        bindings.ClaimedHTLC_set_cltv_expiry(this.ptr, val);
    }
    /**
     * The amount (in msats) of this part of an MPP.
     */
    get_value_msat() {
        const ret = bindings.ClaimedHTLC_get_value_msat(this.ptr);
        return ret;
    }
    /**
     * The amount (in msats) of this part of an MPP.
     */
    set_value_msat(val) {
        bindings.ClaimedHTLC_set_value_msat(this.ptr, val);
    }
    /**
     * The extra fee our counterparty skimmed off the top of this HTLC, if any.
     *
     * This value will always be 0 for [`ClaimedHTLC`]s serialized with LDK versions prior to
     * 0.0.119.
     */
    get_counterparty_skimmed_fee_msat() {
        const ret = bindings.ClaimedHTLC_get_counterparty_skimmed_fee_msat(this.ptr);
        return ret;
    }
    /**
     * The extra fee our counterparty skimmed off the top of this HTLC, if any.
     *
     * This value will always be 0 for [`ClaimedHTLC`]s serialized with LDK versions prior to
     * 0.0.119.
     */
    set_counterparty_skimmed_fee_msat(val) {
        bindings.ClaimedHTLC_set_counterparty_skimmed_fee_msat(this.ptr, val);
    }
    /**
     * Constructs a new ClaimedHTLC given each field
     */
    static constructor_new(channel_id_arg, user_channel_id_arg, cltv_expiry_arg, value_msat_arg, counterparty_skimmed_fee_msat_arg) {
        const ret = bindings.ClaimedHTLC_new(CommonBase.get_ptr_of(channel_id_arg), bindings.encodeUint128(user_channel_id_arg), cltv_expiry_arg, value_msat_arg, counterparty_skimmed_fee_msat_arg);
        const ret_hu_conv = new ClaimedHTLC(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.ClaimedHTLC_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the ClaimedHTLC
     */
    clone() {
        const ret = bindings.ClaimedHTLC_clone(this.ptr);
        const ret_hu_conv = new ClaimedHTLC(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two ClaimedHTLCs contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.ClaimedHTLC_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the ClaimedHTLC object into a byte array which can be read by ClaimedHTLC_read
     */
    write() {
        const ret = bindings.ClaimedHTLC_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a ClaimedHTLC from a byte array, created by ClaimedHTLC_write
     */
    static constructor_read(ser) {
        const ret = bindings.ClaimedHTLC_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_ClaimedHTLCDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=ClaimedHTLC.mjs.map