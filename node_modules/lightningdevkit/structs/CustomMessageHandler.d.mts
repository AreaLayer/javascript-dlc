import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { InitFeatures } from '../structs/InitFeatures.mjs';
import { NodeFeatures } from '../structs/NodeFeatures.mjs';
import { Result_NoneLightningErrorZ } from '../structs/Result_NoneLightningErrorZ.mjs';
import { Type } from '../structs/Type.mjs';
import { TwoTuple_PublicKeyTypeZ } from '../structs/TwoTuple_PublicKeyTypeZ.mjs';
import { Init } from '../structs/Init.mjs';
import { CustomMessageReaderInterface } from '../structs/CustomMessageReader.mjs';
import { CommonBase } from './CommonBase.mjs';
/** An implementation of CustomMessageHandler */
export interface CustomMessageHandlerInterface {
    /**Handles the given message sent from `sender_node_id`, possibly producing messages for
     * [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
     * to send.
     */
    handle_custom_message(msg: Type, sender_node_id: Uint8Array): Result_NoneLightningErrorZ;
    /**Returns the list of pending messages that were generated by the handler, clearing the list
     * in the process. Each message is paired with the node id of the intended recipient. If no
     * connection to the node exists, then the message is simply not sent.
     */
    get_and_clear_pending_msg(): TwoTuple_PublicKeyTypeZ[];
    /**Indicates a peer disconnected.
     */
    peer_disconnected(their_node_id: Uint8Array): void;
    /**Handle a peer connecting.
     *
     * May return an `Err(())` if the features the peer supports are not sufficient to communicate
     * with us. Implementors should be somewhat conservative about doing so, however, as other
     * message handlers may still wish to communicate with this peer.
     */
    peer_connected(their_node_id: Uint8Array, msg: Init, inbound: boolean): Result_NoneNoneZ;
    /**Gets the node feature flags which this handler itself supports. All available handlers are
     * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
     * which are broadcasted in our [`NodeAnnouncement`] message.
     *
     * [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
     */
    provided_node_features(): NodeFeatures;
    /**Gets the init feature flags which should be sent to the given peer. All available handlers
     * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
     * which are sent in our [`Init`] message.
     *
     * [`Init`]: crate::ln::msgs::Init
     */
    provided_init_features(their_node_id: Uint8Array): InitFeatures;
}
/**
 * A handler provided to [`PeerManager`] for reading and handling custom messages.
 *
 * [BOLT 1] specifies a custom message type range for use with experimental or application-specific
 * messages. `CustomMessageHandler` allows for user-defined handling of such types. See the
 * [`lightning_custom_message`] crate for tools useful in composing more than one custom handler.
 *
 * [BOLT 1]: https://github.com/lightning/bolts/blob/master/01-messaging.md
 * [`lightning_custom_message`]: https://docs.rs/lightning_custom_message/latest/lightning_custom_message
 */
export declare class CustomMessageHandler extends CommonBase {
    /** Creates a new instance of CustomMessageHandler from a given implementation */
    static new_impl(arg: CustomMessageHandlerInterface, customMessageReader_impl: CustomMessageReaderInterface): CustomMessageHandler;
    /**
     * Handles the given message sent from `sender_node_id`, possibly producing messages for
     * [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
     * to send.
     */
    handle_custom_message(msg: Type, sender_node_id: Uint8Array): Result_NoneLightningErrorZ;
    /**
     * Returns the list of pending messages that were generated by the handler, clearing the list
     * in the process. Each message is paired with the node id of the intended recipient. If no
     * connection to the node exists, then the message is simply not sent.
     */
    get_and_clear_pending_msg(): TwoTuple_PublicKeyTypeZ[];
    /**
     * Indicates a peer disconnected.
     */
    peer_disconnected(their_node_id: Uint8Array): void;
    /**
     * Handle a peer connecting.
     *
     * May return an `Err(())` if the features the peer supports are not sufficient to communicate
     * with us. Implementors should be somewhat conservative about doing so, however, as other
     * message handlers may still wish to communicate with this peer.
     */
    peer_connected(their_node_id: Uint8Array, msg: Init, inbound: boolean): Result_NoneNoneZ;
    /**
     * Gets the node feature flags which this handler itself supports. All available handlers are
     * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
     * which are broadcasted in our [`NodeAnnouncement`] message.
     *
     * [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
     */
    provided_node_features(): NodeFeatures;
    /**
     * Gets the init feature flags which should be sent to the given peer. All available handlers
     * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
     * which are sent in our [`Init`] message.
     *
     * [`Init`]: crate::ln::msgs::Init
     */
    provided_init_features(their_node_id: Uint8Array): InitFeatures;
}
