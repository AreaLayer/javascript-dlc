import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { InitFeatures } from '../structs/InitFeatures.mjs';
import { NodeFeatures } from '../structs/NodeFeatures.mjs';
import { Result_NoneLightningErrorZ } from '../structs/Result_NoneLightningErrorZ.mjs';
import { Type } from '../structs/Type.mjs';
import { TwoTuple_PublicKeyTypeZ } from '../structs/TwoTuple_PublicKeyTypeZ.mjs';
import { Init } from '../structs/Init.mjs';
import { CustomMessageReader } from '../structs/CustomMessageReader.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKCustomMessageHandlerHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A handler provided to [`PeerManager`] for reading and handling custom messages.
 *
 * [BOLT 1] specifies a custom message type range for use with experimental or application-specific
 * messages. `CustomMessageHandler` allows for user-defined handling of such types. See the
 * [`lightning_custom_message`] crate for tools useful in composing more than one custom handler.
 *
 * [BOLT 1]: https://github.com/lightning/bolts/blob/master/01-messaging.md
 * [`lightning_custom_message`]: https://docs.rs/lightning_custom_message/latest/lightning_custom_message
 */
export class CustomMessageHandler extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.CustomMessageHandler_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of CustomMessageHandler from a given implementation */
    static new_impl(arg, customMessageReader_impl) {
        const impl_holder = new LDKCustomMessageHandlerHolder();
        let structImplementation = {
            handle_custom_message(msg, sender_node_id) {
                const ret_hu_conv = new Type(null, msg);
                CommonBase.add_ref_from(ret_hu_conv, this);
                const sender_node_id_conv = bindings.decodeUint8Array(sender_node_id);
                const ret = arg.handle_custom_message(ret_hu_conv, sender_node_id_conv);
                const result = ret.clone_ptr();
                return result;
            },
            get_and_clear_pending_msg() {
                const ret = arg.get_and_clear_pending_msg();
                const result = bindings.encodeUint64Array(ret.map(ret_conv_25 => ret_conv_25.clone_ptr()));
                return result;
            },
            peer_disconnected(their_node_id) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                arg.peer_disconnected(their_node_id_conv);
            },
            peer_connected(their_node_id, msg, inbound) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const msg_hu_conv = new Init(null, msg);
                const ret = arg.peer_connected(their_node_id_conv, msg_hu_conv, inbound);
                const result = ret.clone_ptr();
                return result;
            },
            provided_node_features() {
                const ret = arg.provided_node_features();
                const result = ret.clone_ptr();
                return result;
            },
            provided_init_features(their_node_id) {
                const their_node_id_conv = bindings.decodeUint8Array(their_node_id);
                const ret = arg.provided_init_features(their_node_id_conv);
                const result = ret.clone_ptr();
                return result;
            },
        };
        const customMessageReader = CustomMessageReader.new_impl(customMessageReader_impl);
        const ptr_idx = bindings.LDKCustomMessageHandler_new(structImplementation, customMessageReader.instance_idx);
        impl_holder.held = new CustomMessageHandler(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(customMessageReader);
        return impl_holder.held;
    }
    /**
     * Handles the given message sent from `sender_node_id`, possibly producing messages for
     * [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
     * to send.
     */
    handle_custom_message(msg, sender_node_id) {
        const ret = bindings.CustomMessageHandler_handle_custom_message(this.ptr, CommonBase.get_ptr_of(msg), bindings.encodeUint8Array(bindings.check_arr_len(sender_node_id, 33)));
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Returns the list of pending messages that were generated by the handler, clearing the list
     * in the process. Each message is paired with the node id of the intended recipient. If no
     * connection to the node exists, then the message is simply not sent.
     */
    get_and_clear_pending_msg() {
        const ret = bindings.CustomMessageHandler_get_and_clear_pending_msg(this.ptr);
        const ret_conv_25_len = bindings.getArrayLength(ret);
        const ret_conv_25_arr = new Array(ret_conv_25_len).fill(null);
        for (var z = 0; z < ret_conv_25_len; z++) {
            const ret_conv_25 = bindings.getU64ArrayElem(ret, z);
            const ret_conv_25_hu_conv = new TwoTuple_PublicKeyTypeZ(null, ret_conv_25);
            CommonBase.add_ref_from(ret_conv_25_hu_conv, this);
            ret_conv_25_arr[z] = ret_conv_25_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_25_arr;
    }
    /**
     * Indicates a peer disconnected.
     */
    peer_disconnected(their_node_id) {
        bindings.CustomMessageHandler_peer_disconnected(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)));
    }
    /**
     * Handle a peer connecting.
     *
     * May return an `Err(())` if the features the peer supports are not sufficient to communicate
     * with us. Implementors should be somewhat conservative about doing so, however, as other
     * message handlers may still wish to communicate with this peer.
     */
    peer_connected(their_node_id, msg, inbound) {
        const ret = bindings.CustomMessageHandler_peer_connected(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)), CommonBase.get_ptr_of(msg), inbound);
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    /**
     * Gets the node feature flags which this handler itself supports. All available handlers are
     * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
     * which are broadcasted in our [`NodeAnnouncement`] message.
     *
     * [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
     */
    provided_node_features() {
        const ret = bindings.CustomMessageHandler_provided_node_features(this.ptr);
        const ret_hu_conv = new NodeFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Gets the init feature flags which should be sent to the given peer. All available handlers
     * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
     * which are sent in our [`Init`] message.
     *
     * [`Init`]: crate::ln::msgs::Init
     */
    provided_init_features(their_node_id) {
        const ret = bindings.CustomMessageHandler_provided_init_features(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(their_node_id, 33)));
        const ret_hu_conv = new InitFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=CustomMessageHandler.mjs.map