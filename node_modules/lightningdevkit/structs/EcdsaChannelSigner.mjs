import { HTLCDescriptor } from '../structs/HTLCDescriptor.mjs';
import { Result_ECDSASignatureNoneZ } from '../structs/Result_ECDSASignatureNoneZ.mjs';
import { Result_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ } from '../structs/Result_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ.mjs';
import { CommitmentTransaction } from '../structs/CommitmentTransaction.mjs';
import { HolderCommitmentTransaction } from '../structs/HolderCommitmentTransaction.mjs';
import { HTLCOutputInCommitment } from '../structs/HTLCOutputInCommitment.mjs';
import { ClosingTransaction } from '../structs/ClosingTransaction.mjs';
import { UnsignedChannelAnnouncement } from '../structs/UnsignedChannelAnnouncement.mjs';
import { ChannelSigner } from '../structs/ChannelSigner.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKEcdsaChannelSignerHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait to sign Lightning channel transactions as described in
 * [BOLT 3](https://github.com/lightning/bolts/blob/master/03-transactions.md).
 *
 * Signing services could be implemented on a hardware wallet and should implement signing
 * policies in order to be secure. Please refer to the [VLS Policy
 * Controls](https://gitlab.com/lightning-signer/validating-lightning-signer/-/blob/main/docs/policy-controls.md)
 * for an example of such policies.
 */
export class EcdsaChannelSigner extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.EcdsaChannelSigner_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of EcdsaChannelSigner from a given implementation */
    static new_impl(arg, channelSigner_impl, pubkeys) {
        const impl_holder = new LDKEcdsaChannelSignerHolder();
        let structImplementation = {
            sign_counterparty_commitment(commitment_tx, inbound_htlc_preimages, outbound_htlc_preimages) {
                const commitment_tx_hu_conv = new CommitmentTransaction(null, commitment_tx);
                const inbound_htlc_preimages_conv_12_len = bindings.getArrayLength(inbound_htlc_preimages);
                const inbound_htlc_preimages_conv_12_arr = new Array(inbound_htlc_preimages_conv_12_len).fill(null);
                for (var m = 0; m < inbound_htlc_preimages_conv_12_len; m++) {
                    const inbound_htlc_preimages_conv_12 = bindings.getU32ArrayElem(inbound_htlc_preimages, m);
                    const inbound_htlc_preimages_conv_12_conv = bindings.decodeUint8Array(inbound_htlc_preimages_conv_12);
                    inbound_htlc_preimages_conv_12_arr[m] = inbound_htlc_preimages_conv_12_conv;
                }
                bindings.freeWasmMemory(inbound_htlc_preimages);
                const outbound_htlc_preimages_conv_12_len = bindings.getArrayLength(outbound_htlc_preimages);
                const outbound_htlc_preimages_conv_12_arr = new Array(outbound_htlc_preimages_conv_12_len).fill(null);
                for (var m = 0; m < outbound_htlc_preimages_conv_12_len; m++) {
                    const outbound_htlc_preimages_conv_12 = bindings.getU32ArrayElem(outbound_htlc_preimages, m);
                    const outbound_htlc_preimages_conv_12_conv = bindings.decodeUint8Array(outbound_htlc_preimages_conv_12);
                    outbound_htlc_preimages_conv_12_arr[m] = outbound_htlc_preimages_conv_12_conv;
                }
                bindings.freeWasmMemory(outbound_htlc_preimages);
                const ret = arg.sign_counterparty_commitment(commitment_tx_hu_conv, inbound_htlc_preimages_conv_12_arr, outbound_htlc_preimages_conv_12_arr);
                const result = ret.clone_ptr();
                return result;
            },
            sign_holder_commitment(commitment_tx) {
                const commitment_tx_hu_conv = new HolderCommitmentTransaction(null, commitment_tx);
                const ret = arg.sign_holder_commitment(commitment_tx_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_justice_revoked_output(justice_tx, input, amount, per_commitment_key) {
                const justice_tx_conv = bindings.decodeUint8Array(justice_tx);
                const per_commitment_key_conv = bindings.decodeUint8Array(per_commitment_key);
                const ret = arg.sign_justice_revoked_output(justice_tx_conv, input, amount, per_commitment_key_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_justice_revoked_htlc(justice_tx, input, amount, per_commitment_key, htlc) {
                const justice_tx_conv = bindings.decodeUint8Array(justice_tx);
                const per_commitment_key_conv = bindings.decodeUint8Array(per_commitment_key);
                const htlc_hu_conv = new HTLCOutputInCommitment(null, htlc);
                const ret = arg.sign_justice_revoked_htlc(justice_tx_conv, input, amount, per_commitment_key_conv, htlc_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_holder_htlc_transaction(htlc_tx, input, htlc_descriptor) {
                const htlc_tx_conv = bindings.decodeUint8Array(htlc_tx);
                const htlc_descriptor_hu_conv = new HTLCDescriptor(null, htlc_descriptor);
                const ret = arg.sign_holder_htlc_transaction(htlc_tx_conv, input, htlc_descriptor_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_counterparty_htlc_transaction(htlc_tx, input, amount, per_commitment_point, htlc) {
                const htlc_tx_conv = bindings.decodeUint8Array(htlc_tx);
                const per_commitment_point_conv = bindings.decodeUint8Array(per_commitment_point);
                const htlc_hu_conv = new HTLCOutputInCommitment(null, htlc);
                const ret = arg.sign_counterparty_htlc_transaction(htlc_tx_conv, input, amount, per_commitment_point_conv, htlc_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_closing_transaction(closing_tx) {
                const closing_tx_hu_conv = new ClosingTransaction(null, closing_tx);
                const ret = arg.sign_closing_transaction(closing_tx_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_holder_anchor_input(anchor_tx, input) {
                const anchor_tx_conv = bindings.decodeUint8Array(anchor_tx);
                const ret = arg.sign_holder_anchor_input(anchor_tx_conv, input);
                const result = ret.clone_ptr();
                return result;
            },
            sign_channel_announcement_with_funding_key(msg) {
                const msg_hu_conv = new UnsignedChannelAnnouncement(null, msg);
                const ret = arg.sign_channel_announcement_with_funding_key(msg_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
        };
        const channelSigner = ChannelSigner.new_impl(channelSigner_impl, pubkeys);
        const ptr_idx = bindings.LDKEcdsaChannelSigner_new(structImplementation, channelSigner.instance_idx, pubkeys.clone_ptr());
        impl_holder.held = new EcdsaChannelSigner(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(channelSigner);
        return impl_holder.held;
    }
    /**
     * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
     *
     * Note that if signing fails or is rejected, the channel will be force-closed.
     *
     * Policy checks should be implemented in this function, including checking the amount
     * sent to us and checking the HTLCs.
     *
     * The preimages of outbound and inbound HTLCs that were fulfilled since the last commitment
     * are provided. A validating signer should ensure that an outbound HTLC output is removed
     * only when the matching preimage is provided and after the corresponding inbound HTLC has
     * been removed for forwarded payments.
     *
     * Note that all the relevant preimages will be provided, but there may also be additional
     * irrelevant or duplicate preimages.
     */
    sign_counterparty_commitment(commitment_tx, inbound_htlc_preimages, outbound_htlc_preimages) {
        const ret = bindings.EcdsaChannelSigner_sign_counterparty_commitment(this.ptr, CommonBase.get_ptr_of(commitment_tx), bindings.encodeUint32Array(inbound_htlc_preimages.map(inbound_htlc_preimages_conv_12 => bindings.encodeUint8Array(bindings.check_arr_len(inbound_htlc_preimages_conv_12, 32)))), bindings.encodeUint32Array(outbound_htlc_preimages.map(outbound_htlc_preimages_conv_12 => bindings.encodeUint8Array(bindings.check_arr_len(outbound_htlc_preimages_conv_12, 32)))));
        const ret_hu_conv = Result_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, commitment_tx);
        return ret_hu_conv;
    }
    /**
     * Creates a signature for a holder's commitment transaction.
     *
     * This will be called
     * - with a non-revoked `commitment_tx`.
     * - with the latest `commitment_tx` when we initiate a force-close.
     *
     * This may be called multiple times for the same transaction.
     *
     * An external signer implementation should check that the commitment has not been revoked.
     *
     * An `Err` can be returned to signal that the signer is unavailable/cannot produce a valid
     * signature and should be retried later. Once the signer is ready to provide a signature after
     * previously returning an `Err`, [`ChannelMonitor::signer_unblocked`] must be called on its
     * monitor.
     *
     * [`ChannelMonitor::signer_unblocked`]: crate::chain::channelmonitor::ChannelMonitor::signer_unblocked
     */
    sign_holder_commitment(commitment_tx) {
        const ret = bindings.EcdsaChannelSigner_sign_holder_commitment(this.ptr, CommonBase.get_ptr_of(commitment_tx));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, commitment_tx);
        return ret_hu_conv;
    }
    /**
     * Create a signature for the given input in a transaction spending an HTLC transaction output
     * or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
     *
     * A justice transaction may claim multiple outputs at the same time if timelocks are
     * similar, but only a signature for the input at index `input` should be signed for here.
     * It may be called multiple times for same output(s) if a fee-bump is needed with regards
     * to an upcoming timelock expiration.
     *
     * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
     *
     * `per_commitment_key` is revocation secret which was provided by our counterparty when they
     * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
     * not allow the spending of any funds by itself (you need our holder `revocation_secret` to do
     * so).
     *
     * An `Err` can be returned to signal that the signer is unavailable/cannot produce a valid
     * signature and should be retried later. Once the signer is ready to provide a signature after
     * previously returning an `Err`, [`ChannelMonitor::signer_unblocked`] must be called on its
     * monitor.
     *
     * [`ChannelMonitor::signer_unblocked`]: crate::chain::channelmonitor::ChannelMonitor::signer_unblocked
     */
    sign_justice_revoked_output(justice_tx, input, amount, per_commitment_key) {
        const ret = bindings.EcdsaChannelSigner_sign_justice_revoked_output(this.ptr, bindings.encodeUint8Array(justice_tx), input, amount, bindings.encodeUint8Array(bindings.check_arr_len(per_commitment_key, 32)));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Create a signature for the given input in a transaction spending a commitment transaction
     * HTLC output when our counterparty broadcasts an old state.
     *
     * A justice transaction may claim multiple outputs at the same time if timelocks are
     * similar, but only a signature for the input at index `input` should be signed for here.
     * It may be called multiple times for same output(s) if a fee-bump is needed with regards
     * to an upcoming timelock expiration.
     *
     * `amount` is the value of the output spent by this input, committed to in the BIP 143
     * signature.
     *
     * `per_commitment_key` is revocation secret which was provided by our counterparty when they
     * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
     * not allow the spending of any funds by itself (you need our holder revocation_secret to do
     * so).
     *
     * `htlc` holds HTLC elements (hash, timelock), thus changing the format of the witness script
     * (which is committed to in the BIP 143 signatures).
     *
     * An `Err` can be returned to signal that the signer is unavailable/cannot produce a valid
     * signature and should be retried later. Once the signer is ready to provide a signature after
     * previously returning an `Err`, [`ChannelMonitor::signer_unblocked`] must be called on its
     * monitor.
     *
     * [`ChannelMonitor::signer_unblocked`]: crate::chain::channelmonitor::ChannelMonitor::signer_unblocked
     */
    sign_justice_revoked_htlc(justice_tx, input, amount, per_commitment_key, htlc) {
        const ret = bindings.EcdsaChannelSigner_sign_justice_revoked_htlc(this.ptr, bindings.encodeUint8Array(justice_tx), input, amount, bindings.encodeUint8Array(bindings.check_arr_len(per_commitment_key, 32)), CommonBase.get_ptr_of(htlc));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, htlc);
        return ret_hu_conv;
    }
    /**
     * Computes the signature for a commitment transaction's HTLC output used as an input within
     * `htlc_tx`, which spends the commitment transaction at index `input`. The signature returned
     * must be be computed using [`EcdsaSighashType::All`].
     *
     * Note that this may be called for HTLCs in the penultimate commitment transaction if a
     * [`ChannelMonitor`] [replica](https://github.com/lightningdevkit/rust-lightning/blob/main/GLOSSARY.md#monitor-replicas)
     * broadcasts it before receiving the update for the latest commitment transaction.
     *
     * An `Err` can be returned to signal that the signer is unavailable/cannot produce a valid
     * signature and should be retried later. Once the signer is ready to provide a signature after
     * previously returning an `Err`, [`ChannelMonitor::signer_unblocked`] must be called on its
     * monitor.
     *
     * [`EcdsaSighashType::All`]: bitcoin::sighash::EcdsaSighashType::All
     * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
     * [`ChannelMonitor::signer_unblocked`]: crate::chain::channelmonitor::ChannelMonitor::signer_unblocked
     */
    sign_holder_htlc_transaction(htlc_tx, input, htlc_descriptor) {
        const ret = bindings.EcdsaChannelSigner_sign_holder_htlc_transaction(this.ptr, bindings.encodeUint8Array(htlc_tx), input, CommonBase.get_ptr_of(htlc_descriptor));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, htlc_descriptor);
        return ret_hu_conv;
    }
    /**
     * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
     * transaction, either offered or received.
     *
     * Such a transaction may claim multiples offered outputs at same time if we know the
     * preimage for each when we create it, but only the input at index `input` should be
     * signed for here. It may be called multiple times for same output(s) if a fee-bump is
     * needed with regards to an upcoming timelock expiration.
     *
     * `witness_script` is either an offered or received script as defined in BOLT3 for HTLC
     * outputs.
     *
     * `amount` is value of the output spent by this input, committed to in the BIP 143 signature.
     *
     * `per_commitment_point` is the dynamic point corresponding to the channel state
     * detected onchain. It has been generated by our counterparty and is used to derive
     * channel state keys, which are then included in the witness script and committed to in the
     * BIP 143 signature.
     *
     * An `Err` can be returned to signal that the signer is unavailable/cannot produce a valid
     * signature and should be retried later. Once the signer is ready to provide a signature after
     * previously returning an `Err`, [`ChannelMonitor::signer_unblocked`] must be called on its
     * monitor.
     *
     * [`ChannelMonitor::signer_unblocked`]: crate::chain::channelmonitor::ChannelMonitor::signer_unblocked
     */
    sign_counterparty_htlc_transaction(htlc_tx, input, amount, per_commitment_point, htlc) {
        const ret = bindings.EcdsaChannelSigner_sign_counterparty_htlc_transaction(this.ptr, bindings.encodeUint8Array(htlc_tx), input, amount, bindings.encodeUint8Array(bindings.check_arr_len(per_commitment_point, 33)), CommonBase.get_ptr_of(htlc));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, htlc);
        return ret_hu_conv;
    }
    /**
     * Create a signature for a (proposed) closing transaction.
     *
     * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
     * chosen to forgo their output as dust.
     */
    sign_closing_transaction(closing_tx) {
        const ret = bindings.EcdsaChannelSigner_sign_closing_transaction(this.ptr, CommonBase.get_ptr_of(closing_tx));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, closing_tx);
        return ret_hu_conv;
    }
    /**
     * Computes the signature for a commitment transaction's anchor output used as an
     * input within `anchor_tx`, which spends the commitment transaction, at index `input`.
     *
     * An `Err` can be returned to signal that the signer is unavailable/cannot produce a valid
     * signature and should be retried later. Once the signer is ready to provide a signature after
     * previously returning an `Err`, [`ChannelMonitor::signer_unblocked`] must be called on its
     * monitor.
     *
     * [`ChannelMonitor::signer_unblocked`]: crate::chain::channelmonitor::ChannelMonitor::signer_unblocked
     */
    sign_holder_anchor_input(anchor_tx, input) {
        const ret = bindings.EcdsaChannelSigner_sign_holder_anchor_input(this.ptr, bindings.encodeUint8Array(anchor_tx), input);
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Signs a channel announcement message with our funding key proving it comes from one of the
     * channel participants.
     *
     * Channel announcements also require a signature from each node's network key. Our node
     * signature is computed through [`NodeSigner::sign_gossip_message`].
     *
     * Note that if this fails or is rejected, the channel will not be publicly announced and
     * our counterparty may (though likely will not) close the channel on us for violating the
     * protocol.
     *
     * [`NodeSigner::sign_gossip_message`]: crate::sign::NodeSigner::sign_gossip_message
     */
    sign_channel_announcement_with_funding_key(msg) {
        const ret = bindings.EcdsaChannelSigner_sign_channel_announcement_with_funding_key(this.ptr, CommonBase.get_ptr_of(msg));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, msg);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.EcdsaChannelSigner_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of a EcdsaChannelSigner
     */
    clone() {
        const ret = bindings.EcdsaChannelSigner_clone(this.ptr);
        const ret_hu_conv = new EcdsaChannelSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=EcdsaChannelSigner.mjs.map