import { Option_u64Z } from '../structs/Option_u64Z.mjs';
import { Option_ThirtyTwoBytesZ } from '../structs/Option_ThirtyTwoBytesZ.mjs';
import { RecipientOnionFields } from '../structs/RecipientOnionFields.mjs';
import { Bolt12Invoice } from '../structs/Bolt12Invoice.mjs';
import { OutPoint } from '../structs/OutPoint.mjs';
import { SpendableOutputDescriptor } from '../structs/SpendableOutputDescriptor.mjs';
import { Option_u32Z } from '../structs/Option_u32Z.mjs';
import { Path } from '../structs/Path.mjs';
import { ClosureReason } from '../structs/ClosureReason.mjs';
import { ChannelId } from '../structs/ChannelId.mjs';
import { ChannelTypeFeatures } from '../structs/ChannelTypeFeatures.mjs';
import { SocketAddress } from '../structs/SocketAddress.mjs';
import { Option_OffersContextZ } from '../structs/Option_OffersContextZ.mjs';
import { OnionMessage } from '../structs/OnionMessage.mjs';
import { FundingInfo } from '../structs/FundingInfo.mjs';
import { PaymentPurpose } from '../structs/PaymentPurpose.mjs';
import { ClaimedHTLC } from '../structs/ClaimedHTLC.mjs';
import { PathFailure } from '../structs/PathFailure.mjs';
import { HTLCDestination } from '../structs/HTLCDestination.mjs';
import { Option_PaymentFailureReasonZ } from '../structs/Option_PaymentFailureReasonZ.mjs';
import { Option_U128Z } from '../structs/Option_U128Z.mjs';
import { Responder } from '../structs/Responder.mjs';
import { ChannelParameters } from '../structs/ChannelParameters.mjs';
import { BumpTransactionEvent } from '../structs/BumpTransactionEvent.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */
export declare class Event extends CommonBase {
    protected constructor(_dummy: null, ptr: bigint);
    clone_ptr(): bigint;
    /**
     * Creates a copy of the Event
     */
    clone(): Event;
    /**
     * Utility method to constructs a new FundingGenerationReady-variant Event
     */
    static constructor_funding_generation_ready(temporary_channel_id: ChannelId, counterparty_node_id: Uint8Array, channel_value_satoshis: bigint, output_script: Uint8Array, user_channel_id: bigint): Event;
    /**
     * Utility method to constructs a new FundingTxBroadcastSafe-variant Event
     */
    static constructor_funding_tx_broadcast_safe(channel_id: ChannelId, user_channel_id: bigint, funding_txo: OutPoint, counterparty_node_id: Uint8Array, former_temporary_channel_id: ChannelId): Event;
    /**
     * Utility method to constructs a new PaymentClaimable-variant Event
     */
    static constructor_payment_claimable(receiver_node_id: Uint8Array, payment_hash: Uint8Array, onion_fields: RecipientOnionFields, amount_msat: bigint, counterparty_skimmed_fee_msat: bigint, purpose: PaymentPurpose, via_channel_id: ChannelId, via_user_channel_id: Option_U128Z, claim_deadline: Option_u32Z): Event;
    /**
     * Utility method to constructs a new PaymentClaimed-variant Event
     */
    static constructor_payment_claimed(receiver_node_id: Uint8Array, payment_hash: Uint8Array, amount_msat: bigint, purpose: PaymentPurpose, htlcs: ClaimedHTLC[], sender_intended_total_msat: Option_u64Z, onion_fields: RecipientOnionFields): Event;
    /**
     * Utility method to constructs a new ConnectionNeeded-variant Event
     */
    static constructor_connection_needed(node_id: Uint8Array, addresses: SocketAddress[]): Event;
    /**
     * Utility method to constructs a new InvoiceReceived-variant Event
     */
    static constructor_invoice_received(payment_id: Uint8Array, invoice: Bolt12Invoice, context: Option_OffersContextZ, responder: Responder): Event;
    /**
     * Utility method to constructs a new PaymentSent-variant Event
     */
    static constructor_payment_sent(payment_id: Option_ThirtyTwoBytesZ, payment_preimage: Uint8Array, payment_hash: Uint8Array, fee_paid_msat: Option_u64Z): Event;
    /**
     * Utility method to constructs a new PaymentFailed-variant Event
     */
    static constructor_payment_failed(payment_id: Uint8Array, payment_hash: Option_ThirtyTwoBytesZ, reason: Option_PaymentFailureReasonZ): Event;
    /**
     * Utility method to constructs a new PaymentPathSuccessful-variant Event
     */
    static constructor_payment_path_successful(payment_id: Uint8Array, payment_hash: Option_ThirtyTwoBytesZ, path: Path): Event;
    /**
     * Utility method to constructs a new PaymentPathFailed-variant Event
     */
    static constructor_payment_path_failed(payment_id: Option_ThirtyTwoBytesZ, payment_hash: Uint8Array, payment_failed_permanently: boolean, failure: PathFailure, path: Path, short_channel_id: Option_u64Z): Event;
    /**
     * Utility method to constructs a new ProbeSuccessful-variant Event
     */
    static constructor_probe_successful(payment_id: Uint8Array, payment_hash: Uint8Array, path: Path): Event;
    /**
     * Utility method to constructs a new ProbeFailed-variant Event
     */
    static constructor_probe_failed(payment_id: Uint8Array, payment_hash: Uint8Array, path: Path, short_channel_id: Option_u64Z): Event;
    /**
     * Utility method to constructs a new PendingHTLCsForwardable-variant Event
     */
    static constructor_pending_htlcs_forwardable(time_forwardable: bigint): Event;
    /**
     * Utility method to constructs a new HTLCIntercepted-variant Event
     */
    static constructor_htlcintercepted(intercept_id: Uint8Array, requested_next_hop_scid: bigint, payment_hash: Uint8Array, inbound_amount_msat: bigint, expected_outbound_amount_msat: bigint): Event;
    /**
     * Utility method to constructs a new SpendableOutputs-variant Event
     */
    static constructor_spendable_outputs(outputs: SpendableOutputDescriptor[], channel_id: ChannelId): Event;
    /**
     * Utility method to constructs a new PaymentForwarded-variant Event
     */
    static constructor_payment_forwarded(prev_channel_id: ChannelId, next_channel_id: ChannelId, prev_user_channel_id: Option_U128Z, next_user_channel_id: Option_U128Z, total_fee_earned_msat: Option_u64Z, skimmed_fee_msat: Option_u64Z, claim_from_onchain_tx: boolean, outbound_amount_forwarded_msat: Option_u64Z): Event;
    /**
     * Utility method to constructs a new ChannelPending-variant Event
     */
    static constructor_channel_pending(channel_id: ChannelId, user_channel_id: bigint, former_temporary_channel_id: ChannelId, counterparty_node_id: Uint8Array, funding_txo: OutPoint, channel_type: ChannelTypeFeatures): Event;
    /**
     * Utility method to constructs a new ChannelReady-variant Event
     */
    static constructor_channel_ready(channel_id: ChannelId, user_channel_id: bigint, counterparty_node_id: Uint8Array, channel_type: ChannelTypeFeatures): Event;
    /**
     * Utility method to constructs a new ChannelClosed-variant Event
     */
    static constructor_channel_closed(channel_id: ChannelId, user_channel_id: bigint, reason: ClosureReason, counterparty_node_id: Uint8Array, channel_capacity_sats: Option_u64Z, channel_funding_txo: OutPoint): Event;
    /**
     * Utility method to constructs a new DiscardFunding-variant Event
     */
    static constructor_discard_funding(channel_id: ChannelId, funding_info: FundingInfo): Event;
    /**
     * Utility method to constructs a new OpenChannelRequest-variant Event
     */
    static constructor_open_channel_request(temporary_channel_id: ChannelId, counterparty_node_id: Uint8Array, funding_satoshis: bigint, push_msat: bigint, channel_type: ChannelTypeFeatures, is_announced: boolean, params: ChannelParameters): Event;
    /**
     * Utility method to constructs a new HTLCHandlingFailed-variant Event
     */
    static constructor_htlchandling_failed(prev_channel_id: ChannelId, failed_next_destination: HTLCDestination): Event;
    /**
     * Utility method to constructs a new BumpTransaction-variant Event
     */
    static constructor_bump_transaction(a: BumpTransactionEvent): Event;
    /**
     * Utility method to constructs a new OnionMessageIntercepted-variant Event
     */
    static constructor_onion_message_intercepted(peer_node_id: Uint8Array, message: OnionMessage): Event;
    /**
     * Utility method to constructs a new OnionMessagePeerConnected-variant Event
     */
    static constructor_onion_message_peer_connected(peer_node_id: Uint8Array): Event;
    /**
     * Checks if two Events contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     */
    eq(b: Event): boolean;
    /**
     * Serialize the Event object into a byte array which can be read by Event_read
     */
    write(): Uint8Array;
}
/** A Event of type FundingGenerationReady */
export declare class Event_FundingGenerationReady extends Event {
    /**
     * The random channel_id we picked which you'll need to pass into
     * [`ChannelManager::funding_transaction_generated`].
     *
     * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
     */
    temporary_channel_id: ChannelId;
    /**
     * The counterparty's node_id, which you'll need to pass back into
     * [`ChannelManager::funding_transaction_generated`].
     *
     * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
     */
    counterparty_node_id: Uint8Array;
    /**
     * The value, in satoshis, that the output should have.
     */
    channel_value_satoshis: bigint;
    /**
     * The script which should be used in the transaction output.
     */
    output_script: Uint8Array;
    /**
     * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
     * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.  This may be zero for objects
     * serialized with LDK versions prior to 0.0.113.
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    user_channel_id: bigint;
}
/** A Event of type FundingTxBroadcastSafe */
export declare class Event_FundingTxBroadcastSafe extends Event {
    /**
     * The `channel_id` indicating which channel has reached this stage.
     */
    channel_id: ChannelId;
    /**
     * The `user_channel_id` value passed in to [`ChannelManager::create_channel`].
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     */
    user_channel_id: bigint;
    /**
     * The outpoint of the channel's funding transaction.
     */
    funding_txo: OutPoint;
    /**
     * The `node_id` of the channel counterparty.
     */
    counterparty_node_id: Uint8Array;
    /**
     * The `temporary_channel_id` this channel used to be known by during channel establishment.
     */
    former_temporary_channel_id: ChannelId;
}
/** A Event of type PaymentClaimable */
export declare class Event_PaymentClaimable extends Event {
    /**
     * The node that will receive the payment after it has been claimed.
     * This is useful to identify payments received via [phantom nodes].
     * This field will always be filled in when the event was generated by LDK versions
     * 0.0.113 and above.
     *
     * [phantom nodes]: crate::sign::PhantomKeysManager
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    receiver_node_id: Uint8Array;
    /**
     * The hash for which the preimage should be handed to the ChannelManager. Note that LDK will
     * not stop you from registering duplicate payment hashes for inbound payments.
     */
    payment_hash: Uint8Array;
    /**
     * The fields in the onion which were received with each HTLC. Only fields which were
     * identical in each HTLC involved in the payment will be included here.
     *
     * Payments received on LDK versions prior to 0.0.115 will have this field unset.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    onion_fields: RecipientOnionFields;
    /**
     * The value, in thousandths of a satoshi, that this payment is claimable for. May be greater
     * than the invoice amount.
     *
     * May be less than the invoice amount if [`ChannelConfig::accept_underpaying_htlcs`] is set
     * and the previous hop took an extra fee.
     *
     * # Note
     * If [`ChannelConfig::accept_underpaying_htlcs`] is set and you claim without verifying this
     * field, you may lose money!
     *
     * [`ChannelConfig::accept_underpaying_htlcs`]: crate::util::config::ChannelConfig::accept_underpaying_htlcs
     */
    amount_msat: bigint;
    /**
     * The value, in thousands of a satoshi, that was skimmed off of this payment as an extra fee
     * taken by our channel counterparty.
     *
     * Will always be 0 unless [`ChannelConfig::accept_underpaying_htlcs`] is set.
     *
     * [`ChannelConfig::accept_underpaying_htlcs`]: crate::util::config::ChannelConfig::accept_underpaying_htlcs
     */
    counterparty_skimmed_fee_msat: bigint;
    /**
     * Information for claiming this received payment, based on whether the purpose of the
     * payment is to pay an invoice or to send a spontaneous payment.
     */
    purpose: PaymentPurpose;
    /**
     * The `channel_id` indicating over which channel we received the payment.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    via_channel_id: ChannelId;
    /**
     * The `user_channel_id` indicating over which channel we received the payment.
     */
    via_user_channel_id: Option_U128Z;
    /**
     * The block height at which this payment will be failed back and will no longer be
     * eligible for claiming.
     *
     * Prior to this height, a call to [`ChannelManager::claim_funds`] is guaranteed to
     * succeed, however you should wait for [`Event::PaymentClaimed`] to be sure.
     *
     * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
     */
    claim_deadline: Option_u32Z;
}
/** A Event of type PaymentClaimed */
export declare class Event_PaymentClaimed extends Event {
    /**
     * The node that received the payment.
     * This is useful to identify payments which were received via [phantom nodes].
     * This field will always be filled in when the event was generated by LDK versions
     * 0.0.113 and above.
     *
     * [phantom nodes]: crate::sign::PhantomKeysManager
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    receiver_node_id: Uint8Array;
    /**
     * The payment hash of the claimed payment. Note that LDK will not stop you from
     * registering duplicate payment hashes for inbound payments.
     */
    payment_hash: Uint8Array;
    /**
     * The value, in thousandths of a satoshi, that this payment is for. May be greater than the
     * invoice amount.
     */
    amount_msat: bigint;
    /**
     * The purpose of the claimed payment, i.e. whether the payment was for an invoice or a
     * spontaneous payment.
     */
    purpose: PaymentPurpose;
    /**
     * The HTLCs that comprise the claimed payment. This will be empty for events serialized prior
     * to LDK version 0.0.117.
     */
    htlcs: ClaimedHTLC[];
    /**
     * The sender-intended sum total of all the MPP parts. This will be `None` for events
     * serialized prior to LDK version 0.0.117.
     */
    sender_intended_total_msat: Option_u64Z;
    /**
     * The fields in the onion which were received with each HTLC. Only fields which were
     * identical in each HTLC involved in the payment will be included here.
     *
     * Payments received on LDK versions prior to 0.0.124 will have this field unset.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    onion_fields: RecipientOnionFields;
}
/** A Event of type ConnectionNeeded */
export declare class Event_ConnectionNeeded extends Event {
    /**
     * The node id for the node needing a connection.
     */
    node_id: Uint8Array;
    /**
     * Sockets for connecting to the node.
     */
    addresses: SocketAddress[];
}
/** A Event of type InvoiceReceived */
export declare class Event_InvoiceReceived extends Event {
    /**
     * The `payment_id` associated with payment for the invoice.
     */
    payment_id: Uint8Array;
    /**
     * The invoice to pay.
     */
    invoice: Bolt12Invoice;
    /**
     * The context of the [`BlindedMessagePath`] used to send the invoice.
     *
     * [`BlindedMessagePath`]: crate::blinded_path::message::BlindedMessagePath
     */
    context: Option_OffersContextZ;
    /**
     * A responder for replying with an [`InvoiceError`] if needed.
     *
     * `None` if the invoice wasn't sent with a reply path.
     *
     * [`InvoiceError`]: crate::offers::invoice_error::InvoiceError
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    responder: Responder;
}
/** A Event of type PaymentSent */
export declare class Event_PaymentSent extends Event {
    /**
     * The `payment_id` passed to [`ChannelManager::send_payment`].
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     */
    payment_id: Option_ThirtyTwoBytesZ;
    /**
     * The preimage to the hash given to ChannelManager::send_payment.
     * Note that this serves as a payment receipt, if you wish to have such a thing, you must
     * store it somehow!
     */
    payment_preimage: Uint8Array;
    /**
     * The hash that was given to [`ChannelManager::send_payment`].
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     */
    payment_hash: Uint8Array;
    /**
     * The total fee which was spent at intermediate hops in this payment, across all paths.
     *
     * Note that, like [`Route::get_total_fees`] this does *not* include any potential
     * overpayment to the recipient node.
     *
     * If the recipient or an intermediate node misbehaves and gives us free money, this may
     * overstate the amount paid, though this is unlikely.
     *
     * This is only `None` for payments initiated on LDK versions prior to 0.0.103.
     *
     * [`Route::get_total_fees`]: crate::routing::router::Route::get_total_fees
     */
    fee_paid_msat: Option_u64Z;
}
/** A Event of type PaymentFailed */
export declare class Event_PaymentFailed extends Event {
    /**
     * The `payment_id` passed to [`ChannelManager::send_payment`].
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     */
    payment_id: Uint8Array;
    /**
     * The hash that was given to [`ChannelManager::send_payment`]. `None` if the payment failed
     * before receiving an invoice when paying a BOLT12 [`Offer`].
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     * [`Offer`]: crate::offers::offer::Offer
     */
    payment_hash: Option_ThirtyTwoBytesZ;
    /**
     * The reason the payment failed. This is only `None` for events generated or serialized
     * by versions prior to 0.0.115, or when downgrading to a version with a reason that was
     * added after.
     */
    reason: Option_PaymentFailureReasonZ;
}
/** A Event of type PaymentPathSuccessful */
export declare class Event_PaymentPathSuccessful extends Event {
    /**
     * The `payment_id` passed to [`ChannelManager::send_payment`].
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     */
    payment_id: Uint8Array;
    /**
     * The hash that was given to [`ChannelManager::send_payment`].
     *
     * This will be `Some` for all payments which completed on LDK 0.0.104 or later.
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     */
    payment_hash: Option_ThirtyTwoBytesZ;
    /**
     * The payment path that was successful.
     *
     * May contain a closed channel if the HTLC sent along the path was fulfilled on chain.
     */
    path: Path;
}
/** A Event of type PaymentPathFailed */
export declare class Event_PaymentPathFailed extends Event {
    /**
     * The `payment_id` passed to [`ChannelManager::send_payment`].
     *
     * This will be `Some` for all payment paths which failed on LDK 0.0.103 or later.
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
     */
    payment_id: Option_ThirtyTwoBytesZ;
    /**
     * The hash that was given to [`ChannelManager::send_payment`].
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     */
    payment_hash: Uint8Array;
    /**
     * Indicates the payment was rejected for some reason by the recipient. This implies that
     * the payment has failed, not just the route in question. If this is not set, the payment may
     * be retried via a different route.
     */
    payment_failed_permanently: boolean;
    /**
     * Extra error details based on the failure type. May contain an update that needs to be
     * applied to the [`NetworkGraph`].
     *
     * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
     */
    failure: PathFailure;
    /**
     * The payment path that failed.
     */
    path: Path;
    /**
     * The channel responsible for the failed payment path.
     *
     * Note that for route hints or for the first hop in a path this may be an SCID alias and
     * may not refer to a channel in the public network graph. These aliases may also collide
     * with channels in the public network graph.
     *
     * If this is `Some`, then the corresponding channel should be avoided when the payment is
     * retried. May be `None` for older [`Event`] serializations.
     */
    short_channel_id: Option_u64Z;
}
/** A Event of type ProbeSuccessful */
export declare class Event_ProbeSuccessful extends Event {
    /**
     * The id returned by [`ChannelManager::send_probe`].
     *
     * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
     */
    payment_id: Uint8Array;
    /**
     * The hash generated by [`ChannelManager::send_probe`].
     *
     * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
     */
    payment_hash: Uint8Array;
    /**
     * The payment path that was successful.
     */
    path: Path;
}
/** A Event of type ProbeFailed */
export declare class Event_ProbeFailed extends Event {
    /**
     * The id returned by [`ChannelManager::send_probe`].
     *
     * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
     */
    payment_id: Uint8Array;
    /**
     * The hash generated by [`ChannelManager::send_probe`].
     *
     * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
     */
    payment_hash: Uint8Array;
    /**
     * The payment path that failed.
     */
    path: Path;
    /**
     * The channel responsible for the failed probe.
     *
     * Note that for route hints or for the first hop in a path this may be an SCID alias and
     * may not refer to a channel in the public network graph. These aliases may also collide
     * with channels in the public network graph.
     */
    short_channel_id: Option_u64Z;
}
/** A Event of type PendingHTLCsForwardable */
export declare class Event_PendingHTLCsForwardable extends Event {
    /**
     * The minimum amount of time that should be waited prior to calling
     * process_pending_htlc_forwards. To increase the effort required to correlate payments,
     * you should wait a random amount of time in roughly the range (now + time_forwardable,
     * now + 5*time_forwardable).
     */
    time_forwardable: bigint;
}
/** A Event of type HTLCIntercepted */
export declare class Event_HTLCIntercepted extends Event {
    /**
     * An id to help LDK identify which HTLC is being forwarded or failed.
     */
    intercept_id: Uint8Array;
    /**
     * The fake scid that was programmed as the next hop's scid, generated using
     * [`ChannelManager::get_intercept_scid`].
     *
     * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
     */
    requested_next_hop_scid: bigint;
    /**
     * The payment hash used for this HTLC.
     */
    payment_hash: Uint8Array;
    /**
     * How many msats were received on the inbound edge of this HTLC.
     */
    inbound_amount_msat: bigint;
    /**
     * How many msats the payer intended to route to the next node. Depending on the reason you are
     * intercepting this payment, you might take a fee by forwarding less than this amount.
     * Forwarding less than this amount may break compatibility with LDK versions prior to 0.0.116.
     *
     * Note that LDK will NOT check that expected fees were factored into this value. You MUST
     * check that whatever fee you want has been included here or subtract it as required. Further,
     * LDK will not stop you from forwarding more than you received.
     */
    expected_outbound_amount_msat: bigint;
}
/** A Event of type SpendableOutputs */
export declare class Event_SpendableOutputs extends Event {
    /**
     * The outputs which you should store as spendable by you.
     */
    outputs: SpendableOutputDescriptor[];
    /**
     * The `channel_id` indicating which channel the spendable outputs belong to.
     *
     * This will always be `Some` for events generated by LDK versions 0.0.117 and above.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    channel_id: ChannelId;
}
/** A Event of type PaymentForwarded */
export declare class Event_PaymentForwarded extends Event {
    /**
     * The channel id of the incoming channel between the previous node and us.
     *
     * This is only `None` for events generated or serialized by versions prior to 0.0.107.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    prev_channel_id: ChannelId;
    /**
     * The channel id of the outgoing channel between the next node and us.
     *
     * This is only `None` for events generated or serialized by versions prior to 0.0.107.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    next_channel_id: ChannelId;
    /**
     * The `user_channel_id` of the incoming channel between the previous node and us.
     *
     * This is only `None` for events generated or serialized by versions prior to 0.0.122.
     */
    prev_user_channel_id: Option_U128Z;
    /**
     * The `user_channel_id` of the outgoing channel between the next node and us.
     *
     * This will be `None` if the payment was settled via an on-chain transaction. See the
     * caveat described for the `total_fee_earned_msat` field. Moreover it will be `None` for
     * events generated or serialized by versions prior to 0.0.122.
     */
    next_user_channel_id: Option_U128Z;
    /**
     * The total fee, in milli-satoshis, which was earned as a result of the payment.
     *
     * Note that if we force-closed the channel over which we forwarded an HTLC while the HTLC
     * was pending, the amount the next hop claimed will have been rounded down to the nearest
     * whole satoshi. Thus, the fee calculated here may be higher than expected as we still
     * claimed the full value in millisatoshis from the source. In this case,
     * `claim_from_onchain_tx` will be set.
     *
     * If the channel which sent us the payment has been force-closed, we will claim the funds
     * via an on-chain transaction. In that case we do not yet know the on-chain transaction
     * fees which we will spend and will instead set this to `None`. It is possible duplicate
     * `PaymentForwarded` events are generated for the same payment iff `total_fee_earned_msat` is
     * `None`.
     */
    total_fee_earned_msat: Option_u64Z;
    /**
     * The share of the total fee, in milli-satoshis, which was withheld in addition to the
     * forwarding fee.
     *
     * This will only be `Some` if we forwarded an intercepted HTLC with less than the
     * expected amount. This means our counterparty accepted to receive less than the invoice
     * amount, e.g., by claiming the payment featuring a corresponding
     * [`PaymentClaimable::counterparty_skimmed_fee_msat`].
     *
     * Will also always be `None` for events serialized with LDK prior to version 0.0.122.
     *
     * The caveat described above the `total_fee_earned_msat` field applies here as well.
     *
     * [`PaymentClaimable::counterparty_skimmed_fee_msat`]: Self::PaymentClaimable::counterparty_skimmed_fee_msat
     */
    skimmed_fee_msat: Option_u64Z;
    /**
     * If this is `true`, the forwarded HTLC was claimed by our counterparty via an on-chain
     * transaction.
     */
    claim_from_onchain_tx: boolean;
    /**
     * The final amount forwarded, in milli-satoshis, after the fee is deducted.
     *
     * The caveat described above the `total_fee_earned_msat` field applies here as well.
     */
    outbound_amount_forwarded_msat: Option_u64Z;
}
/** A Event of type ChannelPending */
export declare class Event_ChannelPending extends Event {
    /**
     * The `channel_id` of the channel that is pending confirmation.
     */
    channel_id: ChannelId;
    /**
     * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
     * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    user_channel_id: bigint;
    /**
     * The `temporary_channel_id` this channel used to be known by during channel establishment.
     *
     * Will be `None` for channels created prior to LDK version 0.0.115.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    former_temporary_channel_id: ChannelId;
    /**
     * The `node_id` of the channel counterparty.
     */
    counterparty_node_id: Uint8Array;
    /**
     * The outpoint of the channel's funding transaction.
     */
    funding_txo: OutPoint;
    /**
     * The features that this channel will operate with.
     *
     * Will be `None` for channels created prior to LDK version 0.0.122.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    channel_type: ChannelTypeFeatures;
}
/** A Event of type ChannelReady */
export declare class Event_ChannelReady extends Event {
    /**
     * The `channel_id` of the channel that is ready.
     */
    channel_id: ChannelId;
    /**
     * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
     * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for an inbound channel.
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    user_channel_id: bigint;
    /**
     * The `node_id` of the channel counterparty.
     */
    counterparty_node_id: Uint8Array;
    /**
     * The features that this channel will operate with.
     */
    channel_type: ChannelTypeFeatures;
}
/** A Event of type ChannelClosed */
export declare class Event_ChannelClosed extends Event {
    /**
     * The `channel_id` of the channel which has been closed. Note that on-chain transactions
     * resolving the channel are likely still awaiting confirmation.
     */
    channel_id: ChannelId;
    /**
     * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
     * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
     * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
     * `user_channel_id` will be randomized for inbound channels.
     * This may be zero for inbound channels serialized prior to 0.0.113 and will always be
     * zero for objects serialized with LDK versions prior to 0.0.102.
     *
     * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
     */
    user_channel_id: bigint;
    /**
     * The reason the channel was closed.
     */
    reason: ClosureReason;
    /**
     * Counterparty in the closed channel.
     *
     * This field will be `None` for objects serialized prior to LDK 0.0.117.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    counterparty_node_id: Uint8Array;
    /**
     * Channel capacity of the closing channel (sats).
     *
     * This field will be `None` for objects serialized prior to LDK 0.0.117.
     */
    channel_capacity_sats: Option_u64Z;
    /**
     * The original channel funding TXO; this helps checking for the existence and confirmation
     * status of the closing tx.
     * Note that for instances serialized in v0.0.119 or prior this will be missing (None).
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    channel_funding_txo: OutPoint;
}
/** A Event of type DiscardFunding */
export declare class Event_DiscardFunding extends Event {
    /**
     * The channel_id of the channel which has been closed.
     */
    channel_id: ChannelId;
    /**
     * The full transaction received from the user
     */
    funding_info: FundingInfo;
}
/** A Event of type OpenChannelRequest */
export declare class Event_OpenChannelRequest extends Event {
    /**
     * The temporary channel ID of the channel requested to be opened.
     *
     * When responding to the request, the `temporary_channel_id` should be passed
     * back to the ChannelManager through [`ChannelManager::accept_inbound_channel`] to accept,
     * or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject.
     *
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
     */
    temporary_channel_id: ChannelId;
    /**
     * The node_id of the counterparty requesting to open the channel.
     *
     * When responding to the request, the `counterparty_node_id` should be passed
     * back to the `ChannelManager` through [`ChannelManager::accept_inbound_channel`] to
     * accept the request, or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject the
     * request.
     *
     * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
     * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
     */
    counterparty_node_id: Uint8Array;
    /**
     * The channel value of the requested channel.
     */
    funding_satoshis: bigint;
    /**
     * Our starting balance in the channel if the request is accepted, in milli-satoshi.
     */
    push_msat: bigint;
    /**
     * The features that this channel will operate with. If you reject the channel, a
     * well-behaved counterparty may automatically re-attempt the channel with a new set of
     * feature flags.
     *
     * Note that if [`ChannelTypeFeatures::supports_scid_privacy`] returns true on this type,
     * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
     * 0.0.106.
     *
     * Furthermore, note that if [`ChannelTypeFeatures::supports_zero_conf`] returns true on this type,
     * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
     * 0.0.107. Channels setting this type also need to get manually accepted via
     * [`crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`],
     * or will be rejected otherwise.
     *
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     */
    channel_type: ChannelTypeFeatures;
    /**
     * True if this channel is (or will be) publicly-announced.
     */
    is_announced: boolean;
    /**
     * Channel parameters given by the counterparty.
     */
    params: ChannelParameters;
}
/** A Event of type HTLCHandlingFailed */
export declare class Event_HTLCHandlingFailed extends Event {
    /**
     * The channel over which the HTLC was received.
     */
    prev_channel_id: ChannelId;
    /**
     * Destination of the HTLC that failed to be processed.
     */
    failed_next_destination: HTLCDestination;
}
/** A Event of type BumpTransaction */
export declare class Event_BumpTransaction extends Event {
    bump_transaction: BumpTransactionEvent;
}
/** A Event of type OnionMessageIntercepted */
export declare class Event_OnionMessageIntercepted extends Event {
    /**
     * The node id of the offline peer.
     */
    peer_node_id: Uint8Array;
    /**
     * The onion message intended to be forwarded to `peer_node_id`.
     */
    message: OnionMessage;
}
/** A Event of type OnionMessagePeerConnected */
export declare class Event_OnionMessagePeerConnected extends Event {
    /**
     * The node id of the peer we just connected to, who advertises support for
     * onion messages.
     */
    peer_node_id: Uint8Array;
}
