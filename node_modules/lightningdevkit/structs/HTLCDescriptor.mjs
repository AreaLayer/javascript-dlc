import { TxOut } from '../structs/TxOut.mjs';
import { TxIn } from '../structs/TxIn.mjs';
import { Option_ThirtyTwoBytesZ } from '../structs/Option_ThirtyTwoBytesZ.mjs';
import { OutPoint } from '../structs/OutPoint.mjs';
import { ChannelDerivationParameters } from '../structs/ChannelDerivationParameters.mjs';
import { Result_HTLCDescriptorDecodeErrorZ } from '../structs/Result_HTLCDescriptorDecodeErrorZ.mjs';
import { HTLCOutputInCommitment } from '../structs/HTLCOutputInCommitment.mjs';
import { EcdsaChannelSigner } from '../structs/EcdsaChannelSigner.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A descriptor used to sign for a commitment transaction's HTLC output.
 */
export class HTLCDescriptor extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.HTLCDescriptor_free);
    }
    /**
     * The parameters required to derive the signer for the HTLC input.
     */
    get_channel_derivation_parameters() {
        const ret = bindings.HTLCDescriptor_get_channel_derivation_parameters(this.ptr);
        const ret_hu_conv = new ChannelDerivationParameters(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The parameters required to derive the signer for the HTLC input.
     */
    set_channel_derivation_parameters(val) {
        bindings.HTLCDescriptor_set_channel_derivation_parameters(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The txid of the commitment transaction in which the HTLC output lives.
     */
    get_commitment_txid() {
        const ret = bindings.HTLCDescriptor_get_commitment_txid(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The txid of the commitment transaction in which the HTLC output lives.
     */
    set_commitment_txid(val) {
        bindings.HTLCDescriptor_set_commitment_txid(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * The number of the commitment transaction in which the HTLC output lives.
     */
    get_per_commitment_number() {
        const ret = bindings.HTLCDescriptor_get_per_commitment_number(this.ptr);
        return ret;
    }
    /**
     * The number of the commitment transaction in which the HTLC output lives.
     */
    set_per_commitment_number(val) {
        bindings.HTLCDescriptor_set_per_commitment_number(this.ptr, val);
    }
    /**
     * The key tweak corresponding to the number of the commitment transaction in which the HTLC
     * output lives. This tweak is applied to all the basepoints for both parties in the channel to
     * arrive at unique keys per commitment.
     *
     * See <https://github.com/lightning/bolts/blob/master/03-transactions.md#keys> for more info.
     */
    get_per_commitment_point() {
        const ret = bindings.HTLCDescriptor_get_per_commitment_point(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The key tweak corresponding to the number of the commitment transaction in which the HTLC
     * output lives. This tweak is applied to all the basepoints for both parties in the channel to
     * arrive at unique keys per commitment.
     *
     * See <https://github.com/lightning/bolts/blob/master/03-transactions.md#keys> for more info.
     */
    set_per_commitment_point(val) {
        bindings.HTLCDescriptor_set_per_commitment_point(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 33)));
    }
    /**
     * The feerate to use on the HTLC claiming transaction. This is always `0` for HTLCs
     * originating from a channel supporting anchor outputs, otherwise it is the channel's
     * negotiated feerate at the time the commitment transaction was built.
     */
    get_feerate_per_kw() {
        const ret = bindings.HTLCDescriptor_get_feerate_per_kw(this.ptr);
        return ret;
    }
    /**
     * The feerate to use on the HTLC claiming transaction. This is always `0` for HTLCs
     * originating from a channel supporting anchor outputs, otherwise it is the channel's
     * negotiated feerate at the time the commitment transaction was built.
     */
    set_feerate_per_kw(val) {
        bindings.HTLCDescriptor_set_feerate_per_kw(this.ptr, val);
    }
    /**
     * The details of the HTLC as it appears in the commitment transaction.
     */
    get_htlc() {
        const ret = bindings.HTLCDescriptor_get_htlc(this.ptr);
        const ret_hu_conv = new HTLCOutputInCommitment(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The details of the HTLC as it appears in the commitment transaction.
     */
    set_htlc(val) {
        bindings.HTLCDescriptor_set_htlc(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The preimage, if `Some`, to claim the HTLC output with. If `None`, the timeout path must be
     * taken.
     */
    get_preimage() {
        const ret = bindings.HTLCDescriptor_get_preimage(this.ptr);
        const ret_hu_conv = Option_ThirtyTwoBytesZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The preimage, if `Some`, to claim the HTLC output with. If `None`, the timeout path must be
     * taken.
     */
    set_preimage(val) {
        bindings.HTLCDescriptor_set_preimage(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The counterparty's signature required to spend the HTLC output.
     */
    get_counterparty_sig() {
        const ret = bindings.HTLCDescriptor_get_counterparty_sig(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The counterparty's signature required to spend the HTLC output.
     */
    set_counterparty_sig(val) {
        bindings.HTLCDescriptor_set_counterparty_sig(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 64)));
    }
    /**
     * Constructs a new HTLCDescriptor given each field
     */
    static constructor_new(channel_derivation_parameters_arg, commitment_txid_arg, per_commitment_number_arg, per_commitment_point_arg, feerate_per_kw_arg, htlc_arg, preimage_arg, counterparty_sig_arg) {
        const ret = bindings.HTLCDescriptor_new(CommonBase.get_ptr_of(channel_derivation_parameters_arg), bindings.encodeUint8Array(bindings.check_arr_len(commitment_txid_arg, 32)), per_commitment_number_arg, bindings.encodeUint8Array(bindings.check_arr_len(per_commitment_point_arg, 33)), feerate_per_kw_arg, CommonBase.get_ptr_of(htlc_arg), CommonBase.get_ptr_of(preimage_arg), bindings.encodeUint8Array(bindings.check_arr_len(counterparty_sig_arg, 64)));
        const ret_hu_conv = new HTLCDescriptor(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.HTLCDescriptor_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the HTLCDescriptor
     */
    clone() {
        const ret = bindings.HTLCDescriptor_clone(this.ptr);
        const ret_hu_conv = new HTLCDescriptor(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Checks if two HTLCDescriptors contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.HTLCDescriptor_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the HTLCDescriptor object into a byte array which can be read by HTLCDescriptor_read
     */
    write() {
        const ret = bindings.HTLCDescriptor_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a HTLCDescriptor from a byte array, created by HTLCDescriptor_write
     */
    static constructor_read(ser) {
        const ret = bindings.HTLCDescriptor_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_HTLCDescriptorDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns the outpoint of the HTLC output in the commitment transaction. This is the outpoint
     * being spent by the HTLC input in the HTLC transaction.
     */
    outpoint() {
        const ret = bindings.HTLCDescriptor_outpoint(this.ptr);
        const ret_hu_conv = new OutPoint(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the UTXO to be spent by the HTLC input, which can be obtained via
     * [`Self::unsigned_tx_input`].
     */
    previous_utxo() {
        const ret = bindings.HTLCDescriptor_previous_utxo(this.ptr);
        const ret_conv = new TxOut(null, ret);
        return ret_conv;
    }
    /**
     * Returns the unsigned transaction input spending the HTLC output in the commitment
     * transaction.
     */
    unsigned_tx_input() {
        const ret = bindings.HTLCDescriptor_unsigned_tx_input(this.ptr);
        const ret_conv = new TxIn(null, ret);
        return ret_conv;
    }
    /**
     * Returns the delayed output created as a result of spending the HTLC output in the commitment
     * transaction.
     */
    tx_output() {
        const ret = bindings.HTLCDescriptor_tx_output(this.ptr);
        const ret_conv = new TxOut(null, ret);
        return ret_conv;
    }
    /**
     * Returns the witness script of the HTLC output in the commitment transaction.
     */
    witness_script() {
        const ret = bindings.HTLCDescriptor_witness_script(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the fully signed witness required to spend the HTLC output in the commitment
     * transaction.
     */
    tx_input_witness(signature, witness_script) {
        const ret = bindings.HTLCDescriptor_tx_input_witness(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(signature, 64)), bindings.encodeUint8Array(witness_script));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Derives the channel signer required to sign the HTLC input.
     */
    derive_channel_signer(signer_provider) {
        const ret = bindings.HTLCDescriptor_derive_channel_signer(this.ptr, CommonBase.get_ptr_of(signer_provider));
        const ret_hu_conv = new EcdsaChannelSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        CommonBase.add_ref_from(this, signer_provider);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=HTLCDescriptor.mjs.map