import { Option_u64Z } from '../structs/Option_u64Z.mjs';
import { Result_InFlightHtlcsDecodeErrorZ } from '../structs/Result_InFlightHtlcsDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A data structure for tracking in-flight HTLCs. May be used during pathfinding to account for
 * in-use channel liquidity.
 */
export class InFlightHtlcs extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.InFlightHtlcs_free);
    }
    clone_ptr() {
        const ret = bindings.InFlightHtlcs_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the InFlightHtlcs
     */
    clone() {
        const ret = bindings.InFlightHtlcs_clone(this.ptr);
        const ret_hu_conv = new InFlightHtlcs(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs an empty `InFlightHtlcs`.
     */
    static constructor_new() {
        const ret = bindings.InFlightHtlcs_new();
        const ret_hu_conv = new InFlightHtlcs(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Takes in a path with payer's node id and adds the path's details to `InFlightHtlcs`.
     */
    process_path(path, payer_node_id) {
        bindings.InFlightHtlcs_process_path(this.ptr, CommonBase.get_ptr_of(path), bindings.encodeUint8Array(bindings.check_arr_len(payer_node_id, 33)));
        CommonBase.add_ref_from(this, path);
    }
    /**
     * Adds a known HTLC given the public key of the HTLC source, target, and short channel
     * id.
     */
    add_inflight_htlc(source, target, channel_scid, used_msat) {
        bindings.InFlightHtlcs_add_inflight_htlc(this.ptr, CommonBase.get_ptr_of(source), CommonBase.get_ptr_of(target), channel_scid, used_msat);
        CommonBase.add_ref_from(this, source);
        CommonBase.add_ref_from(this, target);
    }
    /**
     * Returns liquidity in msat given the public key of the HTLC source, target, and short channel
     * id.
     */
    used_liquidity_msat(source, target, channel_scid) {
        const ret = bindings.InFlightHtlcs_used_liquidity_msat(this.ptr, CommonBase.get_ptr_of(source), CommonBase.get_ptr_of(target), channel_scid);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        CommonBase.add_ref_from(this, source);
        CommonBase.add_ref_from(this, target);
        return ret_hu_conv;
    }
    /**
     * Serialize the InFlightHtlcs object into a byte array which can be read by InFlightHtlcs_read
     */
    write() {
        const ret = bindings.InFlightHtlcs_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a InFlightHtlcs from a byte array, created by InFlightHtlcs_write
     */
    static constructor_read(ser) {
        const ret = bindings.InFlightHtlcs_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_InFlightHtlcsDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=InFlightHtlcs.mjs.map