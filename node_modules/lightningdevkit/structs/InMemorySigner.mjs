import { OutPoint } from '../structs/OutPoint.mjs';
import { ChannelPublicKeys } from '../structs/ChannelPublicKeys.mjs';
import { ChannelTransactionParameters } from '../structs/ChannelTransactionParameters.mjs';
import { ChannelSigner } from '../structs/ChannelSigner.mjs';
import { EcdsaChannelSigner } from '../structs/EcdsaChannelSigner.mjs';
import { Option_u16Z } from '../structs/Option_u16Z.mjs';
import { Option_boolZ } from '../structs/Option_boolZ.mjs';
import { Result_WitnessNoneZ } from '../structs/Result_WitnessNoneZ.mjs';
import { Result_InMemorySignerDecodeErrorZ } from '../structs/Result_InMemorySignerDecodeErrorZ.mjs';
import { ChannelTypeFeatures } from '../structs/ChannelTypeFeatures.mjs';
import { EntropySource } from '../structs/EntropySource.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A simple implementation of [`EcdsaChannelSigner`] that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */
export class InMemorySigner extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.InMemorySigner_free);
    }
    /**
     * Holder secret key in the 2-of-2 multisig script of a channel. This key also backs the
     * holder's anchor output in a commitment transaction, if one is present.
     */
    get_funding_key() {
        const ret = bindings.InMemorySigner_get_funding_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key in the 2-of-2 multisig script of a channel. This key also backs the
     * holder's anchor output in a commitment transaction, if one is present.
     */
    set_funding_key(val) {
        bindings.InMemorySigner_set_funding_key(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * Holder secret key for blinded revocation pubkey.
     */
    get_revocation_base_key() {
        const ret = bindings.InMemorySigner_get_revocation_base_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key for blinded revocation pubkey.
     */
    set_revocation_base_key(val) {
        bindings.InMemorySigner_set_revocation_base_key(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * Holder secret key used for our balance in counterparty-broadcasted commitment transactions.
     */
    get_payment_key() {
        const ret = bindings.InMemorySigner_get_payment_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key used for our balance in counterparty-broadcasted commitment transactions.
     */
    set_payment_key(val) {
        bindings.InMemorySigner_set_payment_key(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * Holder secret key used in an HTLC transaction.
     */
    get_delayed_payment_base_key() {
        const ret = bindings.InMemorySigner_get_delayed_payment_base_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder secret key used in an HTLC transaction.
     */
    set_delayed_payment_base_key(val) {
        bindings.InMemorySigner_set_delayed_payment_base_key(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * Holder HTLC secret key used in commitment transaction HTLC outputs.
     */
    get_htlc_base_key() {
        const ret = bindings.InMemorySigner_get_htlc_base_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Holder HTLC secret key used in commitment transaction HTLC outputs.
     */
    set_htlc_base_key(val) {
        bindings.InMemorySigner_set_htlc_base_key(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    /**
     * Commitment seed.
     */
    get_commitment_seed() {
        const ret = bindings.InMemorySigner_get_commitment_seed(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Commitment seed.
     */
    set_commitment_seed(val) {
        bindings.InMemorySigner_set_commitment_seed(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 32)));
    }
    clone_ptr() {
        const ret = bindings.InMemorySigner_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the InMemorySigner
     */
    clone() {
        const ret = bindings.InMemorySigner_clone(this.ptr);
        const ret_hu_conv = new InMemorySigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Creates a new [`InMemorySigner`].
     */
    static constructor_new(funding_key, revocation_base_key, payment_key, delayed_payment_base_key, htlc_base_key, commitment_seed, channel_value_satoshis, channel_keys_id, rand_bytes_unique_start) {
        const ret = bindings.InMemorySigner_new(bindings.encodeUint8Array(bindings.check_arr_len(funding_key, 32)), bindings.encodeUint8Array(bindings.check_arr_len(revocation_base_key, 32)), bindings.encodeUint8Array(bindings.check_arr_len(payment_key, 32)), bindings.encodeUint8Array(bindings.check_arr_len(delayed_payment_base_key, 32)), bindings.encodeUint8Array(bindings.check_arr_len(htlc_base_key, 32)), bindings.encodeUint8Array(bindings.check_arr_len(commitment_seed, 32)), channel_value_satoshis, bindings.encodeUint8Array(bindings.check_arr_len(channel_keys_id, 32)), bindings.encodeUint8Array(bindings.check_arr_len(rand_bytes_unique_start, 32)));
        const ret_hu_conv = new InMemorySigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Returns the counterparty's pubkeys.
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    counterparty_pubkeys() {
        const ret = bindings.InMemorySigner_counterparty_pubkeys(this.ptr);
        const ret_hu_conv = new ChannelPublicKeys(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the `contest_delay` value specified by our counterparty and applied on holder-broadcastable
     * transactions, i.e., the amount of time that we have to wait to recover our funds if we
     * broadcast a transaction.
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     */
    counterparty_selected_contest_delay() {
        const ret = bindings.InMemorySigner_counterparty_selected_contest_delay(this.ptr);
        const ret_hu_conv = Option_u16Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the `contest_delay` value specified by us and applied on transactions broadcastable
     * by our counterparty, i.e., the amount of time that they have to wait to recover their funds
     * if they broadcast a transaction.
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     */
    holder_selected_contest_delay() {
        const ret = bindings.InMemorySigner_holder_selected_contest_delay(this.ptr);
        const ret_hu_conv = Option_u16Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns whether the holder is the initiator.
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     */
    is_outbound() {
        const ret = bindings.InMemorySigner_is_outbound(this.ptr);
        const ret_hu_conv = Option_boolZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Funding outpoint
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    funding_outpoint() {
        const ret = bindings.InMemorySigner_funding_outpoint(this.ptr);
        const ret_hu_conv = new OutPoint(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns a [`ChannelTransactionParameters`] for this channel, to be used when verifying or
     * building transactions.
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    get_channel_parameters() {
        const ret = bindings.InMemorySigner_get_channel_parameters(this.ptr);
        const ret_hu_conv = new ChannelTransactionParameters(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the channel type features of the channel parameters. Should be helpful for
     * determining a channel's category, i. e. legacy/anchors/taproot/etc.
     *
     * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
     * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    channel_type_features() {
        const ret = bindings.InMemorySigner_channel_type_features(this.ptr);
        const ret_hu_conv = new ChannelTypeFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Sign the single input of `spend_tx` at index `input_idx`, which spends the output described
     * by `descriptor`, returning the witness stack for the input.
     *
     * Returns an error if the input at `input_idx` does not exist, has a non-empty `script_sig`,
     * is not spending the outpoint described by [`descriptor.outpoint`],
     * or if an output descriptor `script_pubkey` does not match the one we can spend.
     *
     * [`descriptor.outpoint`]: StaticPaymentOutputDescriptor::outpoint
     */
    sign_counterparty_payment_input(spend_tx, input_idx, descriptor) {
        const ret = bindings.InMemorySigner_sign_counterparty_payment_input(this.ptr, bindings.encodeUint8Array(spend_tx), input_idx, CommonBase.get_ptr_of(descriptor));
        const ret_hu_conv = Result_WitnessNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, descriptor);
        return ret_hu_conv;
    }
    /**
     * Sign the single input of `spend_tx` at index `input_idx` which spends the output
     * described by `descriptor`, returning the witness stack for the input.
     *
     * Returns an error if the input at `input_idx` does not exist, has a non-empty `script_sig`,
     * is not spending the outpoint described by [`descriptor.outpoint`], does not have a
     * sequence set to [`descriptor.to_self_delay`], or if an output descriptor
     * `script_pubkey` does not match the one we can spend.
     *
     * [`descriptor.outpoint`]: DelayedPaymentOutputDescriptor::outpoint
     * [`descriptor.to_self_delay`]: DelayedPaymentOutputDescriptor::to_self_delay
     */
    sign_dynamic_p2wsh_input(spend_tx, input_idx, descriptor) {
        const ret = bindings.InMemorySigner_sign_dynamic_p2wsh_input(this.ptr, bindings.encodeUint8Array(spend_tx), input_idx, CommonBase.get_ptr_of(descriptor));
        const ret_hu_conv = Result_WitnessNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, descriptor);
        return ret_hu_conv;
    }
    /**
     * Constructs a new EntropySource which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EntropySource must be freed before this_arg is
     */
    as_EntropySource() {
        const ret = bindings.InMemorySigner_as_EntropySource(this.ptr);
        const ret_hu_conv = new EntropySource(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new ChannelSigner which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned ChannelSigner must be freed before this_arg is
     */
    as_ChannelSigner() {
        const ret = bindings.InMemorySigner_as_ChannelSigner(this.ptr);
        const ret_hu_conv = new ChannelSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new EcdsaChannelSigner which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EcdsaChannelSigner must be freed before this_arg is
     */
    as_EcdsaChannelSigner() {
        const ret = bindings.InMemorySigner_as_EcdsaChannelSigner(this.ptr);
        const ret_hu_conv = new EcdsaChannelSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
     */
    write() {
        const ret = bindings.InMemorySigner_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a InMemorySigner from a byte array, created by InMemorySigner_write
     */
    static constructor_read(ser, arg) {
        const ret = bindings.InMemorySigner_read(bindings.encodeUint8Array(ser), CommonBase.get_ptr_of(arg));
        const ret_hu_conv = Result_InMemorySignerDecodeErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, arg);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=InMemorySigner.mjs.map