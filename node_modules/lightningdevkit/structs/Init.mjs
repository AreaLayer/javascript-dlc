import { Option_CVec_ThirtyTwoBytesZZ } from '../structs/Option_CVec_ThirtyTwoBytesZZ.mjs';
import { InitFeatures } from '../structs/InitFeatures.mjs';
import { Option_SocketAddressZ } from '../structs/Option_SocketAddressZ.mjs';
import { Result_InitDecodeErrorZ } from '../structs/Result_InitDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * An [`init`] message to be sent to or received from a peer.
 *
 * [`init`]: https://github.com/lightning/bolts/blob/master/01-messaging.md#the-init-message
 */
export class Init extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.Init_free);
    }
    /**
     * The relevant features which the sender supports.
     */
    get_features() {
        const ret = bindings.Init_get_features(this.ptr);
        const ret_hu_conv = new InitFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The relevant features which the sender supports.
     */
    set_features(val) {
        bindings.Init_set_features(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * Indicates chains the sender is interested in.
     *
     * If there are no common chains, the connection will be closed.
     *
     * Returns a copy of the field.
     */
    get_networks() {
        const ret = bindings.Init_get_networks(this.ptr);
        const ret_hu_conv = Option_CVec_ThirtyTwoBytesZZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Indicates chains the sender is interested in.
     *
     * If there are no common chains, the connection will be closed.
     */
    set_networks(val) {
        bindings.Init_set_networks(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The receipient's network address.
     *
     * This adds the option to report a remote IP address back to a connecting peer using the init
     * message. A node can decide to use that information to discover a potential update to its
     * public IPv4 address (NAT) and use that for a [`NodeAnnouncement`] update message containing
     * the new address.
     */
    get_remote_network_address() {
        const ret = bindings.Init_get_remote_network_address(this.ptr);
        const ret_hu_conv = Option_SocketAddressZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The receipient's network address.
     *
     * This adds the option to report a remote IP address back to a connecting peer using the init
     * message. A node can decide to use that information to discover a potential update to its
     * public IPv4 address (NAT) and use that for a [`NodeAnnouncement`] update message containing
     * the new address.
     */
    set_remote_network_address(val) {
        bindings.Init_set_remote_network_address(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * Constructs a new Init given each field
     */
    static constructor_new(features_arg, networks_arg, remote_network_address_arg) {
        const ret = bindings.Init_new(CommonBase.get_ptr_of(features_arg), CommonBase.get_ptr_of(networks_arg), CommonBase.get_ptr_of(remote_network_address_arg));
        const ret_hu_conv = new Init(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.Init_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Init
     */
    clone() {
        const ret = bindings.Init_clone(this.ptr);
        const ret_hu_conv = new Init(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the Init.
     */
    hash() {
        const ret = bindings.Init_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two Inits contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.Init_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Serialize the Init object into a byte array which can be read by Init_read
     */
    write() {
        const ret = bindings.Init_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Init from a byte array, created by Init_write
     */
    static constructor_read(ser) {
        const ret = bindings.Init_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_InitDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=Init.mjs.map