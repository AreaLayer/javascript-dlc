import { Result_NoneBolt12SemanticErrorZ } from '../structs/Result_NoneBolt12SemanticErrorZ.mjs';
import { Result_UnsignedInvoiceRequestBolt12SemanticErrorZ } from '../structs/Result_UnsignedInvoiceRequestBolt12SemanticErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Builds an [`InvoiceRequest`] from an [`Offer`] for the \"offer to be paid\" flow.
 *
 * See [module-level documentation] for usage.
 *
 * [module-level documentation]: self
 */
export class InvoiceRequestWithExplicitPayerIdBuilder extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.InvoiceRequestWithExplicitPayerIdBuilder_free);
    }
    /**
     * Builds an unsigned [`InvoiceRequest`] after checking for valid semantics. It can be signed
     * by [`UnsignedInvoiceRequest::sign`].
     */
    build() {
        const ret = bindings.InvoiceRequestWithExplicitPayerIdBuilder_build(this.ptr);
        const ret_hu_conv = Result_UnsignedInvoiceRequestBolt12SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Sets the [`InvoiceRequest::chain`] of the given [`Network`] for paying an invoice. If not
     * called, [`Network::Bitcoin`] is assumed. Errors if the chain for `network` is not supported
     * by the offer.
     *
     * Successive calls to this method will override the previous setting.
     */
    chain(network) {
        const ret = bindings.InvoiceRequestWithExplicitPayerIdBuilder_chain(this.ptr, network);
        const ret_hu_conv = Result_NoneBolt12SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Sets the [`InvoiceRequest::amount_msats`] for paying an invoice. Errors if `amount_msats` is
     * not at least the expected invoice amount (i.e., [`Offer::amount`] times [`quantity`]).
     *
     * Successive calls to this method will override the previous setting.
     *
     * [`quantity`]: Self::quantity
     */
    amount_msats(amount_msats) {
        const ret = bindings.InvoiceRequestWithExplicitPayerIdBuilder_amount_msats(this.ptr, amount_msats);
        const ret_hu_conv = Result_NoneBolt12SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Sets [`InvoiceRequest::quantity`] of items. If not set, `1` is assumed. Errors if `quantity`
     * does not conform to [`Offer::is_valid_quantity`].
     *
     * Successive calls to this method will override the previous setting.
     */
    quantity(quantity) {
        const ret = bindings.InvoiceRequestWithExplicitPayerIdBuilder_quantity(this.ptr, quantity);
        const ret_hu_conv = Result_NoneBolt12SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Sets the [`InvoiceRequest::payer_note`].
     *
     * Successive calls to this method will override the previous setting.
     */
    payer_note(payer_note) {
        bindings.InvoiceRequestWithExplicitPayerIdBuilder_payer_note(this.ptr, bindings.encodeString(payer_note));
    }
}
//# sourceMappingURL=InvoiceRequestWithExplicitPayerIdBuilder.mjs.map