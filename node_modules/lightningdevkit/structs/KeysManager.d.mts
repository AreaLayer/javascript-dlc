import { SpendableOutputDescriptor } from '../structs/SpendableOutputDescriptor.mjs';
import { Result_CVec_u8ZNoneZ } from '../structs/Result_CVec_u8ZNoneZ.mjs';
import { InMemorySigner } from '../structs/InMemorySigner.mjs';
import { EntropySource } from '../structs/EntropySource.mjs';
import { NodeSigner } from '../structs/NodeSigner.mjs';
import { SignerProvider } from '../structs/SignerProvider.mjs';
import { OutputSpender } from '../structs/OutputSpender.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * Simple implementation of [`EntropySource`], [`NodeSigner`], and [`SignerProvider`] that takes a
 * 32-byte seed for use as a BIP 32 extended key and derives keys from that.
 *
 * Your `node_id` is seed/0'.
 * Unilateral closes may use seed/1'.
 * Cooperative closes may use seed/2'.
 * The two close keys may be needed to claim on-chain funds!
 *
 * This struct cannot be used for nodes that wish to support receiving phantom payments;
 * [`PhantomKeysManager`] must be used instead.
 *
 * Note that switching between this struct and [`PhantomKeysManager`] will invalidate any
 * previously issued invoices and attempts to pay previous invoices will fail.
 */
export declare class KeysManager extends CommonBase {
    /**
     * Constructs a [`KeysManager`] from a 32-byte seed. If the seed is in some way biased (e.g.,
     * your CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
     * `starting_time` isn't strictly required to actually be a time, but it must absolutely,
     * without a doubt, be unique to this instance. ie if you start multiple times with the same
     * `seed`, `starting_time` must be unique to each run. Thus, the easiest way to achieve this
     * is to simply use the current time (with very high precision).
     *
     * The `seed` MUST be backed up safely prior to use so that the keys can be re-created, however,
     * obviously, `starting_time` should be unique every time you reload the library - it is only
     * used to generate new ephemeral key data (which will be stored by the individual channel if
     * necessary).
     *
     * Note that the seed is required to recover certain on-chain funds independent of
     * [`ChannelMonitor`] data, though a current copy of [`ChannelMonitor`] data is also required
     * for any channel, and some on-chain during-closing funds.
     *
     * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
     */
    static constructor_new(seed: Uint8Array, starting_time_secs: bigint, starting_time_nanos: number): KeysManager;
    /**
     * Gets the \"node_id\" secret key used to sign gossip announcements, decode onion data, etc.
     */
    get_node_secret_key(): Uint8Array;
    /**
     * Derive an old [`EcdsaChannelSigner`] containing per-channel secrets based on a key derivation parameters.
     */
    derive_channel_keys(channel_value_satoshis: bigint, params: Uint8Array): InMemorySigner;
    /**
     * Signs the given [`Psbt`] which spends the given [`SpendableOutputDescriptor`]s.
     * The resulting inputs will be finalized and the PSBT will be ready for broadcast if there
     * are no other inputs that need signing.
     *
     * Returns `Err(())` if the PSBT is missing a descriptor or if we fail to sign.
     *
     * May panic if the [`SpendableOutputDescriptor`]s were not generated by channels which used
     * this [`KeysManager`] or one of the [`InMemorySigner`] created by this [`KeysManager`].
     */
    sign_spendable_outputs_psbt(descriptors: SpendableOutputDescriptor[], psbt: Uint8Array): Result_CVec_u8ZNoneZ;
    /**
     * Constructs a new EntropySource which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EntropySource must be freed before this_arg is
     */
    as_EntropySource(): EntropySource;
    /**
     * Constructs a new NodeSigner which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned NodeSigner must be freed before this_arg is
     */
    as_NodeSigner(): NodeSigner;
    /**
     * Constructs a new OutputSpender which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned OutputSpender must be freed before this_arg is
     */
    as_OutputSpender(): OutputSpender;
    /**
     * Constructs a new SignerProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned SignerProvider must be freed before this_arg is
     */
    as_SignerProvider(): SignerProvider;
}
