import { Result_CVec_u8ZNoneZ } from '../structs/Result_CVec_u8ZNoneZ.mjs';
import { InMemorySigner } from '../structs/InMemorySigner.mjs';
import { EntropySource } from '../structs/EntropySource.mjs';
import { NodeSigner } from '../structs/NodeSigner.mjs';
import { SignerProvider } from '../structs/SignerProvider.mjs';
import { OutputSpender } from '../structs/OutputSpender.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Simple implementation of [`EntropySource`], [`NodeSigner`], and [`SignerProvider`] that takes a
 * 32-byte seed for use as a BIP 32 extended key and derives keys from that.
 *
 * Your `node_id` is seed/0'.
 * Unilateral closes may use seed/1'.
 * Cooperative closes may use seed/2'.
 * The two close keys may be needed to claim on-chain funds!
 *
 * This struct cannot be used for nodes that wish to support receiving phantom payments;
 * [`PhantomKeysManager`] must be used instead.
 *
 * Note that switching between this struct and [`PhantomKeysManager`] will invalidate any
 * previously issued invoices and attempts to pay previous invoices will fail.
 */
export class KeysManager extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.KeysManager_free);
    }
    /**
     * Constructs a [`KeysManager`] from a 32-byte seed. If the seed is in some way biased (e.g.,
     * your CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
     * `starting_time` isn't strictly required to actually be a time, but it must absolutely,
     * without a doubt, be unique to this instance. ie if you start multiple times with the same
     * `seed`, `starting_time` must be unique to each run. Thus, the easiest way to achieve this
     * is to simply use the current time (with very high precision).
     *
     * The `seed` MUST be backed up safely prior to use so that the keys can be re-created, however,
     * obviously, `starting_time` should be unique every time you reload the library - it is only
     * used to generate new ephemeral key data (which will be stored by the individual channel if
     * necessary).
     *
     * Note that the seed is required to recover certain on-chain funds independent of
     * [`ChannelMonitor`] data, though a current copy of [`ChannelMonitor`] data is also required
     * for any channel, and some on-chain during-closing funds.
     *
     * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
     */
    static constructor_new(seed, starting_time_secs, starting_time_nanos) {
        const ret = bindings.KeysManager_new(bindings.encodeUint8Array(bindings.check_arr_len(seed, 32)), starting_time_secs, starting_time_nanos);
        const ret_hu_conv = new KeysManager(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Gets the \"node_id\" secret key used to sign gossip announcements, decode onion data, etc.
     */
    get_node_secret_key() {
        const ret = bindings.KeysManager_get_node_secret_key(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Derive an old [`EcdsaChannelSigner`] containing per-channel secrets based on a key derivation parameters.
     */
    derive_channel_keys(channel_value_satoshis, params) {
        const ret = bindings.KeysManager_derive_channel_keys(this.ptr, channel_value_satoshis, bindings.encodeUint8Array(bindings.check_arr_len(params, 32)));
        const ret_hu_conv = new InMemorySigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Signs the given [`Psbt`] which spends the given [`SpendableOutputDescriptor`]s.
     * The resulting inputs will be finalized and the PSBT will be ready for broadcast if there
     * are no other inputs that need signing.
     *
     * Returns `Err(())` if the PSBT is missing a descriptor or if we fail to sign.
     *
     * May panic if the [`SpendableOutputDescriptor`]s were not generated by channels which used
     * this [`KeysManager`] or one of the [`InMemorySigner`] created by this [`KeysManager`].
     */
    sign_spendable_outputs_psbt(descriptors, psbt) {
        const ret = bindings.KeysManager_sign_spendable_outputs_psbt(this.ptr, bindings.encodeUint64Array(descriptors.map(descriptors_conv_27 => CommonBase.get_ptr_of(descriptors_conv_27))), bindings.encodeUint8Array(psbt));
        const ret_hu_conv = Result_CVec_u8ZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Constructs a new EntropySource which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned EntropySource must be freed before this_arg is
     */
    as_EntropySource() {
        const ret = bindings.KeysManager_as_EntropySource(this.ptr);
        const ret_hu_conv = new EntropySource(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new NodeSigner which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned NodeSigner must be freed before this_arg is
     */
    as_NodeSigner() {
        const ret = bindings.KeysManager_as_NodeSigner(this.ptr);
        const ret_hu_conv = new NodeSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new OutputSpender which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned OutputSpender must be freed before this_arg is
     */
    as_OutputSpender() {
        const ret = bindings.KeysManager_as_OutputSpender(this.ptr);
        const ret_hu_conv = new OutputSpender(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new SignerProvider which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned SignerProvider must be freed before this_arg is
     */
    as_SignerProvider() {
        const ret = bindings.KeysManager_as_SignerProvider(this.ptr);
        const ret_hu_conv = new SignerProvider(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=KeysManager.mjs.map