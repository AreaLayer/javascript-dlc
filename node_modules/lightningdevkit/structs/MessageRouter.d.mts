import { Result_OnionMessagePathNoneZ } from '../structs/Result_OnionMessagePathNoneZ.mjs';
import { Result_CVec_BlindedMessagePathZNoneZ } from '../structs/Result_CVec_BlindedMessagePathZNoneZ.mjs';
import { MessageForwardNode } from '../structs/MessageForwardNode.mjs';
import { Destination } from '../structs/Destination.mjs';
import { MessageContext } from '../structs/MessageContext.mjs';
import { CommonBase } from './CommonBase.mjs';
/** An implementation of MessageRouter */
export interface MessageRouterInterface {
    /**Returns a route for sending an [`OnionMessage`] to the given [`Destination`].
     */
    find_path(sender: Uint8Array, peers: Uint8Array[], destination: Destination): Result_OnionMessagePathNoneZ;
    /**Creates [`BlindedMessagePath`]s to the `recipient` node. The nodes in `peers` are assumed to
     * be direct peers with the `recipient`.
     */
    create_blinded_paths(recipient: Uint8Array, context: MessageContext, peers: Uint8Array[]): Result_CVec_BlindedMessagePathZNoneZ;
    /**Creates compact [`BlindedMessagePath`]s to the `recipient` node. The nodes in `peers` are
     * assumed to be direct peers with the `recipient`.
     *
     * Compact blinded paths use short channel ids instead of pubkeys for a smaller serialization,
     * which is beneficial when a QR code is used to transport the data. The SCID is passed using
     * a [`MessageForwardNode`] but may be `None` for graceful degradation.
     *
     * Implementations using additional intermediate nodes are responsible for using a
     * [`MessageForwardNode`] with `Some` short channel id, if possible. Similarly, implementations
     * should call [`BlindedMessagePath::use_compact_introduction_node`].
     *
     * The provided implementation simply delegates to [`MessageRouter::create_blinded_paths`],
     * ignoring the short channel ids.
     */
    create_compact_blinded_paths(recipient: Uint8Array, context: MessageContext, peers: MessageForwardNode[]): Result_CVec_BlindedMessagePathZNoneZ;
}
/**
 * A trait defining behavior for routing an [`OnionMessage`].
 */
export declare class MessageRouter extends CommonBase {
    /** Creates a new instance of MessageRouter from a given implementation */
    static new_impl(arg: MessageRouterInterface): MessageRouter;
    /**
     * Returns a route for sending an [`OnionMessage`] to the given [`Destination`].
     */
    find_path(sender: Uint8Array, peers: Uint8Array[], destination: Destination): Result_OnionMessagePathNoneZ;
    /**
     * Creates [`BlindedMessagePath`]s to the `recipient` node. The nodes in `peers` are assumed to
     * be direct peers with the `recipient`.
     */
    create_blinded_paths(recipient: Uint8Array, context: MessageContext, peers: Uint8Array[]): Result_CVec_BlindedMessagePathZNoneZ;
    /**
     * Creates compact [`BlindedMessagePath`]s to the `recipient` node. The nodes in `peers` are
     * assumed to be direct peers with the `recipient`.
     *
     * Compact blinded paths use short channel ids instead of pubkeys for a smaller serialization,
     * which is beneficial when a QR code is used to transport the data. The SCID is passed using
     * a [`MessageForwardNode`] but may be `None` for graceful degradation.
     *
     * Implementations using additional intermediate nodes are responsible for using a
     * [`MessageForwardNode`] with `Some` short channel id, if possible. Similarly, implementations
     * should call [`BlindedMessagePath::use_compact_introduction_node`].
     *
     * The provided implementation simply delegates to [`MessageRouter::create_blinded_paths`],
     * ignoring the short channel ids.
     */
    create_compact_blinded_paths(recipient: Uint8Array, context: MessageContext, peers: MessageForwardNode[]): Result_CVec_BlindedMessagePathZNoneZ;
}
