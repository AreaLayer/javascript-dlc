import { Result_OnionMessagePathNoneZ } from '../structs/Result_OnionMessagePathNoneZ.mjs';
import { Result_CVec_BlindedMessagePathZNoneZ } from '../structs/Result_CVec_BlindedMessagePathZNoneZ.mjs';
import { MessageForwardNode } from '../structs/MessageForwardNode.mjs';
import { Destination } from '../structs/Destination.mjs';
import { MessageContext } from '../structs/MessageContext.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKMessageRouterHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait defining behavior for routing an [`OnionMessage`].
 */
export class MessageRouter extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.MessageRouter_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of MessageRouter from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKMessageRouterHolder();
        let structImplementation = {
            find_path(sender, peers, destination) {
                const sender_conv = bindings.decodeUint8Array(sender);
                const peers_conv_12_len = bindings.getArrayLength(peers);
                const peers_conv_12_arr = new Array(peers_conv_12_len).fill(null);
                for (var m = 0; m < peers_conv_12_len; m++) {
                    const peers_conv_12 = bindings.getU32ArrayElem(peers, m);
                    const peers_conv_12_conv = bindings.decodeUint8Array(peers_conv_12);
                    peers_conv_12_arr[m] = peers_conv_12_conv;
                }
                bindings.freeWasmMemory(peers);
                const destination_hu_conv = Destination.constr_from_ptr(destination);
                CommonBase.add_ref_from(destination_hu_conv, this);
                const ret = arg.find_path(sender_conv, peers_conv_12_arr, destination_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            create_blinded_paths(recipient, context, peers) {
                const recipient_conv = bindings.decodeUint8Array(recipient);
                const context_hu_conv = MessageContext.constr_from_ptr(context);
                CommonBase.add_ref_from(context_hu_conv, this);
                const peers_conv_12_len = bindings.getArrayLength(peers);
                const peers_conv_12_arr = new Array(peers_conv_12_len).fill(null);
                for (var m = 0; m < peers_conv_12_len; m++) {
                    const peers_conv_12 = bindings.getU32ArrayElem(peers, m);
                    const peers_conv_12_conv = bindings.decodeUint8Array(peers_conv_12);
                    peers_conv_12_arr[m] = peers_conv_12_conv;
                }
                bindings.freeWasmMemory(peers);
                const ret = arg.create_blinded_paths(recipient_conv, context_hu_conv, peers_conv_12_arr);
                const result = ret.clone_ptr();
                return result;
            },
            create_compact_blinded_paths(recipient, context, peers) {
                const recipient_conv = bindings.decodeUint8Array(recipient);
                const context_hu_conv = MessageContext.constr_from_ptr(context);
                CommonBase.add_ref_from(context_hu_conv, this);
                const peers_conv_20_len = bindings.getArrayLength(peers);
                const peers_conv_20_arr = new Array(peers_conv_20_len).fill(null);
                for (var u = 0; u < peers_conv_20_len; u++) {
                    const peers_conv_20 = bindings.getU64ArrayElem(peers, u);
                    const peers_conv_20_hu_conv = new MessageForwardNode(null, peers_conv_20);
                    CommonBase.add_ref_from(peers_conv_20_hu_conv, this);
                    peers_conv_20_arr[u] = peers_conv_20_hu_conv;
                }
                bindings.freeWasmMemory(peers);
                const ret = arg.create_compact_blinded_paths(recipient_conv, context_hu_conv, peers_conv_20_arr);
                const result = ret.clone_ptr();
                return result;
            },
        };
        const ptr_idx = bindings.LDKMessageRouter_new(structImplementation);
        impl_holder.held = new MessageRouter(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns a route for sending an [`OnionMessage`] to the given [`Destination`].
     */
    find_path(sender, peers, destination) {
        const ret = bindings.MessageRouter_find_path(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(sender, 33)), bindings.encodeUint32Array(peers.map(peers_conv_12 => bindings.encodeUint8Array(bindings.check_arr_len(peers_conv_12, 33)))), CommonBase.get_ptr_of(destination));
        const ret_hu_conv = Result_OnionMessagePathNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates [`BlindedMessagePath`]s to the `recipient` node. The nodes in `peers` are assumed to
     * be direct peers with the `recipient`.
     */
    create_blinded_paths(recipient, context, peers) {
        const ret = bindings.MessageRouter_create_blinded_paths(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(recipient, 33)), CommonBase.get_ptr_of(context), bindings.encodeUint32Array(peers.map(peers_conv_12 => bindings.encodeUint8Array(bindings.check_arr_len(peers_conv_12, 33)))));
        const ret_hu_conv = Result_CVec_BlindedMessagePathZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates compact [`BlindedMessagePath`]s to the `recipient` node. The nodes in `peers` are
     * assumed to be direct peers with the `recipient`.
     *
     * Compact blinded paths use short channel ids instead of pubkeys for a smaller serialization,
     * which is beneficial when a QR code is used to transport the data. The SCID is passed using
     * a [`MessageForwardNode`] but may be `None` for graceful degradation.
     *
     * Implementations using additional intermediate nodes are responsible for using a
     * [`MessageForwardNode`] with `Some` short channel id, if possible. Similarly, implementations
     * should call [`BlindedMessagePath::use_compact_introduction_node`].
     *
     * The provided implementation simply delegates to [`MessageRouter::create_blinded_paths`],
     * ignoring the short channel ids.
     */
    create_compact_blinded_paths(recipient, context, peers) {
        const ret = bindings.MessageRouter_create_compact_blinded_paths(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(recipient, 33)), CommonBase.get_ptr_of(context), bindings.encodeUint64Array(peers.map(peers_conv_20 => CommonBase.get_ptr_of(peers_conv_20))));
        const ret_hu_conv = Result_CVec_BlindedMessagePathZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=MessageRouter.mjs.map