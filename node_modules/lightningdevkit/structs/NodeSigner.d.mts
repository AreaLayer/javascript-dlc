import { Recipient } from '../enums/Recipient.mjs';
import { UnsignedBolt12Invoice } from '../structs/UnsignedBolt12Invoice.mjs';
import { Result_SchnorrSignatureNoneZ } from '../structs/Result_SchnorrSignatureNoneZ.mjs';
import { Result_ThirtyTwoBytesNoneZ } from '../structs/Result_ThirtyTwoBytesNoneZ.mjs';
import { Result_PublicKeyNoneZ } from '../structs/Result_PublicKeyNoneZ.mjs';
import { Option_BigEndianScalarZ } from '../structs/Option_BigEndianScalarZ.mjs';
import { Result_RecoverableSignatureNoneZ } from '../structs/Result_RecoverableSignatureNoneZ.mjs';
import { Result_ECDSASignatureNoneZ } from '../structs/Result_ECDSASignatureNoneZ.mjs';
import { RawBolt11Invoice } from '../structs/RawBolt11Invoice.mjs';
import { UnsignedInvoiceRequest } from '../structs/UnsignedInvoiceRequest.mjs';
import { UnsignedGossipMessage } from '../structs/UnsignedGossipMessage.mjs';
import { CommonBase } from './CommonBase.mjs';
/** An implementation of NodeSigner */
export interface NodeSignerInterface {
    /**Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
     *
     * If the implementor of this trait supports [phantom node payments], then every node that is
     * intended to be included in the phantom invoice route hints must return the same value from
     * this method.
     *
     * This method must return the same value each time it is called.
     *
     * [phantom node payments]: PhantomKeysManager
     */
    get_inbound_payment_key_material(): Uint8Array;
    /**Get node id based on the provided [`Recipient`].
     *
     * This method must return the same value each time it is called with a given [`Recipient`]
     * parameter.
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    get_node_id(recipient: Recipient): Result_PublicKeyNoneZ;
    /**Gets the ECDH shared secret of our node secret and `other_key`, multiplying by `tweak` if
     * one is provided. Note that this tweak can be applied to `other_key` instead of our node
     * secret, though this is less efficient.
     *
     * Note that if this fails while attempting to forward an HTLC, LDK will panic. The error
     * should be resolved to allow LDK to resume forwarding HTLCs.
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    ecdh(recipient: Recipient, other_key: Uint8Array, tweak: Option_BigEndianScalarZ): Result_ThirtyTwoBytesNoneZ;
    /**Sign an invoice.
     *
     * By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
     * this trait to parse the invoice and make sure they're signing what they expect, rather than
     * blindly signing the hash.
     *
     * The `hrp_bytes` are ASCII bytes, while the `invoice_data` is base32.
     *
     * The secret key used to sign the invoice is dependent on the [`Recipient`].
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    sign_invoice(invoice: RawBolt11Invoice, recipient: Recipient): Result_RecoverableSignatureNoneZ;
    /**Signs the [`TaggedHash`] of a BOLT 12 invoice request.
     *
     * May be called by a function passed to [`UnsignedInvoiceRequest::sign`] where
     * `invoice_request` is the callee.
     *
     * Implementors may check that the `invoice_request` is expected rather than blindly signing
     * the tagged hash. An `Ok` result should sign `invoice_request.tagged_hash().as_digest()` with
     * the node's signing key or an ephemeral key to preserve privacy, whichever is associated with
     * [`UnsignedInvoiceRequest::payer_id`].
     *
     * [`TaggedHash`]: crate::offers::merkle::TaggedHash
     */
    sign_bolt12_invoice_request(invoice_request: UnsignedInvoiceRequest): Result_SchnorrSignatureNoneZ;
    /**Signs the [`TaggedHash`] of a BOLT 12 invoice.
     *
     * May be called by a function passed to [`UnsignedBolt12Invoice::sign`] where `invoice` is the
     * callee.
     *
     * Implementors may check that the `invoice` is expected rather than blindly signing the tagged
     * hash. An `Ok` result should sign `invoice.tagged_hash().as_digest()` with the node's signing
     * key or an ephemeral key to preserve privacy, whichever is associated with
     * [`UnsignedBolt12Invoice::signing_pubkey`].
     *
     * [`TaggedHash`]: crate::offers::merkle::TaggedHash
     */
    sign_bolt12_invoice(invoice: UnsignedBolt12Invoice): Result_SchnorrSignatureNoneZ;
    /**Sign a gossip message.
     *
     * Note that if this fails, LDK may panic and the message will not be broadcast to the network
     * or a possible channel counterparty. If LDK panics, the error should be resolved to allow the
     * message to be broadcast, as otherwise it may prevent one from receiving funds over the
     * corresponding channel.
     */
    sign_gossip_message(msg: UnsignedGossipMessage): Result_ECDSASignatureNoneZ;
}
/**
 * A trait that can handle cryptographic operations at the scope level of a node.
 */
export declare class NodeSigner extends CommonBase {
    /** Creates a new instance of NodeSigner from a given implementation */
    static new_impl(arg: NodeSignerInterface): NodeSigner;
    /**
     * Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
     *
     * If the implementor of this trait supports [phantom node payments], then every node that is
     * intended to be included in the phantom invoice route hints must return the same value from
     * this method.
     *
     * This method must return the same value each time it is called.
     *
     * [phantom node payments]: PhantomKeysManager
     */
    get_inbound_payment_key_material(): Uint8Array;
    /**
     * Get node id based on the provided [`Recipient`].
     *
     * This method must return the same value each time it is called with a given [`Recipient`]
     * parameter.
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    get_node_id(recipient: Recipient): Result_PublicKeyNoneZ;
    /**
     * Gets the ECDH shared secret of our node secret and `other_key`, multiplying by `tweak` if
     * one is provided. Note that this tweak can be applied to `other_key` instead of our node
     * secret, though this is less efficient.
     *
     * Note that if this fails while attempting to forward an HTLC, LDK will panic. The error
     * should be resolved to allow LDK to resume forwarding HTLCs.
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    ecdh(recipient: Recipient, other_key: Uint8Array, tweak: Option_BigEndianScalarZ): Result_ThirtyTwoBytesNoneZ;
    /**
     * Sign an invoice.
     *
     * By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
     * this trait to parse the invoice and make sure they're signing what they expect, rather than
     * blindly signing the hash.
     *
     * The `hrp_bytes` are ASCII bytes, while the `invoice_data` is base32.
     *
     * The secret key used to sign the invoice is dependent on the [`Recipient`].
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    sign_invoice(invoice: RawBolt11Invoice, recipient: Recipient): Result_RecoverableSignatureNoneZ;
    /**
     * Signs the [`TaggedHash`] of a BOLT 12 invoice request.
     *
     * May be called by a function passed to [`UnsignedInvoiceRequest::sign`] where
     * `invoice_request` is the callee.
     *
     * Implementors may check that the `invoice_request` is expected rather than blindly signing
     * the tagged hash. An `Ok` result should sign `invoice_request.tagged_hash().as_digest()` with
     * the node's signing key or an ephemeral key to preserve privacy, whichever is associated with
     * [`UnsignedInvoiceRequest::payer_id`].
     *
     * [`TaggedHash`]: crate::offers::merkle::TaggedHash
     */
    sign_bolt12_invoice_request(invoice_request: UnsignedInvoiceRequest): Result_SchnorrSignatureNoneZ;
    /**
     * Signs the [`TaggedHash`] of a BOLT 12 invoice.
     *
     * May be called by a function passed to [`UnsignedBolt12Invoice::sign`] where `invoice` is the
     * callee.
     *
     * Implementors may check that the `invoice` is expected rather than blindly signing the tagged
     * hash. An `Ok` result should sign `invoice.tagged_hash().as_digest()` with the node's signing
     * key or an ephemeral key to preserve privacy, whichever is associated with
     * [`UnsignedBolt12Invoice::signing_pubkey`].
     *
     * [`TaggedHash`]: crate::offers::merkle::TaggedHash
     */
    sign_bolt12_invoice(invoice: UnsignedBolt12Invoice): Result_SchnorrSignatureNoneZ;
    /**
     * Sign a gossip message.
     *
     * Note that if this fails, LDK may panic and the message will not be broadcast to the network
     * or a possible channel counterparty. If LDK panics, the error should be resolved to allow the
     * message to be broadcast, as otherwise it may prevent one from receiving funds over the
     * corresponding channel.
     */
    sign_gossip_message(msg: UnsignedGossipMessage): Result_ECDSASignatureNoneZ;
}
