import { UnsignedBolt12Invoice } from '../structs/UnsignedBolt12Invoice.mjs';
import { Result_SchnorrSignatureNoneZ } from '../structs/Result_SchnorrSignatureNoneZ.mjs';
import { Result_ThirtyTwoBytesNoneZ } from '../structs/Result_ThirtyTwoBytesNoneZ.mjs';
import { Result_PublicKeyNoneZ } from '../structs/Result_PublicKeyNoneZ.mjs';
import { Option_BigEndianScalarZ } from '../structs/Option_BigEndianScalarZ.mjs';
import { Result_RecoverableSignatureNoneZ } from '../structs/Result_RecoverableSignatureNoneZ.mjs';
import { Result_ECDSASignatureNoneZ } from '../structs/Result_ECDSASignatureNoneZ.mjs';
import { RawBolt11Invoice } from '../structs/RawBolt11Invoice.mjs';
import { UnsignedInvoiceRequest } from '../structs/UnsignedInvoiceRequest.mjs';
import { UnsignedGossipMessage } from '../structs/UnsignedGossipMessage.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKNodeSignerHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait that can handle cryptographic operations at the scope level of a node.
 */
export class NodeSigner extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.NodeSigner_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of NodeSigner from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKNodeSignerHolder();
        let structImplementation = {
            get_inbound_payment_key_material() {
                const ret = arg.get_inbound_payment_key_material();
                const result = bindings.encodeUint8Array(bindings.check_arr_len(ret, 32));
                return result;
            },
            get_node_id(recipient) {
                const ret = arg.get_node_id(recipient);
                const result = ret.clone_ptr();
                return result;
            },
            ecdh(recipient, other_key, tweak) {
                const other_key_conv = bindings.decodeUint8Array(other_key);
                const tweak_hu_conv = Option_BigEndianScalarZ.constr_from_ptr(tweak);
                CommonBase.add_ref_from(tweak_hu_conv, this);
                const ret = arg.ecdh(recipient, other_key_conv, tweak_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_invoice(invoice, recipient) {
                const invoice_hu_conv = new RawBolt11Invoice(null, invoice);
                const ret = arg.sign_invoice(invoice_hu_conv, recipient);
                const result = ret.clone_ptr();
                return result;
            },
            sign_bolt12_invoice_request(invoice_request) {
                const invoice_request_hu_conv = new UnsignedInvoiceRequest(null, invoice_request);
                const ret = arg.sign_bolt12_invoice_request(invoice_request_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_bolt12_invoice(invoice) {
                const invoice_hu_conv = new UnsignedBolt12Invoice(null, invoice);
                const ret = arg.sign_bolt12_invoice(invoice_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            sign_gossip_message(msg) {
                const msg_hu_conv = UnsignedGossipMessage.constr_from_ptr(msg);
                CommonBase.add_ref_from(msg_hu_conv, this);
                const ret = arg.sign_gossip_message(msg_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
        };
        const ptr_idx = bindings.LDKNodeSigner_new(structImplementation);
        impl_holder.held = new NodeSigner(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
     *
     * If the implementor of this trait supports [phantom node payments], then every node that is
     * intended to be included in the phantom invoice route hints must return the same value from
     * this method.
     *
     * This method must return the same value each time it is called.
     *
     * [phantom node payments]: PhantomKeysManager
     */
    get_inbound_payment_key_material() {
        const ret = bindings.NodeSigner_get_inbound_payment_key_material(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Get node id based on the provided [`Recipient`].
     *
     * This method must return the same value each time it is called with a given [`Recipient`]
     * parameter.
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    get_node_id(recipient) {
        const ret = bindings.NodeSigner_get_node_id(this.ptr, recipient);
        const ret_hu_conv = Result_PublicKeyNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets the ECDH shared secret of our node secret and `other_key`, multiplying by `tweak` if
     * one is provided. Note that this tweak can be applied to `other_key` instead of our node
     * secret, though this is less efficient.
     *
     * Note that if this fails while attempting to forward an HTLC, LDK will panic. The error
     * should be resolved to allow LDK to resume forwarding HTLCs.
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    ecdh(recipient, other_key, tweak) {
        const ret = bindings.NodeSigner_ecdh(this.ptr, recipient, bindings.encodeUint8Array(bindings.check_arr_len(other_key, 33)), CommonBase.get_ptr_of(tweak));
        const ret_hu_conv = Result_ThirtyTwoBytesNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Sign an invoice.
     *
     * By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
     * this trait to parse the invoice and make sure they're signing what they expect, rather than
     * blindly signing the hash.
     *
     * The `hrp_bytes` are ASCII bytes, while the `invoice_data` is base32.
     *
     * The secret key used to sign the invoice is dependent on the [`Recipient`].
     *
     * Errors if the [`Recipient`] variant is not supported by the implementation.
     */
    sign_invoice(invoice, recipient) {
        const ret = bindings.NodeSigner_sign_invoice(this.ptr, CommonBase.get_ptr_of(invoice), recipient);
        const ret_hu_conv = Result_RecoverableSignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, invoice);
        return ret_hu_conv;
    }
    /**
     * Signs the [`TaggedHash`] of a BOLT 12 invoice request.
     *
     * May be called by a function passed to [`UnsignedInvoiceRequest::sign`] where
     * `invoice_request` is the callee.
     *
     * Implementors may check that the `invoice_request` is expected rather than blindly signing
     * the tagged hash. An `Ok` result should sign `invoice_request.tagged_hash().as_digest()` with
     * the node's signing key or an ephemeral key to preserve privacy, whichever is associated with
     * [`UnsignedInvoiceRequest::payer_id`].
     *
     * [`TaggedHash`]: crate::offers::merkle::TaggedHash
     */
    sign_bolt12_invoice_request(invoice_request) {
        const ret = bindings.NodeSigner_sign_bolt12_invoice_request(this.ptr, CommonBase.get_ptr_of(invoice_request));
        const ret_hu_conv = Result_SchnorrSignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, invoice_request);
        return ret_hu_conv;
    }
    /**
     * Signs the [`TaggedHash`] of a BOLT 12 invoice.
     *
     * May be called by a function passed to [`UnsignedBolt12Invoice::sign`] where `invoice` is the
     * callee.
     *
     * Implementors may check that the `invoice` is expected rather than blindly signing the tagged
     * hash. An `Ok` result should sign `invoice.tagged_hash().as_digest()` with the node's signing
     * key or an ephemeral key to preserve privacy, whichever is associated with
     * [`UnsignedBolt12Invoice::signing_pubkey`].
     *
     * [`TaggedHash`]: crate::offers::merkle::TaggedHash
     */
    sign_bolt12_invoice(invoice) {
        const ret = bindings.NodeSigner_sign_bolt12_invoice(this.ptr, CommonBase.get_ptr_of(invoice));
        const ret_hu_conv = Result_SchnorrSignatureNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, invoice);
        return ret_hu_conv;
    }
    /**
     * Sign a gossip message.
     *
     * Note that if this fails, LDK may panic and the message will not be broadcast to the network
     * or a possible channel counterparty. If LDK panics, the error should be resolved to allow the
     * message to be broadcast, as otherwise it may prevent one from receiving funds over the
     * corresponding channel.
     */
    sign_gossip_message(msg) {
        const ret = bindings.NodeSigner_sign_gossip_message(this.ptr, CommonBase.get_ptr_of(msg));
        const ret_hu_conv = Result_ECDSASignatureNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=NodeSigner.mjs.map