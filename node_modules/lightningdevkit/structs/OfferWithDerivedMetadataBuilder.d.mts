import { Network } from '../enums/Network.mjs';
import { BlindedMessagePath } from '../structs/BlindedMessagePath.mjs';
import { Quantity } from '../structs/Quantity.mjs';
import { Result_OfferBolt12SemanticErrorZ } from '../structs/Result_OfferBolt12SemanticErrorZ.mjs';
import { Nonce } from '../structs/Nonce.mjs';
import { ExpandedKey } from '../structs/ExpandedKey.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * Builds an [`Offer`] for the \"offer to be paid\" flow.
 *
 * See [module-level documentation] for usage.
 *
 * [module-level documentation]: self
 */
export declare class OfferWithDerivedMetadataBuilder extends CommonBase {
    clone_ptr(): bigint;
    /**
     * Creates a copy of the OfferWithDerivedMetadataBuilder
     */
    clone(): OfferWithDerivedMetadataBuilder;
    /**
     * Similar to [`OfferBuilder::new`] except, if [`OfferBuilder::path`] is called, the signing
     * pubkey is derived from the given [`ExpandedKey`] and [`Nonce`]. This provides recipient
     * privacy by using a different signing pubkey for each offer. Otherwise, the provided
     * `node_id` is used for the signing pubkey.
     *
     * Also, sets the metadata when [`OfferBuilder::build`] is called such that it can be used by
     * [`InvoiceRequest::verify_using_metadata`] to determine if the request was produced for the
     * offer given an [`ExpandedKey`]. However, if [`OfferBuilder::path`] is called, then the
     * metadata will not be set and must be included in each [`BlindedMessagePath`] instead. In this case,
     * use [`InvoiceRequest::verify_using_recipient_data`].
     *
     * [`InvoiceRequest::verify_using_metadata`]: crate::offers::invoice_request::InvoiceRequest::verify_using_metadata
     * [`InvoiceRequest::verify_using_recipient_data`]: crate::offers::invoice_request::InvoiceRequest::verify_using_recipient_data
     * [`ExpandedKey`]: crate::ln::inbound_payment::ExpandedKey
     */
    static constructor_deriving_signing_pubkey(node_id: Uint8Array, expanded_key: ExpandedKey, nonce: Nonce): OfferWithDerivedMetadataBuilder;
    /**
     * Adds the chain hash of the given [`Network`] to [`Offer::chains`]. If not called,
     * the chain hash of [`Network::Bitcoin`] is assumed to be the only one supported.
     *
     * See [`Offer::chains`] on how this relates to the payment currency.
     *
     * Successive calls to this method will add another chain hash.
     */
    chain(network: Network): void;
    /**
     * Sets the [`Offer::amount`] as an [`Amount::Bitcoin`].
     *
     * Successive calls to this method will override the previous setting.
     */
    amount_msats(amount_msats: bigint): void;
    /**
     * Sets the [`Offer::absolute_expiry`] as seconds since the Unix epoch. Any expiry that has
     * already passed is valid and can be checked for using [`Offer::is_expired`].
     *
     * Successive calls to this method will override the previous setting.
     */
    absolute_expiry(absolute_expiry: bigint): void;
    /**
     * Sets the [`Offer::description`].
     *
     * Successive calls to this method will override the previous setting.
     */
    description(description: string): void;
    /**
     * Sets the [`Offer::issuer`].
     *
     * Successive calls to this method will override the previous setting.
     */
    issuer(issuer: string): void;
    /**
     * Adds a blinded path to [`Offer::paths`]. Must include at least one path if only connected by
     * private channels or if [`Offer::signing_pubkey`] is not a public node id.
     *
     * Successive calls to this method will add another blinded path. Caller is responsible for not
     * adding duplicate paths.
     */
    path(path: BlindedMessagePath): void;
    /**
     * Sets the quantity of items for [`Offer::supported_quantity`]. If not called, defaults to
     * [`Quantity::One`].
     *
     * Successive calls to this method will override the previous setting.
     */
    supported_quantity(quantity: Quantity): void;
    /**
     * Builds an [`Offer`] from the builder's settings.
     */
    build(): Result_OfferBolt12SemanticErrorZ;
}
