import { Result_OfferBolt12SemanticErrorZ } from '../structs/Result_OfferBolt12SemanticErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Builds an [`Offer`] for the \"offer to be paid\" flow.
 *
 * See [module-level documentation] for usage.
 *
 * [module-level documentation]: self
 */
export class OfferWithDerivedMetadataBuilder extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.OfferWithDerivedMetadataBuilder_free);
    }
    clone_ptr() {
        const ret = bindings.OfferWithDerivedMetadataBuilder_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the OfferWithDerivedMetadataBuilder
     */
    clone() {
        const ret = bindings.OfferWithDerivedMetadataBuilder_clone(this.ptr);
        const ret_hu_conv = new OfferWithDerivedMetadataBuilder(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Similar to [`OfferBuilder::new`] except, if [`OfferBuilder::path`] is called, the signing
     * pubkey is derived from the given [`ExpandedKey`] and [`Nonce`]. This provides recipient
     * privacy by using a different signing pubkey for each offer. Otherwise, the provided
     * `node_id` is used for the signing pubkey.
     *
     * Also, sets the metadata when [`OfferBuilder::build`] is called such that it can be used by
     * [`InvoiceRequest::verify_using_metadata`] to determine if the request was produced for the
     * offer given an [`ExpandedKey`]. However, if [`OfferBuilder::path`] is called, then the
     * metadata will not be set and must be included in each [`BlindedMessagePath`] instead. In this case,
     * use [`InvoiceRequest::verify_using_recipient_data`].
     *
     * [`InvoiceRequest::verify_using_metadata`]: crate::offers::invoice_request::InvoiceRequest::verify_using_metadata
     * [`InvoiceRequest::verify_using_recipient_data`]: crate::offers::invoice_request::InvoiceRequest::verify_using_recipient_data
     * [`ExpandedKey`]: crate::ln::inbound_payment::ExpandedKey
     */
    static constructor_deriving_signing_pubkey(node_id, expanded_key, nonce) {
        const ret = bindings.OfferWithDerivedMetadataBuilder_deriving_signing_pubkey(bindings.encodeUint8Array(bindings.check_arr_len(node_id, 33)), CommonBase.get_ptr_of(expanded_key), CommonBase.get_ptr_of(nonce));
        const ret_hu_conv = new OfferWithDerivedMetadataBuilder(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, expanded_key);
        return ret_hu_conv;
    }
    /**
     * Adds the chain hash of the given [`Network`] to [`Offer::chains`]. If not called,
     * the chain hash of [`Network::Bitcoin`] is assumed to be the only one supported.
     *
     * See [`Offer::chains`] on how this relates to the payment currency.
     *
     * Successive calls to this method will add another chain hash.
     */
    chain(network) {
        bindings.OfferWithDerivedMetadataBuilder_chain(this.ptr, network);
    }
    /**
     * Sets the [`Offer::amount`] as an [`Amount::Bitcoin`].
     *
     * Successive calls to this method will override the previous setting.
     */
    amount_msats(amount_msats) {
        bindings.OfferWithDerivedMetadataBuilder_amount_msats(this.ptr, amount_msats);
    }
    /**
     * Sets the [`Offer::absolute_expiry`] as seconds since the Unix epoch. Any expiry that has
     * already passed is valid and can be checked for using [`Offer::is_expired`].
     *
     * Successive calls to this method will override the previous setting.
     */
    absolute_expiry(absolute_expiry) {
        bindings.OfferWithDerivedMetadataBuilder_absolute_expiry(this.ptr, absolute_expiry);
    }
    /**
     * Sets the [`Offer::description`].
     *
     * Successive calls to this method will override the previous setting.
     */
    description(description) {
        bindings.OfferWithDerivedMetadataBuilder_description(this.ptr, bindings.encodeString(description));
    }
    /**
     * Sets the [`Offer::issuer`].
     *
     * Successive calls to this method will override the previous setting.
     */
    issuer(issuer) {
        bindings.OfferWithDerivedMetadataBuilder_issuer(this.ptr, bindings.encodeString(issuer));
    }
    /**
     * Adds a blinded path to [`Offer::paths`]. Must include at least one path if only connected by
     * private channels or if [`Offer::signing_pubkey`] is not a public node id.
     *
     * Successive calls to this method will add another blinded path. Caller is responsible for not
     * adding duplicate paths.
     */
    path(path) {
        bindings.OfferWithDerivedMetadataBuilder_path(this.ptr, CommonBase.get_ptr_of(path));
    }
    /**
     * Sets the quantity of items for [`Offer::supported_quantity`]. If not called, defaults to
     * [`Quantity::One`].
     *
     * Successive calls to this method will override the previous setting.
     */
    supported_quantity(quantity) {
        bindings.OfferWithDerivedMetadataBuilder_supported_quantity(this.ptr, CommonBase.get_ptr_of(quantity));
    }
    /**
     * Builds an [`Offer`] from the builder's settings.
     */
    build() {
        const ret = bindings.OfferWithDerivedMetadataBuilder_build(this.ptr);
        const ret_hu_conv = Result_OfferBolt12SemanticErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=OfferWithDerivedMetadataBuilder.mjs.map