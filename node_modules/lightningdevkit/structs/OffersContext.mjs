import { Nonce } from '../structs/Nonce.mjs';
import { Result_OffersContextDecodeErrorZ } from '../structs/Result_OffersContextDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Contains data specific to an [`OffersMessage`].
 *
 * [`OffersMessage`]: crate::onion_message::offers::OffersMessage
 */
export class OffersContext extends CommonBase {
    constructor(_dummy, ptr) { super(ptr, bindings.OffersContext_free); }
    /* @internal */
    static constr_from_ptr(ptr) {
        const raw_ty = bindings.LDKOffersContext_ty_from_ptr(ptr);
        switch (raw_ty) {
            case 0: return new OffersContext_InvoiceRequest(ptr);
            case 1: return new OffersContext_OutboundPayment(ptr);
            case 2: return new OffersContext_InboundPayment(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = bindings.OffersContext_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the OffersContext
     */
    clone() {
        const ret = bindings.OffersContext_clone(this.ptr);
        const ret_hu_conv = OffersContext.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new InvoiceRequest-variant OffersContext
     */
    static constructor_invoice_request(nonce) {
        const ret = bindings.OffersContext_invoice_request(CommonBase.get_ptr_of(nonce));
        const ret_hu_conv = OffersContext.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new OutboundPayment-variant OffersContext
     */
    static constructor_outbound_payment(payment_id, nonce, hmac) {
        const ret = bindings.OffersContext_outbound_payment(bindings.encodeUint8Array(bindings.check_arr_len(payment_id, 32)), CommonBase.get_ptr_of(nonce), bindings.encodeUint8Array(bindings.check_arr_len(hmac, 32)));
        const ret_hu_conv = OffersContext.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new InboundPayment-variant OffersContext
     */
    static constructor_inbound_payment(payment_hash) {
        const ret = bindings.OffersContext_inbound_payment(bindings.encodeUint8Array(bindings.check_arr_len(payment_hash, 32)));
        const ret_hu_conv = OffersContext.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Checks if two OffersContexts contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     */
    eq(b) {
        const ret = bindings.OffersContext_eq(this.ptr, CommonBase.get_ptr_of(b));
        return ret;
    }
    /**
     * Serialize the OffersContext object into a byte array which can be read by OffersContext_read
     */
    write() {
        const ret = bindings.OffersContext_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a OffersContext from a byte array, created by OffersContext_write
     */
    static constructor_read(ser) {
        const ret = bindings.OffersContext_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_OffersContextDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
/** A OffersContext of type InvoiceRequest */
export class OffersContext_InvoiceRequest extends OffersContext {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const nonce = bindings.LDKOffersContext_InvoiceRequest_get_nonce(ptr);
        const nonce_hu_conv = new Nonce(null, nonce);
        CommonBase.add_ref_from(nonce_hu_conv, this);
        this.nonce = nonce_hu_conv;
    }
}
/** A OffersContext of type OutboundPayment */
export class OffersContext_OutboundPayment extends OffersContext {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const payment_id = bindings.LDKOffersContext_OutboundPayment_get_payment_id(ptr);
        const payment_id_conv = bindings.decodeUint8Array(payment_id);
        this.payment_id = payment_id_conv;
        const nonce = bindings.LDKOffersContext_OutboundPayment_get_nonce(ptr);
        const nonce_hu_conv = new Nonce(null, nonce);
        CommonBase.add_ref_from(nonce_hu_conv, this);
        this.nonce = nonce_hu_conv;
        const hmac = bindings.LDKOffersContext_OutboundPayment_get_hmac(ptr);
        const hmac_conv = bindings.decodeUint8Array(hmac);
        this.hmac = hmac_conv;
    }
}
/** A OffersContext of type InboundPayment */
export class OffersContext_InboundPayment extends OffersContext {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const payment_hash = bindings.LDKOffersContext_InboundPayment_get_payment_hash(ptr);
        const payment_hash_conv = bindings.decodeUint8Array(payment_hash);
        this.payment_hash = payment_hash_conv;
    }
}
//# sourceMappingURL=OffersContext.mjs.map