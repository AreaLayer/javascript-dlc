import { Result_NoneNoneZ } from '../structs/Result_NoneNoneZ.mjs';
import { BestBlock } from '../structs/BestBlock.mjs';
import { TrackedSpendableOutput } from '../structs/TrackedSpendableOutput.mjs';
import { Result_OutputSweeperDecodeErrorZ } from '../structs/Result_OutputSweeperDecodeErrorZ.mjs';
import { Listen } from '../structs/Listen.mjs';
import { Confirm } from '../structs/Confirm.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A utility that keeps track of [`SpendableOutputDescriptor`]s, persists them in a given
 * [`KVStore`] and regularly retries sweeping them based on a callback given to the constructor
 * methods.
 *
 * Users should call [`Self::track_spendable_outputs`] for any [`SpendableOutputDescriptor`]s received via [`Event::SpendableOutputs`].
 *
 * This needs to be notified of chain state changes either via its [`Listen`] or [`Confirm`]
 * implementation and hence has to be connected with the utilized chain data sources.
 *
 * If chain data is provided via the [`Confirm`] interface or via filtered blocks, users are
 * required to give their chain data sources (i.e., [`Filter`] implementation) to the respective
 * constructor.
 *
 * [`Event::SpendableOutputs`]: crate::events::Event::SpendableOutputs
 */
export class OutputSweeper extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.OutputSweeper_free);
    }
    /**
     * Constructs a new [`OutputSweeper`].
     *
     * If chain data is provided via the [`Confirm`] interface or via filtered blocks, users also
     * need to register their [`Filter`] implementation via the given `chain_data_source`.
     */
    static constructor_new(best_block, broadcaster, fee_estimator, chain_data_source, output_spender, change_destination_source, kv_store, logger) {
        const ret = bindings.OutputSweeper_new(CommonBase.get_ptr_of(best_block), CommonBase.get_ptr_of(broadcaster), CommonBase.get_ptr_of(fee_estimator), CommonBase.get_ptr_of(chain_data_source), CommonBase.get_ptr_of(output_spender), CommonBase.get_ptr_of(change_destination_source), CommonBase.get_ptr_of(kv_store), CommonBase.get_ptr_of(logger));
        const ret_hu_conv = new OutputSweeper(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, broadcaster);
        CommonBase.add_ref_from(ret_hu_conv, fee_estimator);
        CommonBase.add_ref_from(ret_hu_conv, chain_data_source);
        CommonBase.add_ref_from(ret_hu_conv, output_spender);
        CommonBase.add_ref_from(ret_hu_conv, change_destination_source);
        CommonBase.add_ref_from(ret_hu_conv, kv_store);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * Tells the sweeper to track the given outputs descriptors.
     *
     * Usually, this should be called based on the values emitted by the
     * [`Event::SpendableOutputs`].
     *
     * The given `exclude_static_outputs` flag controls whether the sweeper will filter out
     * [`SpendableOutputDescriptor::StaticOutput`]s, which may be handled directly by the on-chain
     * wallet implementation.
     *
     * If `delay_until_height` is set, we will delay the spending until the respective block
     * height is reached. This can be used to batch spends, e.g., to reduce on-chain fees.
     *
     * Returns `Err` on persistence failure, in which case the call may be safely retried.
     *
     * [`Event::SpendableOutputs`]: crate::events::Event::SpendableOutputs
     *
     * Note that channel_id (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    track_spendable_outputs(output_descriptors, channel_id, exclude_static_outputs, delay_until_height) {
        const ret = bindings.OutputSweeper_track_spendable_outputs(this.ptr, bindings.encodeUint64Array(output_descriptors.map(output_descriptors_conv_27 => CommonBase.get_ptr_of(output_descriptors_conv_27))), channel_id == null ? 0n : CommonBase.get_ptr_of(channel_id), exclude_static_outputs, CommonBase.get_ptr_of(delay_until_height));
        const ret_hu_conv = Result_NoneNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns a list of the currently tracked spendable outputs.
     */
    tracked_spendable_outputs() {
        const ret = bindings.OutputSweeper_tracked_spendable_outputs(this.ptr);
        const ret_conv_24_len = bindings.getArrayLength(ret);
        const ret_conv_24_arr = new Array(ret_conv_24_len).fill(null);
        for (var y = 0; y < ret_conv_24_len; y++) {
            const ret_conv_24 = bindings.getU64ArrayElem(ret, y);
            const ret_conv_24_hu_conv = new TrackedSpendableOutput(null, ret_conv_24);
            CommonBase.add_ref_from(ret_conv_24_hu_conv, this);
            ret_conv_24_arr[y] = ret_conv_24_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_24_arr;
    }
    /**
     * Gets the latest best block which was connected either via the [`Listen`] or
     * [`Confirm`] interfaces.
     */
    current_best_block() {
        const ret = bindings.OutputSweeper_current_best_block(this.ptr);
        const ret_hu_conv = new BestBlock(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Listen which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
     */
    as_Listen() {
        const ret = bindings.OutputSweeper_as_Listen(this.ptr);
        const ret_hu_conv = new Listen(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Constructs a new Confirm which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
     */
    as_Confirm() {
        const ret = bindings.OutputSweeper_as_Confirm(this.ptr);
        const ret_hu_conv = new Confirm(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Read a OutputSweeper from a byte array, created by OutputSweeper_write
     */
    static constructor_read(ser, arg_a, arg_b, arg_c, arg_d, arg_e, arg_f, arg_g) {
        const ret = bindings.OutputSweeper_read(bindings.encodeUint8Array(ser), CommonBase.get_ptr_of(arg_a), CommonBase.get_ptr_of(arg_b), CommonBase.get_ptr_of(arg_c), CommonBase.get_ptr_of(arg_d), CommonBase.get_ptr_of(arg_e), CommonBase.get_ptr_of(arg_f), CommonBase.get_ptr_of(arg_g));
        const ret_hu_conv = Result_OutputSweeperDecodeErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, arg_a);
        CommonBase.add_ref_from(ret_hu_conv, arg_b);
        CommonBase.add_ref_from(ret_hu_conv, arg_c);
        CommonBase.add_ref_from(ret_hu_conv, arg_d);
        CommonBase.add_ref_from(ret_hu_conv, arg_e);
        CommonBase.add_ref_from(ret_hu_conv, arg_f);
        CommonBase.add_ref_from(ret_hu_conv, arg_g);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=OutputSweeper.mjs.map