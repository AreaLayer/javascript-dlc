import { InitFeatures } from '../structs/InitFeatures.mjs';
import { Option_SocketAddressZ } from '../structs/Option_SocketAddressZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Details of a connected peer as returned by [`PeerManager::list_peers`].
 */
export class PeerDetails extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.PeerDetails_free);
    }
    /**
     * The node id of the peer.
     *
     * For outbound connections, this [`PublicKey`] will be the same as the `their_node_id` parameter
     * passed in to [`PeerManager::new_outbound_connection`].
     */
    get_counterparty_node_id() {
        const ret = bindings.PeerDetails_get_counterparty_node_id(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The node id of the peer.
     *
     * For outbound connections, this [`PublicKey`] will be the same as the `their_node_id` parameter
     * passed in to [`PeerManager::new_outbound_connection`].
     */
    set_counterparty_node_id(val) {
        bindings.PeerDetails_set_counterparty_node_id(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(val, 33)));
    }
    /**
     * The socket address the peer provided in the initial handshake.
     *
     * Will only be `Some` if an address had been previously provided to
     * [`PeerManager::new_outbound_connection`] or [`PeerManager::new_inbound_connection`].
     *
     * Returns a copy of the field.
     */
    get_socket_address() {
        const ret = bindings.PeerDetails_get_socket_address(this.ptr);
        const ret_hu_conv = Option_SocketAddressZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The socket address the peer provided in the initial handshake.
     *
     * Will only be `Some` if an address had been previously provided to
     * [`PeerManager::new_outbound_connection`] or [`PeerManager::new_inbound_connection`].
     */
    set_socket_address(val) {
        bindings.PeerDetails_set_socket_address(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * The features the peer provided in the initial handshake.
     */
    get_init_features() {
        const ret = bindings.PeerDetails_get_init_features(this.ptr);
        const ret_hu_conv = new InitFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The features the peer provided in the initial handshake.
     */
    set_init_features(val) {
        bindings.PeerDetails_set_init_features(this.ptr, CommonBase.get_ptr_of(val));
    }
    /**
     * Indicates the direction of the peer connection.
     *
     * Will be `true` for inbound connections, and `false` for outbound connections.
     */
    get_is_inbound_connection() {
        const ret = bindings.PeerDetails_get_is_inbound_connection(this.ptr);
        return ret;
    }
    /**
     * Indicates the direction of the peer connection.
     *
     * Will be `true` for inbound connections, and `false` for outbound connections.
     */
    set_is_inbound_connection(val) {
        bindings.PeerDetails_set_is_inbound_connection(this.ptr, val);
    }
    /**
     * Constructs a new PeerDetails given each field
     */
    static constructor_new(counterparty_node_id_arg, socket_address_arg, init_features_arg, is_inbound_connection_arg) {
        const ret = bindings.PeerDetails_new(bindings.encodeUint8Array(bindings.check_arr_len(counterparty_node_id_arg, 33)), CommonBase.get_ptr_of(socket_address_arg), CommonBase.get_ptr_of(init_features_arg), is_inbound_connection_arg);
        const ret_hu_conv = new PeerDetails(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=PeerDetails.mjs.map