import { Option_CVec_u8ZZ } from '../structs/Option_CVec_u8ZZ.mjs';
import { TwoTuple_u64CVec_u8ZZ } from '../structs/TwoTuple_u64CVec_u8ZZ.mjs';
import { Option_PaymentContextZ } from '../structs/Option_PaymentContextZ.mjs';
import { BlindedForward } from '../structs/BlindedForward.mjs';
import { OnionPacket } from '../structs/OnionPacket.mjs';
import { FinalOnionHopData } from '../structs/FinalOnionHopData.mjs';
import { Result_PendingHTLCRoutingDecodeErrorZ } from '../structs/Result_PendingHTLCRoutingDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * Information about where a received HTLC('s onion) has indicated the HTLC should go.
 */
export declare class PendingHTLCRouting extends CommonBase {
    protected constructor(_dummy: null, ptr: bigint);
    clone_ptr(): bigint;
    /**
     * Creates a copy of the PendingHTLCRouting
     */
    clone(): PendingHTLCRouting;
    /**
     * Utility method to constructs a new Forward-variant PendingHTLCRouting
     */
    static constructor_forward(onion_packet: OnionPacket, short_channel_id: bigint, blinded: BlindedForward): PendingHTLCRouting;
    /**
     * Utility method to constructs a new Receive-variant PendingHTLCRouting
     */
    static constructor_receive(payment_data: FinalOnionHopData, payment_metadata: Option_CVec_u8ZZ, payment_context: Option_PaymentContextZ, incoming_cltv_expiry: number, phantom_shared_secret: Uint8Array, custom_tlvs: TwoTuple_u64CVec_u8ZZ[], requires_blinded_error: boolean): PendingHTLCRouting;
    /**
     * Utility method to constructs a new ReceiveKeysend-variant PendingHTLCRouting
     */
    static constructor_receive_keysend(payment_data: FinalOnionHopData, payment_preimage: Uint8Array, payment_metadata: Option_CVec_u8ZZ, incoming_cltv_expiry: number, custom_tlvs: TwoTuple_u64CVec_u8ZZ[], requires_blinded_error: boolean): PendingHTLCRouting;
    /**
     * Serialize the PendingHTLCRouting object into a byte array which can be read by PendingHTLCRouting_read
     */
    write(): Uint8Array;
    /**
     * Read a PendingHTLCRouting from a byte array, created by PendingHTLCRouting_write
     */
    static constructor_read(ser: Uint8Array): Result_PendingHTLCRoutingDecodeErrorZ;
}
/** A PendingHTLCRouting of type Forward */
export declare class PendingHTLCRouting_Forward extends PendingHTLCRouting {
    /**
     * The onion which should be included in the forwarded HTLC, telling the next hop what to
     * do with the HTLC.
     */
    onion_packet: OnionPacket;
    /**
     * The short channel ID of the channel which we were instructed to forward this HTLC to.
     *
     * This could be a real on-chain SCID, an SCID alias, or some other SCID which has meaning
     * to the receiving node, such as one returned from
     * [`ChannelManager::get_intercept_scid`] or [`ChannelManager::get_phantom_scid`].
     */
    short_channel_id: bigint;
    /**
     * Set if this HTLC is being forwarded within a blinded path.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    blinded: BlindedForward;
}
/** A PendingHTLCRouting of type Receive */
export declare class PendingHTLCRouting_Receive extends PendingHTLCRouting {
    /**
     * Information about the amount the sender intended to pay and (potential) proof that this
     * is a payment for an invoice we generated. This proof of payment is is also used for
     * linking MPP parts of a larger payment.
     */
    payment_data: FinalOnionHopData;
    /**
     * Additional data which we (allegedly) instructed the sender to include in the onion.
     *
     * For HTLCs received by LDK, this will ultimately be exposed in
     * [`Event::PaymentClaimable::onion_fields`] as
     * [`RecipientOnionFields::payment_metadata`].
     */
    payment_metadata: Option_CVec_u8ZZ;
    /**
     * The context of the payment included by the recipient in a blinded path, or `None` if a
     * blinded path was not used.
     *
     * Used in part to determine the [`events::PaymentPurpose`].
     */
    payment_context: Option_PaymentContextZ;
    /**
     * CLTV expiry of the received HTLC.
     *
     * Used to track when we should expire pending HTLCs that go unclaimed.
     */
    incoming_cltv_expiry: number;
    /**
     * If the onion had forwarding instructions to one of our phantom node SCIDs, this will
     * provide the onion shared secret used to decrypt the next level of forwarding
     * instructions.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    phantom_shared_secret: Uint8Array;
    /**
     * Custom TLVs which were set by the sender.
     *
     * For HTLCs received by LDK, this will ultimately be exposed in
     * [`Event::PaymentClaimable::onion_fields`] as
     * [`RecipientOnionFields::custom_tlvs`].
     */
    custom_tlvs: TwoTuple_u64CVec_u8ZZ[];
    /**
     * Set if this HTLC is the final hop in a multi-hop blinded path.
     */
    requires_blinded_error: boolean;
}
/** A PendingHTLCRouting of type ReceiveKeysend */
export declare class PendingHTLCRouting_ReceiveKeysend extends PendingHTLCRouting {
    /**
     * Information about the amount the sender intended to pay and possibly a token to
     * associate MPP parts of a larger payment.
     *
     * This will only be filled in if receiving MPP keysend payments is enabled, and it being
     * present will cause deserialization to fail on versions of LDK prior to 0.0.116.
     *
     * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    payment_data: FinalOnionHopData;
    /**
     * Preimage for this onion payment. This preimage is provided by the sender and will be
     * used to settle the spontaneous payment.
     */
    payment_preimage: Uint8Array;
    /**
     * Additional data which we (allegedly) instructed the sender to include in the onion.
     *
     * For HTLCs received by LDK, this will ultimately bubble back up as
     * [`RecipientOnionFields::payment_metadata`].
     */
    payment_metadata: Option_CVec_u8ZZ;
    /**
     * CLTV expiry of the received HTLC.
     *
     * Used to track when we should expire pending HTLCs that go unclaimed.
     */
    incoming_cltv_expiry: number;
    /**
     * Custom TLVs which were set by the sender.
     *
     * For HTLCs received by LDK, these will ultimately bubble back up as
     * [`RecipientOnionFields::custom_tlvs`].
     */
    custom_tlvs: TwoTuple_u64CVec_u8ZZ[];
    /**
     * Set if this HTLC is the final hop in a multi-hop blinded path.
     */
    requires_blinded_error: boolean;
}
