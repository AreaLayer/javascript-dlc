import { Option_CVec_u8ZZ } from '../structs/Option_CVec_u8ZZ.mjs';
import { TwoTuple_u64CVec_u8ZZ } from '../structs/TwoTuple_u64CVec_u8ZZ.mjs';
import { Option_PaymentContextZ } from '../structs/Option_PaymentContextZ.mjs';
import { BlindedForward } from '../structs/BlindedForward.mjs';
import { OnionPacket } from '../structs/OnionPacket.mjs';
import { FinalOnionHopData } from '../structs/FinalOnionHopData.mjs';
import { Result_PendingHTLCRoutingDecodeErrorZ } from '../structs/Result_PendingHTLCRoutingDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Information about where a received HTLC('s onion) has indicated the HTLC should go.
 */
export class PendingHTLCRouting extends CommonBase {
    constructor(_dummy, ptr) { super(ptr, bindings.PendingHTLCRouting_free); }
    /* @internal */
    static constr_from_ptr(ptr) {
        const raw_ty = bindings.LDKPendingHTLCRouting_ty_from_ptr(ptr);
        switch (raw_ty) {
            case 0: return new PendingHTLCRouting_Forward(ptr);
            case 1: return new PendingHTLCRouting_Receive(ptr);
            case 2: return new PendingHTLCRouting_ReceiveKeysend(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = bindings.PendingHTLCRouting_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the PendingHTLCRouting
     */
    clone() {
        const ret = bindings.PendingHTLCRouting_clone(this.ptr);
        const ret_hu_conv = PendingHTLCRouting.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new Forward-variant PendingHTLCRouting
     */
    static constructor_forward(onion_packet, short_channel_id, blinded) {
        const ret = bindings.PendingHTLCRouting_forward(CommonBase.get_ptr_of(onion_packet), short_channel_id, CommonBase.get_ptr_of(blinded));
        const ret_hu_conv = PendingHTLCRouting.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new Receive-variant PendingHTLCRouting
     */
    static constructor_receive(payment_data, payment_metadata, payment_context, incoming_cltv_expiry, phantom_shared_secret, custom_tlvs, requires_blinded_error) {
        const ret = bindings.PendingHTLCRouting_receive(CommonBase.get_ptr_of(payment_data), CommonBase.get_ptr_of(payment_metadata), CommonBase.get_ptr_of(payment_context), incoming_cltv_expiry, bindings.encodeUint8Array(bindings.check_arr_len(phantom_shared_secret, 32)), bindings.encodeUint64Array(custom_tlvs.map(custom_tlvs_conv_23 => CommonBase.get_ptr_of(custom_tlvs_conv_23))), requires_blinded_error);
        const ret_hu_conv = PendingHTLCRouting.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new ReceiveKeysend-variant PendingHTLCRouting
     */
    static constructor_receive_keysend(payment_data, payment_preimage, payment_metadata, incoming_cltv_expiry, custom_tlvs, requires_blinded_error) {
        const ret = bindings.PendingHTLCRouting_receive_keysend(CommonBase.get_ptr_of(payment_data), bindings.encodeUint8Array(bindings.check_arr_len(payment_preimage, 32)), CommonBase.get_ptr_of(payment_metadata), incoming_cltv_expiry, bindings.encodeUint64Array(custom_tlvs.map(custom_tlvs_conv_23 => CommonBase.get_ptr_of(custom_tlvs_conv_23))), requires_blinded_error);
        const ret_hu_conv = PendingHTLCRouting.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Serialize the PendingHTLCRouting object into a byte array which can be read by PendingHTLCRouting_read
     */
    write() {
        const ret = bindings.PendingHTLCRouting_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a PendingHTLCRouting from a byte array, created by PendingHTLCRouting_write
     */
    static constructor_read(ser) {
        const ret = bindings.PendingHTLCRouting_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_PendingHTLCRoutingDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
/** A PendingHTLCRouting of type Forward */
export class PendingHTLCRouting_Forward extends PendingHTLCRouting {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const onion_packet = bindings.LDKPendingHTLCRouting_Forward_get_onion_packet(ptr);
        const onion_packet_hu_conv = new OnionPacket(null, onion_packet);
        CommonBase.add_ref_from(onion_packet_hu_conv, this);
        this.onion_packet = onion_packet_hu_conv;
        this.short_channel_id = bindings.LDKPendingHTLCRouting_Forward_get_short_channel_id(ptr);
        const blinded = bindings.LDKPendingHTLCRouting_Forward_get_blinded(ptr);
        const blinded_hu_conv = new BlindedForward(null, blinded);
        CommonBase.add_ref_from(blinded_hu_conv, this);
        this.blinded = blinded_hu_conv;
    }
}
/** A PendingHTLCRouting of type Receive */
export class PendingHTLCRouting_Receive extends PendingHTLCRouting {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const payment_data = bindings.LDKPendingHTLCRouting_Receive_get_payment_data(ptr);
        const payment_data_hu_conv = new FinalOnionHopData(null, payment_data);
        CommonBase.add_ref_from(payment_data_hu_conv, this);
        this.payment_data = payment_data_hu_conv;
        const payment_metadata = bindings.LDKPendingHTLCRouting_Receive_get_payment_metadata(ptr);
        const payment_metadata_hu_conv = Option_CVec_u8ZZ.constr_from_ptr(payment_metadata);
        CommonBase.add_ref_from(payment_metadata_hu_conv, this);
        this.payment_metadata = payment_metadata_hu_conv;
        const payment_context = bindings.LDKPendingHTLCRouting_Receive_get_payment_context(ptr);
        const payment_context_hu_conv = Option_PaymentContextZ.constr_from_ptr(payment_context);
        CommonBase.add_ref_from(payment_context_hu_conv, this);
        this.payment_context = payment_context_hu_conv;
        this.incoming_cltv_expiry = bindings.LDKPendingHTLCRouting_Receive_get_incoming_cltv_expiry(ptr);
        const phantom_shared_secret = bindings.LDKPendingHTLCRouting_Receive_get_phantom_shared_secret(ptr);
        const phantom_shared_secret_conv = bindings.decodeUint8Array(phantom_shared_secret);
        this.phantom_shared_secret = phantom_shared_secret_conv;
        const custom_tlvs = bindings.LDKPendingHTLCRouting_Receive_get_custom_tlvs(ptr);
        const custom_tlvs_conv_23_len = bindings.getArrayLength(custom_tlvs);
        const custom_tlvs_conv_23_arr = new Array(custom_tlvs_conv_23_len).fill(null);
        for (var x = 0; x < custom_tlvs_conv_23_len; x++) {
            const custom_tlvs_conv_23 = bindings.getU64ArrayElem(custom_tlvs, x);
            const custom_tlvs_conv_23_hu_conv = new TwoTuple_u64CVec_u8ZZ(null, custom_tlvs_conv_23);
            CommonBase.add_ref_from(custom_tlvs_conv_23_hu_conv, this);
            custom_tlvs_conv_23_arr[x] = custom_tlvs_conv_23_hu_conv;
        }
        bindings.freeWasmMemory(custom_tlvs);
        this.custom_tlvs = custom_tlvs_conv_23_arr;
        this.requires_blinded_error = bindings.LDKPendingHTLCRouting_Receive_get_requires_blinded_error(ptr);
    }
}
/** A PendingHTLCRouting of type ReceiveKeysend */
export class PendingHTLCRouting_ReceiveKeysend extends PendingHTLCRouting {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        const payment_data = bindings.LDKPendingHTLCRouting_ReceiveKeysend_get_payment_data(ptr);
        const payment_data_hu_conv = new FinalOnionHopData(null, payment_data);
        CommonBase.add_ref_from(payment_data_hu_conv, this);
        this.payment_data = payment_data_hu_conv;
        const payment_preimage = bindings.LDKPendingHTLCRouting_ReceiveKeysend_get_payment_preimage(ptr);
        const payment_preimage_conv = bindings.decodeUint8Array(payment_preimage);
        this.payment_preimage = payment_preimage_conv;
        const payment_metadata = bindings.LDKPendingHTLCRouting_ReceiveKeysend_get_payment_metadata(ptr);
        const payment_metadata_hu_conv = Option_CVec_u8ZZ.constr_from_ptr(payment_metadata);
        CommonBase.add_ref_from(payment_metadata_hu_conv, this);
        this.payment_metadata = payment_metadata_hu_conv;
        this.incoming_cltv_expiry = bindings.LDKPendingHTLCRouting_ReceiveKeysend_get_incoming_cltv_expiry(ptr);
        const custom_tlvs = bindings.LDKPendingHTLCRouting_ReceiveKeysend_get_custom_tlvs(ptr);
        const custom_tlvs_conv_23_len = bindings.getArrayLength(custom_tlvs);
        const custom_tlvs_conv_23_arr = new Array(custom_tlvs_conv_23_len).fill(null);
        for (var x = 0; x < custom_tlvs_conv_23_len; x++) {
            const custom_tlvs_conv_23 = bindings.getU64ArrayElem(custom_tlvs, x);
            const custom_tlvs_conv_23_hu_conv = new TwoTuple_u64CVec_u8ZZ(null, custom_tlvs_conv_23);
            CommonBase.add_ref_from(custom_tlvs_conv_23_hu_conv, this);
            custom_tlvs_conv_23_arr[x] = custom_tlvs_conv_23_hu_conv;
        }
        bindings.freeWasmMemory(custom_tlvs);
        this.custom_tlvs = custom_tlvs_conv_23_arr;
        this.requires_blinded_error = bindings.LDKPendingHTLCRouting_ReceiveKeysend_get_requires_blinded_error(ptr);
    }
}
//# sourceMappingURL=PendingHTLCRouting.mjs.map