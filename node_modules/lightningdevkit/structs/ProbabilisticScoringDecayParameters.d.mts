import { CommonBase } from './CommonBase.mjs';
/**
 * Parameters for configuring [`ProbabilisticScorer`].
 *
 * Used to configure decay parameters that are static throughout the lifetime of the scorer.
 * these decay parameters affect the score of the channel penalty and are not changed on a
 * per-route penalty cost call.
 */
export declare class ProbabilisticScoringDecayParameters extends CommonBase {
    /**
     * If we aren't learning any new datapoints for a channel, the historical liquidity bounds
     * tracking can simply live on with increasingly stale data. Instead, when a channel has not
     * seen a liquidity estimate update for this amount of time, the historical datapoints are
     * decayed by half.
     * For an example of historical_no_updates_half_life being used see [`historical_estimated_channel_liquidity_probabilities`]
     *
     * Note that after 16 or more half lives all historical data will be completely gone.
     *
     * Default value: 14 days
     *
     * [`historical_estimated_channel_liquidity_probabilities`]: ProbabilisticScorer::historical_estimated_channel_liquidity_probabilities
     */
    get_historical_no_updates_half_life(): bigint;
    /**
     * If we aren't learning any new datapoints for a channel, the historical liquidity bounds
     * tracking can simply live on with increasingly stale data. Instead, when a channel has not
     * seen a liquidity estimate update for this amount of time, the historical datapoints are
     * decayed by half.
     * For an example of historical_no_updates_half_life being used see [`historical_estimated_channel_liquidity_probabilities`]
     *
     * Note that after 16 or more half lives all historical data will be completely gone.
     *
     * Default value: 14 days
     *
     * [`historical_estimated_channel_liquidity_probabilities`]: ProbabilisticScorer::historical_estimated_channel_liquidity_probabilities
     */
    set_historical_no_updates_half_life(val: bigint): void;
    /**
     * Whenever this amount of time elapses since the last update to a channel's liquidity bounds,
     * the distance from the bounds to \"zero\" is cut in half. In other words, the lower-bound on
     * the available liquidity is halved and the upper-bound moves half-way to the channel's total
     * capacity.
     *
     * Because halving the liquidity bounds grows the uncertainty on the channel's liquidity,
     * the penalty for an amount within the new bounds may change. See the [`ProbabilisticScorer`]
     * struct documentation for more info on the way the liquidity bounds are used.
     *
     * For example, if the channel's capacity is 1 million sats, and the current upper and lower
     * liquidity bounds are 200,000 sats and 600,000 sats, after this amount of time the upper
     * and lower liquidity bounds will be decayed to 100,000 and 800,000 sats.
     *
     * Default value: 6 hours
     *
     * # Note
     *
     * When built with the `no-std` feature, time will never elapse. Therefore, the channel
     * liquidity knowledge will never decay except when the bounds cross.
     */
    get_liquidity_offset_half_life(): bigint;
    /**
     * Whenever this amount of time elapses since the last update to a channel's liquidity bounds,
     * the distance from the bounds to \"zero\" is cut in half. In other words, the lower-bound on
     * the available liquidity is halved and the upper-bound moves half-way to the channel's total
     * capacity.
     *
     * Because halving the liquidity bounds grows the uncertainty on the channel's liquidity,
     * the penalty for an amount within the new bounds may change. See the [`ProbabilisticScorer`]
     * struct documentation for more info on the way the liquidity bounds are used.
     *
     * For example, if the channel's capacity is 1 million sats, and the current upper and lower
     * liquidity bounds are 200,000 sats and 600,000 sats, after this amount of time the upper
     * and lower liquidity bounds will be decayed to 100,000 and 800,000 sats.
     *
     * Default value: 6 hours
     *
     * # Note
     *
     * When built with the `no-std` feature, time will never elapse. Therefore, the channel
     * liquidity knowledge will never decay except when the bounds cross.
     */
    set_liquidity_offset_half_life(val: bigint): void;
    /**
     * Constructs a new ProbabilisticScoringDecayParameters given each field
     */
    static constructor_new(historical_no_updates_half_life_arg: bigint, liquidity_offset_half_life_arg: bigint): ProbabilisticScoringDecayParameters;
    clone_ptr(): bigint;
    /**
     * Creates a copy of the ProbabilisticScoringDecayParameters
     */
    clone(): ProbabilisticScoringDecayParameters;
    /**
     * Creates a "default" ProbabilisticScoringDecayParameters. See struct and individual field documentaiton for details on which values are used.
     */
    static constructor_default(): ProbabilisticScoringDecayParameters;
}
