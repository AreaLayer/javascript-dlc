import { Network } from '../enums/Network.mjs';
import { Result_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ } from '../structs/Result_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ.mjs';
import { Result_RefundBolt12SemanticErrorZ } from '../structs/Result_RefundBolt12SemanticErrorZ.mjs';
import { BlindedMessagePath } from '../structs/BlindedMessagePath.mjs';
import { Nonce } from '../structs/Nonce.mjs';
import { ExpandedKey } from '../structs/ExpandedKey.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * Builds a [`Refund`] for the \"offer for money\" flow.
 *
 * See [module-level documentation] for usage.
 *
 * [module-level documentation]: self
 */
export declare class RefundMaybeWithDerivedMetadataBuilder extends CommonBase {
    clone_ptr(): bigint;
    /**
     * Creates a copy of the RefundMaybeWithDerivedMetadataBuilder
     */
    clone(): RefundMaybeWithDerivedMetadataBuilder;
    /**
     * Creates a new builder for a refund using the [`Refund::payer_id`] for the public node id to
     * send to if no [`Refund::paths`] are set. Otherwise, it may be a transient pubkey.
     *
     * Additionally, sets the required (empty) [`Refund::description`], [`Refund::payer_metadata`],
     * and [`Refund::amount_msats`].
     *
     * # Note
     *
     * If constructing a [`Refund`] for use with a [`ChannelManager`], use
     * [`ChannelManager::create_refund_builder`] instead of [`RefundBuilder::new`].
     *
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     * [`ChannelManager::create_refund_builder`]: crate::ln::channelmanager::ChannelManager::create_refund_builder
     */
    static constructor_new(metadata: Uint8Array, payer_id: Uint8Array, amount_msats: bigint): Result_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ;
    /**
     * Similar to [`RefundBuilder::new`] except, if [`RefundBuilder::path`] is called, the payer id
     * is derived from the given [`ExpandedKey`] and nonce. This provides sender privacy by using a
     * different payer id for each refund, assuming a different nonce is used.  Otherwise, the
     * provided `node_id` is used for the payer id.
     *
     * Also, sets the metadata when [`RefundBuilder::build`] is called such that it can be used by
     * [`Bolt12Invoice::verify_using_metadata`] to determine if the invoice was produced for the
     * refund given an [`ExpandedKey`]. However, if [`RefundBuilder::path`] is called, then the
     * metadata must be included in each [`BlindedMessagePath`] instead. In this case, use
     * [`Bolt12Invoice::verify_using_payer_data`].
     *
     * The `payment_id` is encrypted in the metadata and should be unique. This ensures that only
     * one invoice will be paid for the refund and that payments can be uniquely identified.
     *
     * [`Bolt12Invoice::verify_using_metadata`]: crate::offers::invoice::Bolt12Invoice::verify_using_metadata
     * [`Bolt12Invoice::verify_using_payer_data`]: crate::offers::invoice::Bolt12Invoice::verify_using_payer_data
     * [`ExpandedKey`]: crate::ln::inbound_payment::ExpandedKey
     */
    static constructor_deriving_payer_id(node_id: Uint8Array, expanded_key: ExpandedKey, nonce: Nonce, amount_msats: bigint, payment_id: Uint8Array): Result_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ;
    /**
     * Sets the [`Refund::description`].
     *
     * Successive calls to this method will override the previous setting.
     */
    description(description: string): void;
    /**
     * Sets the [`Refund::absolute_expiry`] as seconds since the Unix epoch. Any expiry that has
     * already passed is valid and can be checked for using [`Refund::is_expired`].
     *
     * Successive calls to this method will override the previous setting.
     */
    absolute_expiry(absolute_expiry: bigint): void;
    /**
     * Sets the [`Refund::issuer`].
     *
     * Successive calls to this method will override the previous setting.
     */
    issuer(issuer: string): void;
    /**
     * Adds a blinded path to [`Refund::paths`]. Must include at least one path if only connected
     * by private channels or if [`Refund::payer_id`] is not a public node id.
     *
     * Successive calls to this method will add another blinded path. Caller is responsible for not
     * adding duplicate paths.
     */
    path(path: BlindedMessagePath): void;
    /**
     * Sets the [`Refund::chain`] of the given [`Network`] for paying an invoice. If not
     * called, [`Network::Bitcoin`] is assumed.
     *
     * Successive calls to this method will override the previous setting.
     */
    chain(network: Network): void;
    /**
     * Sets [`Refund::quantity`] of items. This is purely for informational purposes. It is useful
     * when the refund pertains to a [`Bolt12Invoice`] that paid for more than one item from an
     * [`Offer`] as specified by [`InvoiceRequest::quantity`].
     *
     * Successive calls to this method will override the previous setting.
     *
     * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
     * [`InvoiceRequest::quantity`]: crate::offers::invoice_request::InvoiceRequest::quantity
     * [`Offer`]: crate::offers::offer::Offer
     */
    quantity(quantity: bigint): void;
    /**
     * Sets the [`Refund::payer_note`].
     *
     * Successive calls to this method will override the previous setting.
     */
    payer_note(payer_note: string): void;
    /**
     * Builds a [`Refund`] after checking for valid semantics.
     */
    build(): Result_RefundBolt12SemanticErrorZ;
}
