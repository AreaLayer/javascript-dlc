import { OnionMessageContents } from '../structs/OnionMessageContents.mjs';
import { Result_ReleaseHeldHtlcDecodeErrorZ } from '../structs/Result_ReleaseHeldHtlcDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
/**
 * Releases the HTLC corresponding to an inbound [`HeldHtlcAvailable`] message.
 */
export declare class ReleaseHeldHtlc extends CommonBase {
    /**
     * Used to release the HTLC held upstream if it matches the corresponding
     * [`HeldHtlcAvailable::payment_release_secret`].
     */
    get_payment_release_secret(): Uint8Array;
    /**
     * Used to release the HTLC held upstream if it matches the corresponding
     * [`HeldHtlcAvailable::payment_release_secret`].
     */
    set_payment_release_secret(val: Uint8Array): void;
    /**
     * Constructs a new ReleaseHeldHtlc given each field
     */
    static constructor_new(payment_release_secret_arg: Uint8Array): ReleaseHeldHtlc;
    clone_ptr(): bigint;
    /**
     * Creates a copy of the ReleaseHeldHtlc
     */
    clone(): ReleaseHeldHtlc;
    /**
     * Constructs a new OnionMessageContents which calls the relevant methods on this_arg.
     * This copies the `inner` pointer in this_arg and thus the returned OnionMessageContents must be freed before this_arg is
     */
    as_OnionMessageContents(): OnionMessageContents;
    /**
     * Serialize the ReleaseHeldHtlc object into a byte array which can be read by ReleaseHeldHtlc_read
     */
    write(): Uint8Array;
    /**
     * Read a ReleaseHeldHtlc from a byte array, created by ReleaseHeldHtlc_write
     */
    static constructor_read(ser: Uint8Array): Result_ReleaseHeldHtlcDecodeErrorZ;
}
