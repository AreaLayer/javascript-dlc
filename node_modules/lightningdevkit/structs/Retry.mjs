import { Result_RetryDecodeErrorZ } from '../structs/Result_RetryDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * Strategies available to retry payment path failures.
 */
export class Retry extends CommonBase {
    constructor(_dummy, ptr) { super(ptr, bindings.Retry_free); }
    /* @internal */
    static constr_from_ptr(ptr) {
        const raw_ty = bindings.LDKRetry_ty_from_ptr(ptr);
        switch (raw_ty) {
            case 0: return new Retry_Attempts(ptr);
            default:
                throw new Error('oops, this should be unreachable'); // Unreachable without extending the (internal) bindings interface
        }
    }
    clone_ptr() {
        const ret = bindings.Retry_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Retry
     */
    clone() {
        const ret = bindings.Retry_clone(this.ptr);
        const ret_hu_conv = Retry.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Utility method to constructs a new Attempts-variant Retry
     */
    static constructor_attempts(a) {
        const ret = bindings.Retry_attempts(a);
        const ret_hu_conv = Retry.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Checks if two Retrys contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     */
    eq(b) {
        const ret = bindings.Retry_eq(this.ptr, CommonBase.get_ptr_of(b));
        return ret;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the Retry.
     */
    hash() {
        const ret = bindings.Retry_hash(this.ptr);
        return ret;
    }
    /**
     * Serialize the Retry object into a byte array which can be read by Retry_read
     */
    write() {
        const ret = bindings.Retry_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Retry from a byte array, created by Retry_write
     */
    static constructor_read(ser) {
        const ret = bindings.Retry_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_RetryDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
/** A Retry of type Attempts */
export class Retry_Attempts extends Retry {
    /* @internal */
    constructor(ptr) {
        super(null, ptr);
        this.attempts = bindings.LDKRetry_Attempts_get_attempts(ptr);
    }
}
//# sourceMappingURL=Retry.mjs.map