import { RouteParameters } from '../structs/RouteParameters.mjs';
import { Path } from '../structs/Path.mjs';
import { Result_RouteDecodeErrorZ } from '../structs/Result_RouteDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */
export class Route extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.Route_free);
    }
    /**
     * The list of [`Path`]s taken for a single (potentially-)multi-part payment. If no
     * [`BlindedTail`]s are present, then the pubkey of the last [`RouteHop`] in each path must be
     * the same.
     */
    get_paths() {
        const ret = bindings.Route_get_paths(this.ptr);
        const ret_conv_6_len = bindings.getArrayLength(ret);
        const ret_conv_6_arr = new Array(ret_conv_6_len).fill(null);
        for (var g = 0; g < ret_conv_6_len; g++) {
            const ret_conv_6 = bindings.getU64ArrayElem(ret, g);
            const ret_conv_6_hu_conv = new Path(null, ret_conv_6);
            CommonBase.add_ref_from(ret_conv_6_hu_conv, this);
            ret_conv_6_arr[g] = ret_conv_6_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_6_arr;
    }
    /**
     * The list of [`Path`]s taken for a single (potentially-)multi-part payment. If no
     * [`BlindedTail`]s are present, then the pubkey of the last [`RouteHop`] in each path must be
     * the same.
     */
    set_paths(val) {
        bindings.Route_set_paths(this.ptr, bindings.encodeUint64Array(val.map(val_conv_6 => CommonBase.get_ptr_of(val_conv_6))));
    }
    /**
     * The `route_params` parameter passed to [`find_route`].
     *
     * This is used by `ChannelManager` to track information which may be required for retries.
     *
     * Will be `None` for objects serialized with LDK versions prior to 0.0.117.
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    get_route_params() {
        const ret = bindings.Route_get_route_params(this.ptr);
        const ret_hu_conv = new RouteParameters(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The `route_params` parameter passed to [`find_route`].
     *
     * This is used by `ChannelManager` to track information which may be required for retries.
     *
     * Will be `None` for objects serialized with LDK versions prior to 0.0.117.
     *
     * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    set_route_params(val) {
        bindings.Route_set_route_params(this.ptr, val == null ? 0n : CommonBase.get_ptr_of(val));
    }
    /**
     * Constructs a new Route given each field
     *
     * Note that route_params_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    static constructor_new(paths_arg, route_params_arg) {
        const ret = bindings.Route_new(bindings.encodeUint64Array(paths_arg.map(paths_arg_conv_6 => CommonBase.get_ptr_of(paths_arg_conv_6))), route_params_arg == null ? 0n : CommonBase.get_ptr_of(route_params_arg));
        const ret_hu_conv = new Route(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    clone_ptr() {
        const ret = bindings.Route_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the Route
     */
    clone() {
        const ret = bindings.Route_clone(this.ptr);
        const ret_hu_conv = new Route(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Generates a non-cryptographic 64-bit hash of the Route.
     */
    hash() {
        const ret = bindings.Route_hash(this.ptr);
        return ret;
    }
    /**
     * Checks if two Routes contain equal inner contents.
     * This ignores pointers and is_owned flags and looks at the values in fields.
     * Two objects with NULL inner values will be considered "equal" here.
     */
    eq(b) {
        const ret = bindings.Route_eq(this.ptr, CommonBase.get_ptr_of(b));
        CommonBase.add_ref_from(this, b);
        return ret;
    }
    /**
     * Returns the total amount of fees paid on this [`Route`].
     *
     * For objects serialized with LDK 0.0.117 and after, this includes any extra payment made to
     * the recipient, which can happen in excess of the amount passed to [`find_route`] via
     * [`RouteParameters::final_value_msat`], if we had to reach the [`htlc_minimum_msat`] limits.
     *
     * [`htlc_minimum_msat`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_update-message
     */
    get_total_fees() {
        const ret = bindings.Route_get_total_fees(this.ptr);
        return ret;
    }
    /**
     * Returns the total amount paid on this [`Route`], excluding the fees.
     *
     * Might be more than requested as part of the given [`RouteParameters::final_value_msat`] if
     * we had to reach the [`htlc_minimum_msat`] limits.
     *
     * [`htlc_minimum_msat`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_update-message
     */
    get_total_amount() {
        const ret = bindings.Route_get_total_amount(this.ptr);
        return ret;
    }
    /**
     * Get the string representation of a Route object
     */
    to_str() {
        const ret = bindings.Route_to_str(this.ptr);
        const ret_conv = bindings.decodeString(ret);
        return ret_conv;
    }
    /**
     * Serialize the Route object into a byte array which can be read by Route_read
     */
    write() {
        const ret = bindings.Route_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a Route from a byte array, created by Route_write
     */
    static constructor_read(ser) {
        const ret = bindings.Route_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_RouteDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=Route.mjs.map