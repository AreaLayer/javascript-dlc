import { RouteParameters } from '../structs/RouteParameters.mjs';
import { ChannelDetails } from '../structs/ChannelDetails.mjs';
import { Result_RouteLightningErrorZ } from '../structs/Result_RouteLightningErrorZ.mjs';
import { Result_CVec_BlindedPaymentPathZNoneZ } from '../structs/Result_CVec_BlindedPaymentPathZNoneZ.mjs';
import { InFlightHtlcs } from '../structs/InFlightHtlcs.mjs';
import { ReceiveTlvs } from '../structs/ReceiveTlvs.mjs';
import { MessageRouter } from '../structs/MessageRouter.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKRouterHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait defining behavior for routing a payment.
 */
export class Router extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.Router_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Router from a given implementation */
    static new_impl(arg, messageRouter_impl) {
        const impl_holder = new LDKRouterHolder();
        let structImplementation = {
            find_route(payer, route_params, first_hops, inflight_htlcs) {
                const payer_conv = bindings.decodeUint8Array(payer);
                const route_params_hu_conv = new RouteParameters(null, route_params);
                const first_hops_conv_16_len = bindings.getArrayLength(first_hops);
                const first_hops_conv_16_arr = new Array(first_hops_conv_16_len).fill(null);
                if (first_hops != null) {
                    for (var q = 0; q < first_hops_conv_16_len; q++) {
                        const first_hops_conv_16 = bindings.getU64ArrayElem(first_hops, q);
                        const first_hops_conv_16_hu_conv = new ChannelDetails(null, first_hops_conv_16);
                        CommonBase.add_ref_from(first_hops_conv_16_hu_conv, this);
                        first_hops_conv_16_arr[q] = first_hops_conv_16_hu_conv;
                    }
                }
                bindings.freeWasmMemory(first_hops);
                const inflight_htlcs_hu_conv = new InFlightHtlcs(null, inflight_htlcs);
                CommonBase.add_ref_from(inflight_htlcs_hu_conv, this);
                const ret = arg.find_route(payer_conv, route_params_hu_conv, first_hops_conv_16_arr, inflight_htlcs_hu_conv);
                const result = ret.clone_ptr();
                return result;
            },
            find_route_with_id(payer, route_params, first_hops, inflight_htlcs, _payment_hash, _payment_id) {
                const payer_conv = bindings.decodeUint8Array(payer);
                const route_params_hu_conv = new RouteParameters(null, route_params);
                const first_hops_conv_16_len = bindings.getArrayLength(first_hops);
                const first_hops_conv_16_arr = new Array(first_hops_conv_16_len).fill(null);
                if (first_hops != null) {
                    for (var q = 0; q < first_hops_conv_16_len; q++) {
                        const first_hops_conv_16 = bindings.getU64ArrayElem(first_hops, q);
                        const first_hops_conv_16_hu_conv = new ChannelDetails(null, first_hops_conv_16);
                        CommonBase.add_ref_from(first_hops_conv_16_hu_conv, this);
                        first_hops_conv_16_arr[q] = first_hops_conv_16_hu_conv;
                    }
                }
                bindings.freeWasmMemory(first_hops);
                const inflight_htlcs_hu_conv = new InFlightHtlcs(null, inflight_htlcs);
                CommonBase.add_ref_from(inflight_htlcs_hu_conv, this);
                const _payment_hash_conv = bindings.decodeUint8Array(_payment_hash);
                const _payment_id_conv = bindings.decodeUint8Array(_payment_id);
                const ret = arg.find_route_with_id(payer_conv, route_params_hu_conv, first_hops_conv_16_arr, inflight_htlcs_hu_conv, _payment_hash_conv, _payment_id_conv);
                const result = ret.clone_ptr();
                return result;
            },
            create_blinded_payment_paths(recipient, first_hops, tlvs, amount_msats) {
                const recipient_conv = bindings.decodeUint8Array(recipient);
                const first_hops_conv_16_len = bindings.getArrayLength(first_hops);
                const first_hops_conv_16_arr = new Array(first_hops_conv_16_len).fill(null);
                for (var q = 0; q < first_hops_conv_16_len; q++) {
                    const first_hops_conv_16 = bindings.getU64ArrayElem(first_hops, q);
                    const first_hops_conv_16_hu_conv = new ChannelDetails(null, first_hops_conv_16);
                    CommonBase.add_ref_from(first_hops_conv_16_hu_conv, this);
                    first_hops_conv_16_arr[q] = first_hops_conv_16_hu_conv;
                }
                bindings.freeWasmMemory(first_hops);
                const tlvs_hu_conv = new ReceiveTlvs(null, tlvs);
                CommonBase.add_ref_from(tlvs_hu_conv, this);
                const ret = arg.create_blinded_payment_paths(recipient_conv, first_hops_conv_16_arr, tlvs_hu_conv, amount_msats);
                const result = ret.clone_ptr();
                return result;
            },
        };
        const messageRouter = MessageRouter.new_impl(messageRouter_impl);
        const ptr_idx = bindings.LDKRouter_new(structImplementation, messageRouter.instance_idx);
        impl_holder.held = new Router(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(messageRouter);
        return impl_holder.held;
    }
    /**
     * Finds a [`Route`] for a payment between the given `payer` and a payee.
     *
     * The `payee` and the payment's value are given in [`RouteParameters::payment_params`]
     * and [`RouteParameters::final_value_msat`], respectively.
     *
     * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    find_route(payer, route_params, first_hops, inflight_htlcs) {
        const ret = bindings.Router_find_route(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(payer, 33)), CommonBase.get_ptr_of(route_params), bindings.encodeUint64Array(first_hops != null ? first_hops.map(first_hops_conv_16 => CommonBase.get_ptr_of(first_hops_conv_16)) : null), CommonBase.get_ptr_of(inflight_htlcs));
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, route_params);
        if (first_hops != null) {
            first_hops.forEach((first_hops_conv_16) => { CommonBase.add_ref_from(this, first_hops_conv_16); });
        }
        ;
        return ret_hu_conv;
    }
    /**
     * Finds a [`Route`] for a payment between the given `payer` and a payee.
     *
     * The `payee` and the payment's value are given in [`RouteParameters::payment_params`]
     * and [`RouteParameters::final_value_msat`], respectively.
     *
     * Includes a [`PaymentHash`] and a [`PaymentId`] to be able to correlate the request with a specific
     * payment.
     *
     * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    find_route_with_id(payer, route_params, first_hops, inflight_htlcs, _payment_hash, _payment_id) {
        const ret = bindings.Router_find_route_with_id(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(payer, 33)), CommonBase.get_ptr_of(route_params), bindings.encodeUint64Array(first_hops != null ? first_hops.map(first_hops_conv_16 => CommonBase.get_ptr_of(first_hops_conv_16)) : null), CommonBase.get_ptr_of(inflight_htlcs), bindings.encodeUint8Array(bindings.check_arr_len(_payment_hash, 32)), bindings.encodeUint8Array(bindings.check_arr_len(_payment_id, 32)));
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(this, route_params);
        if (first_hops != null) {
            first_hops.forEach((first_hops_conv_16) => { CommonBase.add_ref_from(this, first_hops_conv_16); });
        }
        ;
        return ret_hu_conv;
    }
    /**
     * Creates [`BlindedPaymentPath`]s for payment to the `recipient` node. The channels in `first_hops`
     * are assumed to be with the `recipient`'s peers. The payment secret and any constraints are
     * given in `tlvs`.
     */
    create_blinded_payment_paths(recipient, first_hops, tlvs, amount_msats) {
        const ret = bindings.Router_create_blinded_payment_paths(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(recipient, 33)), bindings.encodeUint64Array(first_hops.map(first_hops_conv_16 => CommonBase.get_ptr_of(first_hops_conv_16))), CommonBase.get_ptr_of(tlvs), amount_msats);
        const ret_hu_conv = Result_CVec_BlindedPaymentPathZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=Router.mjs.map