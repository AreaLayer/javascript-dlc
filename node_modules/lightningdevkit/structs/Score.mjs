import { ScoreLookUp } from '../structs/ScoreLookUp.mjs';
import { ScoreUpdate } from '../structs/ScoreUpdate.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKScoreHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait which can both lookup and update routing channel penalty scores.
 *
 * This is used in places where both bounds are required and implemented for all types which
 * implement [`ScoreLookUp`] and [`ScoreUpdate`].
 *
 * Bindings users may need to manually implement this for their custom scoring implementations.
 */
export class Score extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.Score_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of Score from a given implementation */
    static new_impl(arg, scoreLookUp_impl, scoreUpdate_impl) {
        const impl_holder = new LDKScoreHolder();
        let structImplementation = {
            write() {
                const ret = arg.write();
                const result = bindings.encodeUint8Array(ret);
                return result;
            },
        };
        const scoreLookUp = ScoreLookUp.new_impl(scoreLookUp_impl);
        const scoreUpdate = ScoreUpdate.new_impl(scoreUpdate_impl);
        const ptr_idx = bindings.LDKScore_new(structImplementation, scoreLookUp.instance_idx, scoreUpdate.instance_idx);
        impl_holder.held = new Score(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        impl_holder.held.ptrs_to.push(scoreLookUp);
        impl_holder.held.ptrs_to.push(scoreUpdate);
        return impl_holder.held;
    }
    /**
     * Serialize the object into a byte array
     */
    write() {
        const ret = bindings.Score_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
}
//# sourceMappingURL=Score.mjs.map