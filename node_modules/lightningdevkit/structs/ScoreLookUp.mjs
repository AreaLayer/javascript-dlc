import { CandidateRouteHop } from '../structs/CandidateRouteHop.mjs';
import { ChannelUsage } from '../structs/ChannelUsage.mjs';
import { ProbabilisticScoringFeeParameters } from '../structs/ProbabilisticScoringFeeParameters.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKScoreLookUpHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * An interface used to score payment channels for path finding.
 *
 * `ScoreLookUp` is used to determine the penalty for a given channel.
 *
 * Scoring is in terms of fees willing to be paid in order to avoid routing through a channel.
 */
export class ScoreLookUp extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ScoreLookUp_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of ScoreLookUp from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKScoreLookUpHolder();
        let structImplementation = {
            channel_penalty_msat(candidate, usage, score_params) {
                const candidate_hu_conv = CandidateRouteHop.constr_from_ptr(candidate);
                const usage_hu_conv = new ChannelUsage(null, usage);
                CommonBase.add_ref_from(usage_hu_conv, this);
                const score_params_hu_conv = new ProbabilisticScoringFeeParameters(null, score_params);
                const ret = arg.channel_penalty_msat(candidate_hu_conv, usage_hu_conv, score_params_hu_conv);
                return ret;
            },
        };
        const ptr_idx = bindings.LDKScoreLookUp_new(structImplementation);
        impl_holder.held = new ScoreLookUp(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns the fee in msats willing to be paid to avoid routing `send_amt_msat` through the
     * given channel in the direction from `source` to `target`.
     *
     * The channel's capacity (less any other MPP parts that are also being considered for use in
     * the same payment) is given by `capacity_msat`. It may be determined from various sources
     * such as a chain data, network gossip, or invoice hints. For invoice hints, a capacity near
     * [`u64::max_value`] is given to indicate sufficient capacity for the invoice's full amount.
     * Thus, implementations should be overflow-safe.
     */
    channel_penalty_msat(candidate, usage, score_params) {
        const ret = bindings.ScoreLookUp_channel_penalty_msat(this.ptr, CommonBase.get_ptr_of(candidate), CommonBase.get_ptr_of(usage), CommonBase.get_ptr_of(score_params));
        CommonBase.add_ref_from(this, score_params);
        return ret;
    }
}
//# sourceMappingURL=ScoreLookUp.mjs.map