import { Path } from '../structs/Path.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKScoreUpdateHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * `ScoreUpdate` is used to update the scorer's internal state after a payment attempt.
 */
export class ScoreUpdate extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.ScoreUpdate_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of ScoreUpdate from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKScoreUpdateHolder();
        let structImplementation = {
            payment_path_failed(path, short_channel_id, duration_since_epoch) {
                const path_hu_conv = new Path(null, path);
                arg.payment_path_failed(path_hu_conv, short_channel_id, duration_since_epoch);
            },
            payment_path_successful(path, duration_since_epoch) {
                const path_hu_conv = new Path(null, path);
                arg.payment_path_successful(path_hu_conv, duration_since_epoch);
            },
            probe_failed(path, short_channel_id, duration_since_epoch) {
                const path_hu_conv = new Path(null, path);
                arg.probe_failed(path_hu_conv, short_channel_id, duration_since_epoch);
            },
            probe_successful(path, duration_since_epoch) {
                const path_hu_conv = new Path(null, path);
                arg.probe_successful(path_hu_conv, duration_since_epoch);
            },
            time_passed(duration_since_epoch) {
                arg.time_passed(duration_since_epoch);
            },
        };
        const ptr_idx = bindings.LDKScoreUpdate_new(structImplementation);
        impl_holder.held = new ScoreUpdate(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Handles updating channel penalties after failing to route through a channel.
     */
    payment_path_failed(path, short_channel_id, duration_since_epoch) {
        bindings.ScoreUpdate_payment_path_failed(this.ptr, CommonBase.get_ptr_of(path), short_channel_id, duration_since_epoch);
        CommonBase.add_ref_from(this, path);
    }
    /**
     * Handles updating channel penalties after successfully routing along a path.
     */
    payment_path_successful(path, duration_since_epoch) {
        bindings.ScoreUpdate_payment_path_successful(this.ptr, CommonBase.get_ptr_of(path), duration_since_epoch);
        CommonBase.add_ref_from(this, path);
    }
    /**
     * Handles updating channel penalties after a probe over the given path failed.
     */
    probe_failed(path, short_channel_id, duration_since_epoch) {
        bindings.ScoreUpdate_probe_failed(this.ptr, CommonBase.get_ptr_of(path), short_channel_id, duration_since_epoch);
        CommonBase.add_ref_from(this, path);
    }
    /**
     * Handles updating channel penalties after a probe over the given path succeeded.
     */
    probe_successful(path, duration_since_epoch) {
        bindings.ScoreUpdate_probe_successful(this.ptr, CommonBase.get_ptr_of(path), duration_since_epoch);
        CommonBase.add_ref_from(this, path);
    }
    /**
     * Scorers may wish to reduce their certainty of channel liquidity information over time.
     * Thus, this method is provided to allow scorers to observe the passage of time - the holder
     * of this object should call this method regularly (generally via the
     * `lightning-background-processor` crate).
     */
    time_passed(duration_since_epoch) {
        bindings.ScoreUpdate_time_passed(this.ptr, duration_since_epoch);
    }
}
//# sourceMappingURL=ScoreUpdate.mjs.map