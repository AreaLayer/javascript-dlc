import { EcdsaChannelSigner } from '../structs/EcdsaChannelSigner.mjs';
import { Result_EcdsaChannelSignerDecodeErrorZ } from '../structs/Result_EcdsaChannelSignerDecodeErrorZ.mjs';
import { Result_CVec_u8ZNoneZ } from '../structs/Result_CVec_u8ZNoneZ.mjs';
import { Result_ShutdownScriptNoneZ } from '../structs/Result_ShutdownScriptNoneZ.mjs';
import { CommonBase } from './CommonBase.mjs';
/** An implementation of SignerProvider */
export interface SignerProviderInterface {
    /**Generates a unique `channel_keys_id` that can be used to obtain a [`Self::EcdsaSigner`] through
     * [`SignerProvider::derive_channel_signer`]. The `user_channel_id` is provided to allow
     * implementations of [`SignerProvider`] to maintain a mapping between itself and the generated
     * `channel_keys_id`.
     *
     * This method must return a different value each time it is called.
     */
    generate_channel_keys_id(inbound: boolean, channel_value_satoshis: bigint, user_channel_id: bigint): Uint8Array;
    /**Derives the private key material backing a `Signer`.
     *
     * To derive a new `Signer`, a fresh `channel_keys_id` should be obtained through
     * [`SignerProvider::generate_channel_keys_id`]. Otherwise, an existing `Signer` can be
     * re-derived from its `channel_keys_id`, which can be obtained through its trait method
     * [`ChannelSigner::channel_keys_id`].
     */
    derive_channel_signer(channel_value_satoshis: bigint, channel_keys_id: Uint8Array): EcdsaChannelSigner;
    /**Reads a [`Signer`] for this [`SignerProvider`] from the given input stream.
     * This is only called during deserialization of other objects which contain
     * [`EcdsaChannelSigner`]-implementing objects (i.e., [`ChannelMonitor`]s and [`ChannelManager`]s).
     * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
     * contain no versioning scheme. You may wish to include your own version prefix and ensure
     * you've read all of the provided bytes to ensure no corruption occurred.
     *
     * This method is slowly being phased out -- it will only be called when reading objects
     * written by LDK versions prior to 0.0.113.
     *
     * [`Signer`]: Self::EcdsaSigner
     * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     */
    read_chan_signer(reader: Uint8Array): Result_EcdsaChannelSignerDecodeErrorZ;
    /**Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
     *
     * If this function returns an error, this will result in a channel failing to open.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user. `channel_keys_id` may be
     * used to derive a unique value for each channel.
     */
    get_destination_script(channel_keys_id: Uint8Array): Result_CVec_u8ZNoneZ;
    /**Get a script pubkey which we will send funds to when closing a channel.
     *
     * If this function returns an error, this will result in a channel failing to open or close.
     * In the event of a failure when the counterparty is initiating a close, this can result in a
     * channel force close.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user.
     */
    get_shutdown_scriptpubkey(): Result_ShutdownScriptNoneZ;
}
/**
 * A trait that can return signer instances for individual channels.
 */
export declare class SignerProvider extends CommonBase {
    /** Creates a new instance of SignerProvider from a given implementation */
    static new_impl(arg: SignerProviderInterface): SignerProvider;
    /**
     * Generates a unique `channel_keys_id` that can be used to obtain a [`Self::EcdsaSigner`] through
     * [`SignerProvider::derive_channel_signer`]. The `user_channel_id` is provided to allow
     * implementations of [`SignerProvider`] to maintain a mapping between itself and the generated
     * `channel_keys_id`.
     *
     * This method must return a different value each time it is called.
     */
    generate_channel_keys_id(inbound: boolean, channel_value_satoshis: bigint, user_channel_id: bigint): Uint8Array;
    /**
     * Derives the private key material backing a `Signer`.
     *
     * To derive a new `Signer`, a fresh `channel_keys_id` should be obtained through
     * [`SignerProvider::generate_channel_keys_id`]. Otherwise, an existing `Signer` can be
     * re-derived from its `channel_keys_id`, which can be obtained through its trait method
     * [`ChannelSigner::channel_keys_id`].
     */
    derive_channel_signer(channel_value_satoshis: bigint, channel_keys_id: Uint8Array): EcdsaChannelSigner;
    /**
     * Reads a [`Signer`] for this [`SignerProvider`] from the given input stream.
     * This is only called during deserialization of other objects which contain
     * [`EcdsaChannelSigner`]-implementing objects (i.e., [`ChannelMonitor`]s and [`ChannelManager`]s).
     * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
     * contain no versioning scheme. You may wish to include your own version prefix and ensure
     * you've read all of the provided bytes to ensure no corruption occurred.
     *
     * This method is slowly being phased out -- it will only be called when reading objects
     * written by LDK versions prior to 0.0.113.
     *
     * [`Signer`]: Self::EcdsaSigner
     * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     */
    read_chan_signer(reader: Uint8Array): Result_EcdsaChannelSignerDecodeErrorZ;
    /**
     * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
     *
     * If this function returns an error, this will result in a channel failing to open.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user. `channel_keys_id` may be
     * used to derive a unique value for each channel.
     */
    get_destination_script(channel_keys_id: Uint8Array): Result_CVec_u8ZNoneZ;
    /**
     * Get a script pubkey which we will send funds to when closing a channel.
     *
     * If this function returns an error, this will result in a channel failing to open or close.
     * In the event of a failure when the counterparty is initiating a close, this can result in a
     * channel force close.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user.
     */
    get_shutdown_scriptpubkey(): Result_ShutdownScriptNoneZ;
}
