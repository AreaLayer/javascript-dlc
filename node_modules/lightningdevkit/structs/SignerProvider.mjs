import { EcdsaChannelSigner } from '../structs/EcdsaChannelSigner.mjs';
import { Result_EcdsaChannelSignerDecodeErrorZ } from '../structs/Result_EcdsaChannelSignerDecodeErrorZ.mjs';
import { Result_CVec_u8ZNoneZ } from '../structs/Result_CVec_u8ZNoneZ.mjs';
import { Result_ShutdownScriptNoneZ } from '../structs/Result_ShutdownScriptNoneZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKSignerProviderHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * A trait that can return signer instances for individual channels.
 */
export class SignerProvider extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.SignerProvider_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of SignerProvider from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKSignerProviderHolder();
        let structImplementation = {
            generate_channel_keys_id(inbound, channel_value_satoshis, user_channel_id) {
                const user_channel_id_conv = bindings.decodeUint128(user_channel_id);
                const ret = arg.generate_channel_keys_id(inbound, channel_value_satoshis, user_channel_id_conv);
                const result = bindings.encodeUint8Array(bindings.check_arr_len(ret, 32));
                return result;
            },
            derive_channel_signer(channel_value_satoshis, channel_keys_id) {
                const channel_keys_id_conv = bindings.decodeUint8Array(channel_keys_id);
                const ret = arg.derive_channel_signer(channel_value_satoshis, channel_keys_id_conv);
                const result = ret.clone_ptr();
                CommonBase.add_ref_from(impl_holder.held, ret);
                return result;
            },
            read_chan_signer(reader) {
                const reader_conv = bindings.decodeUint8Array(reader);
                const ret = arg.read_chan_signer(reader_conv);
                const result = ret.clone_ptr();
                return result;
            },
            get_destination_script(channel_keys_id) {
                const channel_keys_id_conv = bindings.decodeUint8Array(channel_keys_id);
                const ret = arg.get_destination_script(channel_keys_id_conv);
                const result = ret.clone_ptr();
                return result;
            },
            get_shutdown_scriptpubkey() {
                const ret = arg.get_shutdown_scriptpubkey();
                const result = ret.clone_ptr();
                return result;
            },
        };
        const ptr_idx = bindings.LDKSignerProvider_new(structImplementation);
        impl_holder.held = new SignerProvider(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Generates a unique `channel_keys_id` that can be used to obtain a [`Self::EcdsaSigner`] through
     * [`SignerProvider::derive_channel_signer`]. The `user_channel_id` is provided to allow
     * implementations of [`SignerProvider`] to maintain a mapping between itself and the generated
     * `channel_keys_id`.
     *
     * This method must return a different value each time it is called.
     */
    generate_channel_keys_id(inbound, channel_value_satoshis, user_channel_id) {
        const ret = bindings.SignerProvider_generate_channel_keys_id(this.ptr, inbound, channel_value_satoshis, bindings.encodeUint128(user_channel_id));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Derives the private key material backing a `Signer`.
     *
     * To derive a new `Signer`, a fresh `channel_keys_id` should be obtained through
     * [`SignerProvider::generate_channel_keys_id`]. Otherwise, an existing `Signer` can be
     * re-derived from its `channel_keys_id`, which can be obtained through its trait method
     * [`ChannelSigner::channel_keys_id`].
     */
    derive_channel_signer(channel_value_satoshis, channel_keys_id) {
        const ret = bindings.SignerProvider_derive_channel_signer(this.ptr, channel_value_satoshis, bindings.encodeUint8Array(bindings.check_arr_len(channel_keys_id, 32)));
        const ret_hu_conv = new EcdsaChannelSigner(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Reads a [`Signer`] for this [`SignerProvider`] from the given input stream.
     * This is only called during deserialization of other objects which contain
     * [`EcdsaChannelSigner`]-implementing objects (i.e., [`ChannelMonitor`]s and [`ChannelManager`]s).
     * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
     * contain no versioning scheme. You may wish to include your own version prefix and ensure
     * you've read all of the provided bytes to ensure no corruption occurred.
     *
     * This method is slowly being phased out -- it will only be called when reading objects
     * written by LDK versions prior to 0.0.113.
     *
     * [`Signer`]: Self::EcdsaSigner
     * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
     * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
     */
    read_chan_signer(reader) {
        const ret = bindings.SignerProvider_read_chan_signer(this.ptr, bindings.encodeUint8Array(reader));
        const ret_hu_conv = Result_EcdsaChannelSignerDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
     *
     * If this function returns an error, this will result in a channel failing to open.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user. `channel_keys_id` may be
     * used to derive a unique value for each channel.
     */
    get_destination_script(channel_keys_id) {
        const ret = bindings.SignerProvider_get_destination_script(this.ptr, bindings.encodeUint8Array(bindings.check_arr_len(channel_keys_id, 32)));
        const ret_hu_conv = Result_CVec_u8ZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Get a script pubkey which we will send funds to when closing a channel.
     *
     * If this function returns an error, this will result in a channel failing to open or close.
     * In the event of a failure when the counterparty is initiating a close, this can result in a
     * channel force close.
     *
     * This method should return a different value each time it is called, to avoid linking
     * on-chain funds across channels as controlled to the same user.
     */
    get_shutdown_scriptpubkey() {
        const ret = bindings.SignerProvider_get_shutdown_scriptpubkey(this.ptr);
        const ret_hu_conv = Result_ShutdownScriptNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=SignerProvider.mjs.map