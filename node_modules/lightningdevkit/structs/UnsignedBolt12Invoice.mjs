import { Option_u64Z } from '../structs/Option_u64Z.mjs';
import { BlindedMessagePath } from '../structs/BlindedMessagePath.mjs';
import { Option_CVec_u8ZZ } from '../structs/Option_CVec_u8ZZ.mjs';
import { Option_CVec_ThirtyTwoBytesZZ } from '../structs/Option_CVec_ThirtyTwoBytesZZ.mjs';
import { Option_AmountZ } from '../structs/Option_AmountZ.mjs';
import { Option_QuantityZ } from '../structs/Option_QuantityZ.mjs';
import { Bolt12InvoiceFeatures } from '../structs/Bolt12InvoiceFeatures.mjs';
import { PrintableString } from '../structs/PrintableString.mjs';
import { OfferFeatures } from '../structs/OfferFeatures.mjs';
import { TaggedHash } from '../structs/TaggedHash.mjs';
import { InvoiceRequestFeatures } from '../structs/InvoiceRequestFeatures.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
/**
 * A semantically valid [`Bolt12Invoice`] that hasn't been signed.
 *
 * # Serialization
 *
 * This is serialized as a TLV stream, which includes TLV records from the originating message. As
 * such, it may include unknown, odd TLV records.
 */
export class UnsignedBolt12Invoice extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.UnsignedBolt12Invoice_free);
    }
    clone_ptr() {
        const ret = bindings.UnsignedBolt12Invoice_clone_ptr(this.ptr);
        return ret;
    }
    /**
     * Creates a copy of the UnsignedBolt12Invoice
     */
    clone() {
        const ret = bindings.UnsignedBolt12Invoice_clone(this.ptr);
        const ret_hu_conv = new UnsignedBolt12Invoice(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Returns the [`TaggedHash`] of the invoice to sign.
     */
    tagged_hash() {
        const ret = bindings.UnsignedBolt12Invoice_tagged_hash(this.ptr);
        const ret_hu_conv = new TaggedHash(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Duration since the Unix epoch when the invoice was created.
     */
    created_at() {
        const ret = bindings.UnsignedBolt12Invoice_created_at(this.ptr);
        return ret;
    }
    /**
     * Duration since
     * [`Bolt12Invoice::created_at`]
     * when the invoice has expired and therefore should no longer be paid.
     */
    relative_expiry() {
        const ret = bindings.UnsignedBolt12Invoice_relative_expiry(this.ptr);
        return ret;
    }
    /**
     * Fallback addresses for paying the invoice on-chain, in order of most-preferred to
     * least-preferred.
     */
    fallbacks() {
        const ret = bindings.UnsignedBolt12Invoice_fallbacks(this.ptr);
        const ret_conv_8_len = bindings.getArrayLength(ret);
        const ret_conv_8_arr = new Array(ret_conv_8_len).fill(null);
        for (var i = 0; i < ret_conv_8_len; i++) {
            const ret_conv_8 = bindings.getU32ArrayElem(ret, i);
            const ret_conv_8_conv = bindings.decodeString(ret_conv_8);
            ret_conv_8_arr[i] = ret_conv_8_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_8_arr;
    }
    /**
     * Features pertaining to paying an invoice.
     */
    invoice_features() {
        const ret = bindings.UnsignedBolt12Invoice_invoice_features(this.ptr);
        const ret_hu_conv = new Bolt12InvoiceFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The public key corresponding to the key used to sign the invoice.
     */
    signing_pubkey() {
        const ret = bindings.UnsignedBolt12Invoice_signing_pubkey(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The chains that may be used when paying a requested invoice.
     *
     * From [`Offer::chains`]; `None` if the invoice was created in response to a [`Refund`].
     *
     * [`Offer::chains`]: crate::offers::offer::Offer::chains
     */
    offer_chains() {
        const ret = bindings.UnsignedBolt12Invoice_offer_chains(this.ptr);
        const ret_hu_conv = Option_CVec_ThirtyTwoBytesZZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The chain that must be used when paying the invoice; selected from [`offer_chains`] if the
     * invoice originated from an offer.
     *
     * From [`InvoiceRequest::chain`] or [`Refund::chain`].
     *
     * [`offer_chains`]: Self::offer_chains
     * [`InvoiceRequest::chain`]: crate::offers::invoice_request::InvoiceRequest::chain
     */
    chain() {
        const ret = bindings.UnsignedBolt12Invoice_chain(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Opaque bytes set by the originating [`Offer`].
     *
     * From [`Offer::metadata`]; `None` if the invoice was created in response to a [`Refund`] or
     * if the [`Offer`] did not set it.
     *
     * [`Offer`]: crate::offers::offer::Offer
     * [`Offer::metadata`]: crate::offers::offer::Offer::metadata
     */
    metadata() {
        const ret = bindings.UnsignedBolt12Invoice_metadata(this.ptr);
        const ret_hu_conv = Option_CVec_u8ZZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The minimum amount required for a successful payment of a single item.
     *
     * From [`Offer::amount`]; `None` if the invoice was created in response to a [`Refund`] or if
     * the [`Offer`] did not set it.
     *
     * [`Offer`]: crate::offers::offer::Offer
     * [`Offer::amount`]: crate::offers::offer::Offer::amount
     */
    amount() {
        const ret = bindings.UnsignedBolt12Invoice_amount(this.ptr);
        const ret_hu_conv = Option_AmountZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Features pertaining to the originating [`Offer`].
     *
     * From [`Offer::offer_features`]; `None` if the invoice was created in response to a
     * [`Refund`].
     *
     * [`Offer`]: crate::offers::offer::Offer
     * [`Offer::offer_features`]: crate::offers::offer::Offer::offer_features
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    offer_features() {
        const ret = bindings.UnsignedBolt12Invoice_offer_features(this.ptr);
        const ret_hu_conv = new OfferFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * A complete description of the purpose of the originating offer or refund.
     *
     * From [`Offer::description`] or [`Refund::description`].
     *
     * [`Offer::description`]: crate::offers::offer::Offer::description
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    description() {
        const ret = bindings.UnsignedBolt12Invoice_description(this.ptr);
        const ret_hu_conv = new PrintableString(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Duration since the Unix epoch when an invoice should no longer be requested.
     *
     * From [`Offer::absolute_expiry`] or [`Refund::absolute_expiry`].
     *
     * [`Offer::absolute_expiry`]: crate::offers::offer::Offer::absolute_expiry
     */
    absolute_expiry() {
        const ret = bindings.UnsignedBolt12Invoice_absolute_expiry(this.ptr);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The issuer of the offer or refund.
     *
     * From [`Offer::issuer`] or [`Refund::issuer`].
     *
     * [`Offer::issuer`]: crate::offers::offer::Offer::issuer
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    issuer() {
        const ret = bindings.UnsignedBolt12Invoice_issuer(this.ptr);
        const ret_hu_conv = new PrintableString(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * Paths to the recipient originating from publicly reachable nodes.
     *
     * From [`Offer::paths`] or [`Refund::paths`].
     *
     * [`Offer::paths`]: crate::offers::offer::Offer::paths
     */
    message_paths() {
        const ret = bindings.UnsignedBolt12Invoice_message_paths(this.ptr);
        const ret_conv_20_len = bindings.getArrayLength(ret);
        const ret_conv_20_arr = new Array(ret_conv_20_len).fill(null);
        for (var u = 0; u < ret_conv_20_len; u++) {
            const ret_conv_20 = bindings.getU64ArrayElem(ret, u);
            const ret_conv_20_hu_conv = new BlindedMessagePath(null, ret_conv_20);
            CommonBase.add_ref_from(ret_conv_20_hu_conv, this);
            ret_conv_20_arr[u] = ret_conv_20_hu_conv;
        }
        bindings.freeWasmMemory(ret);
        return ret_conv_20_arr;
    }
    /**
     * The quantity of items supported.
     *
     * From [`Offer::supported_quantity`]; `None` if the invoice was created in response to a
     * [`Refund`].
     *
     * [`Offer::supported_quantity`]: crate::offers::offer::Offer::supported_quantity
     */
    supported_quantity() {
        const ret = bindings.UnsignedBolt12Invoice_supported_quantity(this.ptr);
        const ret_hu_conv = Option_QuantityZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * An unpredictable series of bytes from the payer.
     *
     * From [`InvoiceRequest::payer_metadata`] or [`Refund::payer_metadata`].
     */
    payer_metadata() {
        const ret = bindings.UnsignedBolt12Invoice_payer_metadata(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Features pertaining to requesting an invoice.
     *
     * From [`InvoiceRequest::invoice_request_features`] or [`Refund::features`].
     */
    invoice_request_features() {
        const ret = bindings.UnsignedBolt12Invoice_invoice_request_features(this.ptr);
        const ret_hu_conv = new InvoiceRequestFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * The quantity of items requested or refunded for.
     *
     * From [`InvoiceRequest::quantity`] or [`Refund::quantity`].
     */
    quantity() {
        const ret = bindings.UnsignedBolt12Invoice_quantity(this.ptr);
        const ret_hu_conv = Option_u64Z.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * A possibly transient pubkey used to sign the invoice request or to send an invoice for a
     * refund in case there are no [`message_paths`].
     *
     * [`message_paths`]: Self::message_paths
     */
    payer_id() {
        const ret = bindings.UnsignedBolt12Invoice_payer_id(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A payer-provided note reflected back in the invoice.
     *
     * From [`InvoiceRequest::payer_note`] or [`Refund::payer_note`].
     *
     * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    payer_note() {
        const ret = bindings.UnsignedBolt12Invoice_payer_note(this.ptr);
        const ret_hu_conv = new PrintableString(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, this);
        return ret_hu_conv;
    }
    /**
     * SHA256 hash of the payment preimage that will be given in return for paying the invoice.
     */
    payment_hash() {
        const ret = bindings.UnsignedBolt12Invoice_payment_hash(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * The minimum amount required for a successful payment of the invoice.
     */
    amount_msats() {
        const ret = bindings.UnsignedBolt12Invoice_amount_msats(this.ptr);
        return ret;
    }
    /**
     * Serialize the UnsignedBolt12Invoice object into a byte array which can be read by UnsignedBolt12Invoice_read
     */
    write() {
        const ret = bindings.UnsignedBolt12Invoice_write(this.ptr);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
}
//# sourceMappingURL=UnsignedBolt12Invoice.mjs.map