import { Result_ThirtyTwoBytesNoneZ } from '../structs/Result_ThirtyTwoBytesNoneZ.mjs';
import { Result_C2Tuple_CVec_u8Zu64ZNoneZ } from '../structs/Result_C2Tuple_CVec_u8Zu64ZNoneZ.mjs';
import { Result_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ } from '../structs/Result_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ.mjs';
import { Result_RouteLightningErrorZ } from '../structs/Result_RouteLightningErrorZ.mjs';
import { InitFeatures } from '../structs/InitFeatures.mjs';
import { Result_PublicKeySecp256k1ErrorZ } from '../structs/Result_PublicKeySecp256k1ErrorZ.mjs';
import { Result_COption_NetworkUpdateZDecodeErrorZ } from '../structs/Result_COption_NetworkUpdateZDecodeErrorZ.mjs';
import { Result_NoneLightningErrorZ } from '../structs/Result_NoneLightningErrorZ.mjs';
import { Result_u64ShortChannelIdErrorZ } from '../structs/Result_u64ShortChannelIdErrorZ.mjs';
import { Result_PendingHTLCInfoInboundHTLCErrZ } from '../structs/Result_PendingHTLCInfoInboundHTLCErrZ.mjs';
import { Result_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ } from '../structs/Result_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ.mjs';
import { Result_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ } from '../structs/Result_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ.mjs';
import { Result_COption_APIErrorZDecodeErrorZ } from '../structs/Result_COption_APIErrorZDecodeErrorZ.mjs';
import { Result_COption_MonitorEventZDecodeErrorZ } from '../structs/Result_COption_MonitorEventZDecodeErrorZ.mjs';
import { Result_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ } from '../structs/Result_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ.mjs';
import { Result_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ } from '../structs/Result_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ.mjs';
import { Result_SocketAddressSocketAddressParseErrorZ } from '../structs/Result_SocketAddressSocketAddressParseErrorZ.mjs';
import { Result_COption_InboundHTLCStateDetailsZDecodeErrorZ } from '../structs/Result_COption_InboundHTLCStateDetailsZDecodeErrorZ.mjs';
import { Result_COption_OutboundHTLCStateDetailsZDecodeErrorZ } from '../structs/Result_COption_OutboundHTLCStateDetailsZDecodeErrorZ.mjs';
import { Option_HTLCClaimZ } from '../structs/Option_HTLCClaimZ.mjs';
import { Result_COption_PathFailureZDecodeErrorZ } from '../structs/Result_COption_PathFailureZDecodeErrorZ.mjs';
import { Result_COption_ClosureReasonZDecodeErrorZ } from '../structs/Result_COption_ClosureReasonZDecodeErrorZ.mjs';
import { Result_COption_HTLCDestinationZDecodeErrorZ } from '../structs/Result_COption_HTLCDestinationZDecodeErrorZ.mjs';
import { Result_COption_PaymentFailureReasonZDecodeErrorZ } from '../structs/Result_COption_PaymentFailureReasonZDecodeErrorZ.mjs';
import { Result_COption_EventZDecodeErrorZ } from '../structs/Result_COption_EventZDecodeErrorZ.mjs';
import { Result_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ } from '../structs/Result_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ.mjs';
import { Result_PeeledOnionNoneZ } from '../structs/Result_PeeledOnionNoneZ.mjs';
import { Result_Bolt11InvoiceSignOrCreationErrorZ } from '../structs/Result_Bolt11InvoiceSignOrCreationErrorZ.mjs';
import { Result_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ } from '../structs/Result_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
export class UtilMethods extends CommonBase {
    /**
     * Gets the 128-bit integer, as 16 little-endian bytes
     */
    static constructor_U128_le_bytes(val) {
        const ret = bindings.U128_le_bytes(bindings.encodeUint128(val));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Constructs a new U128 from 16 little-endian bytes
     */
    static constructor_U128_new(le_bytes) {
        const ret = bindings.U128_new(bindings.encodeUint8Array(bindings.check_arr_len(le_bytes, 16)));
        const ret_conv = bindings.decodeUint128(ret);
        return ret_conv;
    }
    /**
     * Constructs a new COption_NoneZ containing a
     */
    static constructor_COption_NoneZ_some() {
        const ret = bindings.COption_NoneZ_some();
        return ret;
    }
    /**
     * Constructs a new COption_NoneZ containing nothing
     */
    static constructor_COption_NoneZ_none() {
        const ret = bindings.COption_NoneZ_none();
        return ret;
    }
    /**
     * Read a APIError from a byte array, created by APIError_write
     */
    static constructor_APIError_read(ser) {
        const ret = bindings.APIError_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_APIErrorZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Creates a digital signature of a message given a SecretKey, like the node's secret.
     * A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
     * Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
     */
    static constructor_sign(msg, sk) {
        const ret = bindings.sign(bindings.encodeUint8Array(msg), bindings.encodeUint8Array(bindings.check_arr_len(sk, 32)));
        const ret_conv = bindings.decodeString(ret);
        return ret_conv;
    }
    /**
     * Recovers the PublicKey of the signer of the message given the message and the signature.
     */
    static constructor_recover_pk(msg, sig) {
        const ret = bindings.recover_pk(bindings.encodeUint8Array(msg), bindings.encodeString(sig));
        const ret_hu_conv = Result_PublicKeySecp256k1ErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
     * and the PublicKey.
     */
    static constructor_verify(msg, sig, pk) {
        const ret = bindings.verify(bindings.encodeUint8Array(msg), bindings.encodeString(sig), bindings.encodeUint8Array(bindings.check_arr_len(pk, 33)));
        return ret;
    }
    /**
     * Read previously persisted [`ChannelMonitor`]s from the store.
     */
    static constructor_read_channel_monitors(kv_store, entropy_source, signer_provider) {
        const ret = bindings.read_channel_monitors(CommonBase.get_ptr_of(kv_store), CommonBase.get_ptr_of(entropy_source), CommonBase.get_ptr_of(signer_provider));
        const ret_hu_conv = Result_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, kv_store);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        CommonBase.add_ref_from(ret_hu_conv, signer_provider);
        return ret_hu_conv;
    }
    /**
     * Extracts the block height (most significant 3-bytes) from the `short_channel_id`
     */
    static constructor_block_from_scid(short_channel_id) {
        const ret = bindings.block_from_scid(short_channel_id);
        return ret;
    }
    /**
     * Extracts the tx index (bytes [2..4]) from the `short_channel_id`
     */
    static constructor_tx_index_from_scid(short_channel_id) {
        const ret = bindings.tx_index_from_scid(short_channel_id);
        return ret;
    }
    /**
     * Extracts the vout (bytes [0..2]) from the `short_channel_id`
     */
    static constructor_vout_from_scid(short_channel_id) {
        const ret = bindings.vout_from_scid(short_channel_id);
        return ret;
    }
    /**
     * Constructs a `short_channel_id` using the components pieces. Results in an error
     * if the block height, tx index, or vout index overflow the maximum sizes.
     */
    static constructor_scid_from_parts(block, tx_index, vout_index) {
        const ret = bindings.scid_from_parts(block, tx_index, vout_index);
        const ret_hu_conv = Result_u64ShortChannelIdErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a C2Tuple_BestBlockOutputSweeperZ from a byte array, created by C2Tuple_BestBlockOutputSweeperZ_write
     */
    static constructor_C2Tuple_BestBlockOutputSweeperZ_read(ser, arg_a, arg_b, arg_c, arg_d, arg_e, arg_f, arg_g) {
        const ret = bindings.C2Tuple_BestBlockOutputSweeperZ_read(bindings.encodeUint8Array(ser), CommonBase.get_ptr_of(arg_a), CommonBase.get_ptr_of(arg_b), CommonBase.get_ptr_of(arg_c), CommonBase.get_ptr_of(arg_d), CommonBase.get_ptr_of(arg_e), CommonBase.get_ptr_of(arg_f), CommonBase.get_ptr_of(arg_g));
        const ret_hu_conv = Result_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, arg_a);
        CommonBase.add_ref_from(ret_hu_conv, arg_b);
        CommonBase.add_ref_from(ret_hu_conv, arg_c);
        CommonBase.add_ref_from(ret_hu_conv, arg_d);
        CommonBase.add_ref_from(ret_hu_conv, arg_e);
        CommonBase.add_ref_from(ret_hu_conv, arg_f);
        CommonBase.add_ref_from(ret_hu_conv, arg_g);
        return ret_hu_conv;
    }
    /**
     * Read a MonitorEvent from a byte array, created by MonitorEvent_write
     */
    static constructor_MonitorEvent_read(ser) {
        const ret = bindings.MonitorEvent_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_MonitorEventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a C2Tuple_ThirtyTwoBytesChannelMonitorZ from a byte array, created by C2Tuple_ThirtyTwoBytesChannelMonitorZ_write
     */
    static constructor_C2Tuple_ThirtyTwoBytesChannelMonitorZ_read(ser, arg_a, arg_b) {
        const ret = bindings.C2Tuple_ThirtyTwoBytesChannelMonitorZ_read(bindings.encodeUint8Array(ser), CommonBase.get_ptr_of(arg_a), CommonBase.get_ptr_of(arg_b));
        const ret_hu_conv = Result_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, arg_a);
        CommonBase.add_ref_from(ret_hu_conv, arg_b);
        return ret_hu_conv;
    }
    /**
     * Peel one layer off an incoming onion, returning a [`PendingHTLCInfo`] that contains information
     * about the intended next-hop for the HTLC.
     *
     * This does all the relevant context-free checks that LDK requires for payment relay or
     * acceptance. If the payment is to be received, and the amount matches the expected amount for
     * a given invoice, this indicates the [`msgs::UpdateAddHTLC`], once fully committed in the
     * channel, will generate an [`Event::PaymentClaimable`].
     *
     * [`Event::PaymentClaimable`]: crate::events::Event::PaymentClaimable
     */
    static constructor_peel_payment_onion(msg, node_signer, logger, cur_height, accept_mpp_keysend, allow_skimmed_fees) {
        const ret = bindings.peel_payment_onion(CommonBase.get_ptr_of(msg), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), cur_height, accept_mpp_keysend, allow_skimmed_fees);
        const ret_hu_conv = Result_PendingHTLCInfoInboundHTLCErrZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, msg);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * Fetches the set of [`InitFeatures`] flags that are provided by or required by
     * [`ChannelManager`].
     */
    static constructor_provided_init_features(config) {
        const ret = bindings.provided_init_features(CommonBase.get_ptr_of(config));
        const ret_hu_conv = new InitFeatures(null, ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        CommonBase.add_ref_from(ret_hu_conv, config);
        return ret_hu_conv;
    }
    /**
     * Read a C2Tuple_ThirtyTwoBytesChannelManagerZ from a byte array, created by C2Tuple_ThirtyTwoBytesChannelManagerZ_write
     */
    static constructor_C2Tuple_ThirtyTwoBytesChannelManagerZ_read(ser, arg_entropy_source, arg_node_signer, arg_signer_provider, arg_fee_estimator, arg_chain_monitor, arg_tx_broadcaster, arg_router, arg_logger, arg_default_config, arg_channel_monitors) {
        const ret = bindings.C2Tuple_ThirtyTwoBytesChannelManagerZ_read(bindings.encodeUint8Array(ser), bindings.ChannelManagerReadArgs_new(CommonBase.get_ptr_of(arg_entropy_source), CommonBase.get_ptr_of(arg_node_signer), CommonBase.get_ptr_of(arg_signer_provider), CommonBase.get_ptr_of(arg_fee_estimator), CommonBase.get_ptr_of(arg_chain_monitor), CommonBase.get_ptr_of(arg_tx_broadcaster), CommonBase.get_ptr_of(arg_router), CommonBase.get_ptr_of(arg_logger), CommonBase.get_ptr_of(arg_default_config), bindings.encodeUint64Array(arg_channel_monitors.map(arg_channel_monitors_conv_16 => CommonBase.get_ptr_of(arg_channel_monitors_conv_16)))));
        const ret_hu_conv = Result_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, arg_entropy_source);
        CommonBase.add_ref_from(ret_hu_conv, arg_node_signer);
        CommonBase.add_ref_from(ret_hu_conv, arg_signer_provider);
        CommonBase.add_ref_from(ret_hu_conv, arg_fee_estimator);
        CommonBase.add_ref_from(ret_hu_conv, arg_chain_monitor);
        CommonBase.add_ref_from(ret_hu_conv, arg_tx_broadcaster);
        CommonBase.add_ref_from(ret_hu_conv, arg_router);
        CommonBase.add_ref_from(ret_hu_conv, arg_logger);
        ;
        arg_channel_monitors.forEach((arg_channel_monitors_conv_16) => { CommonBase.add_ref_from(ret_hu_conv, arg_channel_monitors_conv_16); });
        return ret_hu_conv;
    }
    /**
     * Adds a tweak to a public key to derive a new public key.
     *
     * May panic if `tweak` is not the output of a SHA-256 hash.
     */
    static constructor_add_public_key_tweak(base_point, tweak) {
        const ret = bindings.add_public_key_tweak(bindings.encodeUint8Array(bindings.check_arr_len(base_point, 33)), bindings.encodeUint8Array(bindings.check_arr_len(tweak, 32)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Read a InboundHTLCStateDetails from a byte array, created by InboundHTLCStateDetails_write
     */
    static constructor_InboundHTLCStateDetails_read(ser) {
        const ret = bindings.InboundHTLCStateDetails_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_InboundHTLCStateDetailsZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a OutboundHTLCStateDetails from a byte array, created by OutboundHTLCStateDetails_write
     */
    static constructor_OutboundHTLCStateDetails_read(ser) {
        const ret = bindings.OutboundHTLCStateDetails_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_OutboundHTLCStateDetailsZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment`], but no
     * `ChannelManager` is required. Useful for generating invoices for [phantom node payments] without
     * a `ChannelManager`.
     *
     * `keys` is generated by calling [`NodeSigner::get_inbound_payment_key_material`] and then
     * calling [`ExpandedKey::new`] with its result. It is recommended to cache this value and not
     * regenerate it for each new inbound payment.
     *
     * `current_time` is a Unix timestamp representing the current time.
     *
     * Note that if `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
     * on versions of LDK prior to 0.0.114.
     *
     * [phantom node payments]: crate::sign::PhantomKeysManager
     * [`NodeSigner::get_inbound_payment_key_material`]: crate::sign::NodeSigner::get_inbound_payment_key_material
     */
    static constructor_create(keys, min_value_msat, invoice_expiry_delta_secs, entropy_source, current_time, min_final_cltv_expiry_delta) {
        const ret = bindings.create(CommonBase.get_ptr_of(keys), CommonBase.get_ptr_of(min_value_msat), invoice_expiry_delta_secs, CommonBase.get_ptr_of(entropy_source), current_time, CommonBase.get_ptr_of(min_final_cltv_expiry_delta));
        const ret_hu_conv = Result_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, keys);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        return ret_hu_conv;
    }
    /**
     * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash`],
     * but no `ChannelManager` is required. Useful for generating invoices for [phantom node payments]
     * without a `ChannelManager`.
     *
     * See [`create`] for information on the `keys` and `current_time` parameters.
     *
     * Note that if `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
     * on versions of LDK prior to 0.0.114.
     *
     * [phantom node payments]: crate::sign::PhantomKeysManager
     */
    static constructor_create_from_hash(keys, min_value_msat, payment_hash, invoice_expiry_delta_secs, current_time, min_final_cltv_expiry_delta) {
        const ret = bindings.create_from_hash(CommonBase.get_ptr_of(keys), CommonBase.get_ptr_of(min_value_msat), bindings.encodeUint8Array(bindings.check_arr_len(payment_hash, 32)), invoice_expiry_delta_secs, current_time, CommonBase.get_ptr_of(min_final_cltv_expiry_delta));
        const ret_hu_conv = Result_ThirtyTwoBytesNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, keys);
        return ret_hu_conv;
    }
    /**
     * Parses an OnionV3 host and port into a [`SocketAddress::OnionV3`].
     *
     * The host part must end with \".onion\".
     */
    static constructor_parse_onion_address(host, port) {
        const ret = bindings.parse_onion_address(bindings.encodeString(host), port);
        const ret_hu_conv = Result_SocketAddressSocketAddressParseErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Gets the weight for an HTLC-Success transaction.
     */
    static constructor_htlc_success_tx_weight(channel_type_features) {
        const ret = bindings.htlc_success_tx_weight(CommonBase.get_ptr_of(channel_type_features));
        return ret;
    }
    /**
     * Gets the weight for an HTLC-Timeout transaction.
     */
    static constructor_htlc_timeout_tx_weight(channel_type_features) {
        const ret = bindings.htlc_timeout_tx_weight(CommonBase.get_ptr_of(channel_type_features));
        return ret;
    }
    /**
     * Check if a given input witness attempts to claim a HTLC.
     */
    static constructor_HTLCClaim_from_witness(witness) {
        const ret = bindings.HTLCClaim_from_witness(bindings.encodeUint8Array(witness));
        const ret_hu_conv = Option_HTLCClaimZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, ret_hu_conv);
        return ret_hu_conv;
    }
    /**
     * Build the commitment secret from the seed and the commitment number
     */
    static constructor_build_commitment_secret(commitment_seed, idx) {
        const ret = bindings.build_commitment_secret(bindings.encodeUint8Array(bindings.check_arr_len(commitment_seed, 32)), idx);
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Build a closing transaction
     */
    static constructor_build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint) {
        const ret = bindings.build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, bindings.encodeUint8Array(to_holder_script), bindings.encodeUint8Array(to_counterparty_script), CommonBase.get_ptr_of(funding_outpoint));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
     * from the base secret and the per_commitment_point.
     */
    static constructor_derive_private_key(per_commitment_point, base_secret) {
        const ret = bindings.derive_private_key(bindings.encodeUint8Array(bindings.check_arr_len(per_commitment_point, 33)), bindings.encodeUint8Array(bindings.check_arr_len(base_secret, 32)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Derives a per-commitment-transaction revocation key from its constituent parts.
     *
     * Only the cheating participant owns a valid witness to propagate a revoked
     * commitment transaction, thus per_commitment_secret always come from cheater
     * and revocation_base_secret always come from punisher, which is the broadcaster
     * of the transaction spending with this key knowledge.
     */
    static constructor_derive_private_revocation_key(per_commitment_secret, countersignatory_revocation_base_secret) {
        const ret = bindings.derive_private_revocation_key(bindings.encodeUint8Array(bindings.check_arr_len(per_commitment_secret, 32)), bindings.encodeUint8Array(bindings.check_arr_len(countersignatory_revocation_base_secret, 32)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * A script either spendable by the revocation
     * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
     * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
     */
    static constructor_get_revokeable_redeemscript(revocation_key, contest_delay, broadcaster_delayed_payment_key) {
        const ret = bindings.get_revokeable_redeemscript(CommonBase.get_ptr_of(revocation_key), contest_delay, CommonBase.get_ptr_of(broadcaster_delayed_payment_key));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the script for the counterparty's output on a holder's commitment transaction based on
     * the channel type.
     */
    static constructor_get_counterparty_payment_script(channel_type_features, payment_key) {
        const ret = bindings.get_counterparty_payment_script(CommonBase.get_ptr_of(channel_type_features), bindings.encodeUint8Array(bindings.check_arr_len(payment_key, 33)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
     * does not need to have its previous_output_index filled.
     */
    static constructor_get_htlc_redeemscript(htlc, channel_type_features, keys) {
        const ret = bindings.get_htlc_redeemscript(CommonBase.get_ptr_of(htlc), CommonBase.get_ptr_of(channel_type_features), CommonBase.get_ptr_of(keys));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Gets the redeemscript for a funding output from the two funding public keys.
     * Note that the order of funding public keys does not matter.
     */
    static constructor_make_funding_redeemscript(broadcaster, countersignatory) {
        const ret = bindings.make_funding_redeemscript(bindings.encodeUint8Array(bindings.check_arr_len(broadcaster, 33)), bindings.encodeUint8Array(bindings.check_arr_len(countersignatory, 33)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
     * parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
     * transaction which needs signing, and can be used to construct an HTLC transaction which is
     * broadcastable given a counterparty HTLC signature.
     *
     * Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
     * commitment transaction).
     */
    static constructor_build_htlc_transaction(commitment_txid, feerate_per_kw, contest_delay, htlc, channel_type_features, broadcaster_delayed_payment_key, revocation_key) {
        const ret = bindings.build_htlc_transaction(bindings.encodeUint8Array(bindings.check_arr_len(commitment_txid, 32)), feerate_per_kw, contest_delay, CommonBase.get_ptr_of(htlc), CommonBase.get_ptr_of(channel_type_features), CommonBase.get_ptr_of(broadcaster_delayed_payment_key), CommonBase.get_ptr_of(revocation_key));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the witness required to satisfy and spend a HTLC input.
     */
    static constructor_build_htlc_input_witness(local_sig, remote_sig, preimage, redeem_script, channel_type_features) {
        const ret = bindings.build_htlc_input_witness(bindings.encodeUint8Array(bindings.check_arr_len(local_sig, 64)), bindings.encodeUint8Array(bindings.check_arr_len(remote_sig, 64)), CommonBase.get_ptr_of(preimage), bindings.encodeUint8Array(redeem_script), CommonBase.get_ptr_of(channel_type_features));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Gets the witnessScript for the to_remote output when anchors are enabled.
     */
    static constructor_get_to_countersignatory_with_anchors_redeemscript(payment_point) {
        const ret = bindings.get_to_countersignatory_with_anchors_redeemscript(bindings.encodeUint8Array(bindings.check_arr_len(payment_point, 33)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Gets the witnessScript for an anchor output from the funding public key.
     * The witness in the spending input must be:
     * <BIP 143 funding_signature>
     * After 16 blocks of confirmation, an alternative satisfying witness could be:
     * <>
     * (empty vector required to satisfy compliance with MINIMALIF-standard rule)
     */
    static constructor_get_anchor_redeemscript(funding_pubkey) {
        const ret = bindings.get_anchor_redeemscript(bindings.encodeUint8Array(bindings.check_arr_len(funding_pubkey, 33)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Returns the witness required to satisfy and spend an anchor input.
     */
    static constructor_build_anchor_input_witness(funding_key, funding_sig) {
        const ret = bindings.build_anchor_input_witness(bindings.encodeUint8Array(bindings.check_arr_len(funding_key, 33)), bindings.encodeUint8Array(bindings.check_arr_len(funding_sig, 64)));
        const ret_conv = bindings.decodeUint8Array(ret);
        return ret_conv;
    }
    /**
     * Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
     * shared secret first. This prevents on-chain observers from discovering how many commitment
     * transactions occurred in a channel before it was closed.
     *
     * This function gets the shared secret from relevant channel public keys and can be used to
     * \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
     */
    static constructor_get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint, countersignatory_payment_basepoint, outbound_from_broadcaster) {
        const ret = bindings.get_commitment_transaction_number_obscure_factor(bindings.encodeUint8Array(bindings.check_arr_len(broadcaster_payment_basepoint, 33)), bindings.encodeUint8Array(bindings.check_arr_len(countersignatory_payment_basepoint, 33)), outbound_from_broadcaster);
        return ret;
    }
    /**
     * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
     * See [`PhantomKeysManager`] for more information on phantom node payments.
     *
     * `phantom_route_hints` parameter:
     * Contains channel info for all nodes participating in the phantom invoice
     * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
     * participating node
     * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
     * updated when a channel becomes disabled or closes
     * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
     * may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
     * down
     *
     * `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
     * between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
     * If `None` is provided for `payment_hash`, then one will be created.
     *
     * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
     * in excess of the current time.
     *
     * `duration_since_epoch` is the current time since epoch in seconds.
     *
     * You can specify a custom `min_final_cltv_expiry_delta`, or let LDK default it to
     * [`MIN_FINAL_CLTV_EXPIRY_DELTA`]. The provided expiry must be at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`] - 3.
     * Note that LDK will add a buffer of 3 blocks to the delta to allow for up to a few new block
     * confirmations during routing.
     *
     * Note that the provided `keys_manager`'s `NodeSigner` implementation must support phantom
     * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
     * requirement).
     *
     * [`PhantomKeysManager`]: crate::sign::PhantomKeysManager
     * [`ChannelManager::get_phantom_route_hints`]: crate::ln::channelmanager::ChannelManager::get_phantom_route_hints
     * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
     * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
     * [`PhantomRouteHints::channels`]: crate::ln::channelmanager::PhantomRouteHints::channels
     * [`MIN_FINAL_CLTV_EXPIRY_DETLA`]: crate::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA
     *
     * This can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
     * available and the current time is supplied by the caller.
     */
    static constructor_create_phantom_invoice(amt_msat, payment_hash, description, invoice_expiry_delta_secs, phantom_route_hints, entropy_source, node_signer, logger, network, min_final_cltv_expiry_delta, duration_since_epoch) {
        const ret = bindings.create_phantom_invoice(CommonBase.get_ptr_of(amt_msat), CommonBase.get_ptr_of(payment_hash), bindings.encodeString(description), invoice_expiry_delta_secs, bindings.encodeUint64Array(phantom_route_hints.map(phantom_route_hints_conv_19 => CommonBase.get_ptr_of(phantom_route_hints_conv_19))), CommonBase.get_ptr_of(entropy_source), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), network, CommonBase.get_ptr_of(min_final_cltv_expiry_delta), duration_since_epoch);
        const ret_hu_conv = Result_Bolt11InvoiceSignOrCreationErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
     * See [`PhantomKeysManager`] for more information on phantom node payments.
     *
     * `phantom_route_hints` parameter:
     * Contains channel info for all nodes participating in the phantom invoice
     * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
     * participating node
     * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
     * updated when a channel becomes disabled or closes
     * Note that the route hints generated from `phantom_route_hints` will be limited to a maximum
     * of 3 hints to ensure that the invoice can be scanned in a QR code. These hints are selected
     * in the order that the nodes in `PhantomRouteHints` are specified, selecting one hint per node
     * until the maximum is hit. Callers may provide as many `PhantomRouteHints::channels` as
     * desired, but note that some nodes will be trimmed if more than 3 nodes are provided.
     *
     * `description_hash` is a SHA-256 hash of the description text
     *
     * `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
     * between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
     * If `None` is provided for `payment_hash`, then one will be created.
     *
     * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
     * in excess of the current time.
     *
     * `duration_since_epoch` is the current time since epoch in seconds.
     *
     * Note that the provided `keys_manager`'s `NodeSigner` implementation must support phantom
     * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
     * requirement).
     *
     * [`PhantomKeysManager`]: crate::sign::PhantomKeysManager
     * [`ChannelManager::get_phantom_route_hints`]: crate::ln::channelmanager::ChannelManager::get_phantom_route_hints
     * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
     * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
     * [`PhantomRouteHints::channels`]: crate::ln::channelmanager::PhantomRouteHints::channels
     *
     * This can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
     * available and the current time is supplied by the caller.
     */
    static constructor_create_phantom_invoice_with_description_hash(amt_msat, payment_hash, invoice_expiry_delta_secs, description_hash, phantom_route_hints, entropy_source, node_signer, logger, network, min_final_cltv_expiry_delta, duration_since_epoch) {
        const ret = bindings.create_phantom_invoice_with_description_hash(CommonBase.get_ptr_of(amt_msat), CommonBase.get_ptr_of(payment_hash), invoice_expiry_delta_secs, CommonBase.get_ptr_of(description_hash), bindings.encodeUint64Array(phantom_route_hints.map(phantom_route_hints_conv_19 => CommonBase.get_ptr_of(phantom_route_hints_conv_19))), CommonBase.get_ptr_of(entropy_source), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), network, CommonBase.get_ptr_of(min_final_cltv_expiry_delta), duration_since_epoch);
        const ret_hu_conv = Result_Bolt11InvoiceSignOrCreationErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * See [`create_invoice_from_channelmanager_with_description_hash`]
     * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
     * available and the current time is supplied by the caller.
     */
    static constructor_create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(channelmanager, node_signer, logger, network, amt_msat, description_hash, duration_since_epoch, invoice_expiry_delta_secs, min_final_cltv_expiry_delta) {
        const ret = bindings.create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(CommonBase.get_ptr_of(channelmanager), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), network, CommonBase.get_ptr_of(amt_msat), CommonBase.get_ptr_of(description_hash), duration_since_epoch, invoice_expiry_delta_secs, CommonBase.get_ptr_of(min_final_cltv_expiry_delta));
        const ret_hu_conv = Result_Bolt11InvoiceSignOrCreationErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, channelmanager);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * See [`create_invoice_from_channelmanager`]
     * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
     * available and the current time is supplied by the caller.
     */
    static constructor_create_invoice_from_channelmanager_and_duration_since_epoch(channelmanager, node_signer, logger, network, amt_msat, description, duration_since_epoch, invoice_expiry_delta_secs, min_final_cltv_expiry_delta) {
        const ret = bindings.create_invoice_from_channelmanager_and_duration_since_epoch(CommonBase.get_ptr_of(channelmanager), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), network, CommonBase.get_ptr_of(amt_msat), bindings.encodeString(description), duration_since_epoch, invoice_expiry_delta_secs, CommonBase.get_ptr_of(min_final_cltv_expiry_delta));
        const ret_hu_conv = Result_Bolt11InvoiceSignOrCreationErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, channelmanager);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * See [`create_invoice_from_channelmanager_and_duration_since_epoch`]
     * This version allows for providing a custom [`PaymentHash`] for the invoice.
     * This may be useful if you're building an on-chain swap or involving another protocol where
     * the payment hash is also involved outside the scope of lightning.
     */
    static constructor_create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(channelmanager, node_signer, logger, network, amt_msat, description, duration_since_epoch, invoice_expiry_delta_secs, payment_hash, min_final_cltv_expiry_delta) {
        const ret = bindings.create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(CommonBase.get_ptr_of(channelmanager), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), network, CommonBase.get_ptr_of(amt_msat), bindings.encodeString(description), duration_since_epoch, invoice_expiry_delta_secs, bindings.encodeUint8Array(bindings.check_arr_len(payment_hash, 32)), CommonBase.get_ptr_of(min_final_cltv_expiry_delta));
        const ret_hu_conv = Result_Bolt11InvoiceSignOrCreationErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, channelmanager);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * Builds the necessary parameters to pay or pre-flight probe the given zero-amount
     * [`Bolt11Invoice`] using [`ChannelManager::send_payment`] or
     * [`ChannelManager::send_preflight_probes`].
     *
     * Prior to paying, you must ensure that the [`Bolt11Invoice::payment_hash`] is unique and the
     * same [`PaymentHash`] has never been paid before.
     *
     * Will always succeed unless the invoice has an amount specified, in which case
     * [`payment_parameters_from_invoice`] should be used.
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     * [`ChannelManager::send_preflight_probes`]: crate::ln::channelmanager::ChannelManager::send_preflight_probes
     */
    static constructor_payment_parameters_from_zero_amount_invoice(invoice, amount_msat) {
        const ret = bindings.payment_parameters_from_zero_amount_invoice(CommonBase.get_ptr_of(invoice), amount_msat);
        const ret_hu_conv = Result_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, invoice);
        return ret_hu_conv;
    }
    /**
     * Builds the necessary parameters to pay or pre-flight probe the given [`Bolt11Invoice`] using
     * [`ChannelManager::send_payment`] or [`ChannelManager::send_preflight_probes`].
     *
     * Prior to paying, you must ensure that the [`Bolt11Invoice::payment_hash`] is unique and the
     * same [`PaymentHash`] has never been paid before.
     *
     * Will always succeed unless the invoice has no amount specified, in which case
     * [`payment_parameters_from_zero_amount_invoice`] should be used.
     *
     * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
     * [`ChannelManager::send_preflight_probes`]: crate::ln::channelmanager::ChannelManager::send_preflight_probes
     */
    static constructor_payment_parameters_from_invoice(invoice) {
        const ret = bindings.payment_parameters_from_invoice(CommonBase.get_ptr_of(invoice));
        const ret_hu_conv = Result_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, invoice);
        return ret_hu_conv;
    }
    /**
     * Read a NetworkUpdate from a byte array, created by NetworkUpdate_write
     */
    static constructor_NetworkUpdate_read(ser) {
        const ret = bindings.NetworkUpdate_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_NetworkUpdateZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Verifies the signature of a [`NodeAnnouncement`].
     *
     * Returns an error if it is invalid.
     */
    static constructor_verify_node_announcement(msg) {
        const ret = bindings.verify_node_announcement(CommonBase.get_ptr_of(msg));
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, msg);
        return ret_hu_conv;
    }
    /**
     * Verifies all signatures included in a [`ChannelAnnouncement`].
     *
     * Returns an error if one of the signatures is invalid.
     */
    static constructor_verify_channel_announcement(msg) {
        const ret = bindings.verify_channel_announcement(CommonBase.get_ptr_of(msg));
        const ret_hu_conv = Result_NoneLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, msg);
        return ret_hu_conv;
    }
    /**
     * Finds a route from us (payer) to the given target node (payee).
     *
     * If the payee provided features in their invoice, they should be provided via the `payee` field
     * in the given [`RouteParameters::payment_params`].
     * Without this, MPP will only be used if the payee's features are available in the network graph.
     *
     * Private routing paths between a public node and the target may be included in the `payee` field
     * of [`RouteParameters::payment_params`].
     *
     * If some channels aren't announced, it may be useful to fill in `first_hops` with the results
     * from [`ChannelManager::list_usable_channels`]. If it is filled in, the view of these channels
     * from `network_graph` will be ignored, and only those in `first_hops` will be used.
     *
     * The fees on channels from us to the next hop are ignored as they are assumed to all be equal.
     * However, the enabled/disabled bit on such channels as well as the `htlc_minimum_msat` /
     * `htlc_maximum_msat` *are* checked as they may change based on the receiving node.
     *
     * # Panics
     *
     * Panics if first_hops contains channels without `short_channel_id`s;
     * [`ChannelManager::list_usable_channels`] will never include such channels.
     *
     * [`ChannelManager::list_usable_channels`]: crate::ln::channelmanager::ChannelManager::list_usable_channels
     * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
     * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
     *
     * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    static constructor_find_route(our_node_pubkey, route_params, network_graph, first_hops, logger, scorer, score_params, random_seed_bytes) {
        const ret = bindings.find_route(bindings.encodeUint8Array(bindings.check_arr_len(our_node_pubkey, 33)), CommonBase.get_ptr_of(route_params), CommonBase.get_ptr_of(network_graph), bindings.encodeUint64Array(first_hops != null ? first_hops.map(first_hops_conv_16 => CommonBase.get_ptr_of(first_hops_conv_16)) : null), CommonBase.get_ptr_of(logger), CommonBase.get_ptr_of(scorer), CommonBase.get_ptr_of(score_params), bindings.encodeUint8Array(bindings.check_arr_len(random_seed_bytes, 32)));
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, route_params);
        CommonBase.add_ref_from(ret_hu_conv, network_graph);
        if (first_hops != null) {
            first_hops.forEach((first_hops_conv_16) => { CommonBase.add_ref_from(ret_hu_conv, first_hops_conv_16); });
        }
        ;
        CommonBase.add_ref_from(ret_hu_conv, logger);
        CommonBase.add_ref_from(ret_hu_conv, scorer);
        CommonBase.add_ref_from(ret_hu_conv, score_params);
        return ret_hu_conv;
    }
    /**
     * Construct a route from us (payer) to the target node (payee) via the given hops (which should
     * exclude the payer, but include the payee). This may be useful, e.g., for probing the chosen path.
     *
     * Re-uses logic from `find_route`, so the restrictions described there also apply here.
     */
    static constructor_build_route_from_hops(our_node_pubkey, hops, route_params, network_graph, logger, random_seed_bytes) {
        const ret = bindings.build_route_from_hops(bindings.encodeUint8Array(bindings.check_arr_len(our_node_pubkey, 33)), bindings.encodeUint32Array(hops.map(hops_conv_12 => bindings.encodeUint8Array(bindings.check_arr_len(hops_conv_12, 33)))), CommonBase.get_ptr_of(route_params), CommonBase.get_ptr_of(network_graph), CommonBase.get_ptr_of(logger), bindings.encodeUint8Array(bindings.check_arr_len(random_seed_bytes, 32)));
        const ret_hu_conv = Result_RouteLightningErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, route_params);
        CommonBase.add_ref_from(ret_hu_conv, network_graph);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        return ret_hu_conv;
    }
    /**
     * Creates an unsigned [`Psbt`] which spends the given descriptors to
     * the given outputs, plus an output to the given change destination (if sufficient
     * change value remains). The PSBT will have a feerate, at least, of the given value.
     *
     * The `locktime` argument is used to set the transaction's locktime. If `None`, the
     * transaction will have a locktime of 0. It it recommended to set this to the current block
     * height to avoid fee sniping, unless you have some specific reason to use a different
     * locktime.
     *
     * Returns the PSBT and expected max transaction weight.
     *
     * Returns `Err(())` if the output value is greater than the input value minus required fee,
     * if a descriptor was duplicated, or if an output descriptor `script_pubkey`
     * does not match the one we can spend.
     *
     * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
     */
    static constructor_SpendableOutputDescriptor_create_spendable_outputs_psbt(descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight, locktime) {
        const ret = bindings.SpendableOutputDescriptor_create_spendable_outputs_psbt(bindings.encodeUint64Array(descriptors.map(descriptors_conv_27 => CommonBase.get_ptr_of(descriptors_conv_27))), bindings.encodeUint64Array(outputs.map(outputs_conv_7 => CommonBase.get_ptr_of(outputs_conv_7))), bindings.encodeUint8Array(change_destination_script), feerate_sat_per_1000_weight, CommonBase.get_ptr_of(locktime));
        const ret_hu_conv = Result_C2Tuple_CVec_u8Zu64ZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns whether `tlv_type` corresponds to a TLV record for async payment messages.
     */
    static constructor_AsyncPaymentsMessage_is_known_type(tlv_type) {
        const ret = bindings.AsyncPaymentsMessage_is_known_type(tlv_type);
        return ret;
    }
    /**
     * Creates an [`OnionMessage`] with the given `contents` for sending to the destination of
     * `path`, first calling [`Destination::resolve`] on `path.destination` with the given
     * [`ReadOnlyNetworkGraph`].
     *
     * Returns the node id of the peer to send the message to, the message itself, and any addresses
     * needed to connect to the first node.
     *
     * Note that reply_path (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    static constructor_create_onion_message_resolving_destination(entropy_source, node_signer, node_id_lookup, network_graph, path, contents, reply_path) {
        const ret = bindings.create_onion_message_resolving_destination(CommonBase.get_ptr_of(entropy_source), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(node_id_lookup), CommonBase.get_ptr_of(network_graph), CommonBase.get_ptr_of(path), CommonBase.get_ptr_of(contents), reply_path == null ? 0n : CommonBase.get_ptr_of(reply_path));
        const ret_hu_conv = Result_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, node_id_lookup);
        CommonBase.add_ref_from(ret_hu_conv, network_graph);
        CommonBase.add_ref_from(ret_hu_conv, contents);
        return ret_hu_conv;
    }
    /**
     * Creates an [`OnionMessage`] with the given `contents` for sending to the destination of
     * `path`.
     *
     * Returns the node id of the peer to send the message to, the message itself, and any addresses
     * needed to connect to the first node.
     *
     * Returns [`SendError::UnresolvedIntroductionNode`] if:
     * - `destination` contains a blinded path with an [`IntroductionNode::DirectedShortChannelId`],
     * - unless it can be resolved by [`NodeIdLookUp::next_node_id`].
     * Use [`create_onion_message_resolving_destination`] instead to resolve the introduction node
     * first with a [`ReadOnlyNetworkGraph`].
     *
     * Note that reply_path (or a relevant inner pointer) may be NULL or all-0s to represent None
     */
    static constructor_create_onion_message(entropy_source, node_signer, node_id_lookup, path, contents, reply_path) {
        const ret = bindings.create_onion_message(CommonBase.get_ptr_of(entropy_source), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(node_id_lookup), CommonBase.get_ptr_of(path), CommonBase.get_ptr_of(contents), reply_path == null ? 0n : CommonBase.get_ptr_of(reply_path));
        const ret_hu_conv = Result_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, entropy_source);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, node_id_lookup);
        CommonBase.add_ref_from(ret_hu_conv, contents);
        return ret_hu_conv;
    }
    /**
     * Decode one layer of an incoming [`OnionMessage`].
     *
     * Returns either the next layer of the onion for forwarding or the decrypted content for the
     * receiver.
     */
    static constructor_peel_onion_message(msg, node_signer, logger, custom_handler) {
        const ret = bindings.peel_onion_message(CommonBase.get_ptr_of(msg), CommonBase.get_ptr_of(node_signer), CommonBase.get_ptr_of(logger), CommonBase.get_ptr_of(custom_handler));
        const ret_hu_conv = Result_PeeledOnionNoneZ.constr_from_ptr(ret);
        CommonBase.add_ref_from(ret_hu_conv, msg);
        CommonBase.add_ref_from(ret_hu_conv, node_signer);
        CommonBase.add_ref_from(ret_hu_conv, logger);
        CommonBase.add_ref_from(ret_hu_conv, custom_handler);
        return ret_hu_conv;
    }
    /**
     * Returns whether `tlv_type` corresponds to a TLV record for Offers.
     */
    static constructor_OffersMessage_is_known_type(tlv_type) {
        const ret = bindings.OffersMessage_is_known_type(tlv_type);
        return ret;
    }
    /**
     * Read a PathFailure from a byte array, created by PathFailure_write
     */
    static constructor_PathFailure_read(ser) {
        const ret = bindings.PathFailure_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_PathFailureZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a ClosureReason from a byte array, created by ClosureReason_write
     */
    static constructor_ClosureReason_read(ser) {
        const ret = bindings.ClosureReason_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_ClosureReasonZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a HTLCDestination from a byte array, created by HTLCDestination_write
     */
    static constructor_HTLCDestination_read(ser) {
        const ret = bindings.HTLCDestination_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_HTLCDestinationZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a PaymentFailureReason from a byte array, created by PaymentFailureReason_write
     */
    static constructor_PaymentFailureReason_read(ser) {
        const ret = bindings.PaymentFailureReason_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_PaymentFailureReasonZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Read a Event from a byte array, created by Event_write
     */
    static constructor_Event_read(ser) {
        const ret = bindings.Event_read(bindings.encodeUint8Array(ser));
        const ret_hu_conv = Result_COption_EventZDecodeErrorZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=UtilMethods.mjs.map