import { Result_TransactionNoneZ } from '../structs/Result_TransactionNoneZ.mjs';
import { Result_CVec_u8ZNoneZ } from '../structs/Result_CVec_u8ZNoneZ.mjs';
import { Result_CVec_UtxoZNoneZ } from '../structs/Result_CVec_UtxoZNoneZ.mjs';
import { CommonBase } from './CommonBase.mjs';
import * as bindings from '../bindings.mjs';
class LDKWalletSourceHolder {
    constructor() {
        this.held = null;
    }
}
/**
 * An alternative to [`CoinSelectionSource`] that can be implemented and used along [`Wallet`] to
 * provide a default implementation to [`CoinSelectionSource`].
 */
export class WalletSource extends CommonBase {
    /* @internal */
    constructor(_dummy, ptr) {
        super(ptr, bindings.WalletSource_free);
        this.bindings_instance = null;
    }
    /** Creates a new instance of WalletSource from a given implementation */
    static new_impl(arg) {
        const impl_holder = new LDKWalletSourceHolder();
        let structImplementation = {
            list_confirmed_utxos() {
                const ret = arg.list_confirmed_utxos();
                const result = ret.clone_ptr();
                return result;
            },
            get_change_script() {
                const ret = arg.get_change_script();
                const result = ret.clone_ptr();
                return result;
            },
            sign_psbt(psbt) {
                const psbt_conv = bindings.decodeUint8Array(psbt);
                const ret = arg.sign_psbt(psbt_conv);
                const result = ret.clone_ptr();
                return result;
            },
        };
        const ptr_idx = bindings.LDKWalletSource_new(structImplementation);
        impl_holder.held = new WalletSource(null, ptr_idx[0]);
        impl_holder.held.instance_idx = ptr_idx[1];
        impl_holder.held.bindings_instance = structImplementation;
        return impl_holder.held;
    }
    /**
     * Returns all UTXOs, with at least 1 confirmation each, that are available to spend.
     */
    list_confirmed_utxos() {
        const ret = bindings.WalletSource_list_confirmed_utxos(this.ptr);
        const ret_hu_conv = Result_CVec_UtxoZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Returns a script to use for change above dust resulting from a successful coin selection
     * attempt.
     */
    get_change_script() {
        const ret = bindings.WalletSource_get_change_script(this.ptr);
        const ret_hu_conv = Result_CVec_u8ZNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
    /**
     * Signs and provides the full [`TxIn::script_sig`] and [`TxIn::witness`] for all inputs within
     * the transaction known to the wallet (i.e., any provided via
     * [`WalletSource::list_confirmed_utxos`]).
     *
     * If your wallet does not support signing PSBTs you can call `psbt.extract_tx()` to get the
     * unsigned transaction and then sign it with your wallet.
     */
    sign_psbt(psbt) {
        const ret = bindings.WalletSource_sign_psbt(this.ptr, bindings.encodeUint8Array(psbt));
        const ret_hu_conv = Result_TransactionNoneZ.constr_from_ptr(ret);
        return ret_hu_conv;
    }
}
//# sourceMappingURL=WalletSource.mjs.map